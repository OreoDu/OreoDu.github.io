{"title":"Memory Management","date":"2020-10-25T00:07:00.000Z","date_formatted":{"ll":"Oct 25, 2020","L":"10/25/2020","MM-DD":"10-25"},"link":"2020/20201025-Memory-Management","comments":true,"tags":["Operating System"],"categories":["Linux","Operating System"],"updated":"2020-10-26T00:50:44.134Z","content":"<h1 id=\"memory-management\">Memory Management<a title=\"#memory-management\" href=\"#memory-management\"></a></h1>\n<h2 id=\"part.1-address-space-and-memory-descripter\">Part.1 Address space and memory descripter<a title=\"#part.1-address-space-and-memory-descripter\" href=\"#part.1-address-space-and-memory-descripter\"></a></h2>\n<h3 id=\"address-space\">Address space<a title=\"#address-space\" href=\"#address-space\"></a></h3>\n<p>The memory that a process can access is called its address space.  It is defined by the process page table and set up by the kernel.</p>\n<img src=\"https://tva1.sinaimg.cn/large/0081Kckwly1gk19i68q35j30zu0akwi3.jpg\" alt=\"Screen Shot 2020-10-25 at 08.13.37\" style=\"zoom:45%;\">\n<p>Each process is given a flat(as opposed to segmented) 32/64-bits address space and a memory address is an index within the address space.</p>\n<img src=\"https://tva1.sinaimg.cn/large/0081Kckwly1gk19oatz2gj30ly07q40h.jpg\" alt=\"Screen Shot 2020-10-25 at 08.19.30\" style=\"zoom: 67%;\">\n<p>Interval of addresses that the process has the right to access: virtual memory areas (VMAs).</p>\n<p>VMAs can be dynamically added or removed to the process address space and have associated permissions: read, write, execute. When a process try to access an address outside of valid VMAs, or access a VMA with wrong permissions: segmentation fault.</p>\n<p>VMAs cancontain:<br>\nMapping of the executable file code (text section)<br>\nMapping of the executable file initialized variables (data section)<br>\nMapping of the zero page for uninitialized variables (bss section)<br>\nMapping of the zero page for the user-space stack<br>\nText, data, bss for each shared library used<br>\nMemory-mapped files, shared memory segment, anonymous mappings (used by malloc)</p>\n<img src=\"https://tva1.sinaimg.cn/large/0081Kckwgy1gk1ah62rodj310g0bygny.jpg\" alt=\"Screen Shot 2020-10-25 at 08.47.11\" style=\"zoom: 40%;\">\n<h3 id=\"memory-descriptor\">Memory descriptor<a title=\"#memory-descriptor\" href=\"#memory-descriptor\"></a></h3>\n<ol>\n<li>\n<p>The kernel represent a process address space through a struct <code>mm_struct</code> object, the memory descriptor which is defined in <code>include/linux/mm_types.h</code>.</p>\n<p>All <code>mm_struct</code> are linked together in a doubly linked list. Through the <code>mmlist </code> field if the <code>mm_struct</code>.</p>\n<p>See more from <a href=\"https://elixir.bootlin.com/linux/latest/ident/mm_struct\" target=\"_blank\">here</a>.</p>\n</li>\n<li>\n<p>Memory descriptor allocation</p>\n<p>A task memory descriptor is located in the <code>mm_field</code> of the corresponding <code>task_struct</code>. Current task memory descriptor: <code>current-&gt;m</code>. During <code>fork()</code>,<code>copy_mm()</code> is making a copy of the parent memory descriptor for the child. <code>copy_mm()</code>calls <code>dup_mm()</code> which calls <code>allocate_mm()</code> which allocates a <code>mm_struct</code> object from a slab cache.</p>\n<p>Two threads sharing the same address space have the <code>mm_field</code> of their <code>task_struct</code> pointing to the same <code>mm_struc</code> object. Threads are created using the <code>CLONE_VM</code> flag passed to <code>clone()</code> → <code>allocate_mm()</code> is not called.</p>\n</li>\n<li>\n<p>Memory descriptor destruction</p>\n<p>When a process exits, <code>do_exit()</code> is called. It calls <code>exit_mm()</code>. Performs some housekeeping/statistics updates.</p>\n<p>Call <code>mm_put()</code>. <code>mm_put()</code> decrements the <code>users</code> field and calls <code>_mmput()</code> if it reaches 0. <code>_mmput()</code> calls <code>mmdrop()</code>, that decrements the <code>count</code> field and calls <code>mm_drop()</code> if it reaches 0. <code>_mmdrop()</code> calls <code>free_mm()</code> which return the memory for the <code>mm_struct()</code> to the slab cache (i.e. free).</p>\n</li>\n<li>\n<p>Memory descriptor and kernel threads</p>\n<p>Kernel threads do not have a user-space address space. <code>mm</code> field of a kernel thread <code>task_struct</code> is <code>NULL</code>. When a kernel thread is scheduled, the kernel notice its <code>mm</code> is <code>NULL</code> so it keeps the previous address space loaded (page tables) and makes  the <code>active_mm</code> field of the kernel thread to point on the borrowed <code>mm_struct</code>.</p>\n</li>\n</ol>\n<h2 id=\"part.2-virtual-memory-area\">Part.2 Virtual Memory Area<a title=\"#part.2-virtual-memory-area\" href=\"#part.2-virtual-memory-area\"></a></h2>\n<h3 id=\"vm_area_struct\"><code>vm_area_struct</code><a title=\"#vm_area_struct\" href=\"#vm_area_struct\"></a></h3>\n<p>Each VMA is represented by an object of type <code>vm_area_struct</code> and defined in <code>include/linux/mm_types.h</code>. See more details from <a href=\"https://elixir.bootlin.com/linux/latest/C/ident/vm_area_struct\" target=\"_blank\">here</a>. Each VMA is unique to the associated <code>mm_struct</code>. Two processes mapping the same file will have two different <code>mm_struct</code> objects, and two different vm area struct objects. Two threads sharing a <code>mm_struct</code> object also share the <code>vm_area_struct</code> objects.</p>\n<h3 id=\"flags\">Flags<a title=\"#flags\" href=\"#flags\"></a></h3>\n<p>Flags specify properties and information for all the pages contained in the VMA.</p>\n<p><code>VM READ</code>: pages can be read from<br>\n<code>VM WRITE</code>: pages can be written to<br>\n<code>VM EXEC</code>: code inside pages can be executed<br>\n<code>VM SHARED</code>: pages are shared between multiple processes (if unset the mapping is private)</p>\n<p><code>VM MAYREAD</code>: the <code>VM READ</code> flag can be set<br>\n<code>VM MAYWRITE</code>: the <code>VM WRITE</code> flag can be set<br>\n<code>VM MAYEXEC</code>: the <code>VM EXEC</code> flag can be set<br>\n<code>VM MAYSHARE</code>: the <code>VM SHARED</code> flag can be set</p>\n<p><code>VM GROWSDOWN</code>: area can grow downwards<br>\n<code>VM GROWSUP</code>: area can grow upwards<br>\n<code>VM SHM</code>: area can be used for shared memory<br>\n<code>VM DENYWRITE</code>: area maps an unwritable file<br>\n<code>VM EXECUTABLE</code>: area maps an executable file<br>\n… …</p>\n<h3 id=\"vma-operations\">VMA operations<a title=\"#vma-operations\" href=\"#vma-operations\"></a></h3>\n<p><code>vm ops</code>  in <code>vm_area_struct</code> points to a <code>vm_operations_struct</code> object which contains function pointers to operate on a specific VMAs and is defined in include/linux/mm.h. See more details from <a href=\"https://elixir.bootlin.com/linux/latest/C/ident/vm_operations_struct\" target=\"_blank\">here</a>.</p>\n<p>Function pointers in vm operations struct:<br>\n<code>open()</code>: called when the area is added to an address space.<br>\n<code>close()</code>: called when the area is removed from an address space.<br>\n<code>fault()</code>: invoked by the page fault handler when a page that is not present in physical memory is accessed.<br>\n<code>page_mkwrite()</code>:invoked by the page fault handler when a previously read-only page is made writable.</p>\n<h3 id=\"vmas-in-real-life\">VMAs in real life<a title=\"#vmas-in-real-life\" href=\"#vmas-in-real-life\"></a></h3>\n<p>From userspace, one can observe the VMAs map for a given process: <code>cat /proc/&lt;pid&gt;/maps</code>.</p>\n<p>· <code>/proc/&lt;pid&gt;/maps</code>  columnsdescription:<br>\nAddress range Permissions<br>\nStart offset of file mapping<br>\nDevice containing the mapped file<br>\nMapped file inode number<br>\nMapped file pathname</p>\n<p>Can also use the command <code>pmap &lt;pid&gt;</code>.</p>\n<h2 id=\"part.3-vma-manipulation\">Part.3 VMA manipulation<a title=\"#part.3-vma-manipulation\" href=\"#part.3-vma-manipulation\"></a></h2>\n<h3 id=\"finding-a-vma\">Finding a VMA<a title=\"#finding-a-vma\" href=\"#finding-a-vma\"></a></h3>\n<p><code>find_vma()</code>: used to find a VMA in which a specific memory address resides, its prototype in include/linux/mm.h and  it is defined in mm/mmap.c. See more details from <a href=\"https://elixir.bootlin.com/linux/latest/C/ident/find_vma\" target=\"_blank\">here</a>.</p>\n<p><code>find_vma_prev()</code>: returns in addition the last VMA before a given address.</p>\n<p><code>find_vma_intersection()</code>: returns the first VMA overlapping a given address range.</p>\n<h3 id=\"creating-an-address-interval\">Creating an address interval<a title=\"#creating-an-address-interval\" href=\"#creating-an-address-interval\"></a></h3>\n<p><code>do_mmap()</code> is used to create a new linear address interval which can result in the creation of a new VMAs<br>\nor a merge of the create area with an adjacent one when they have the same permissions.</p>\n<p>On error <code>do_mmap()</code> returns a negative value.</p>\n<p>On success:<br>\nThe kernel tries to merge the new interval with an adjacent one having same permissions.<br>\nOtherwise, create a new VMA.<br>\nReturns a pointer to the start of the mapped memory area.</p>\n<p><code>do_mmap()</code> is exported to user-space through <code>mmap2()</code>.</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">externunsignedlong <span class=\"title\">do_mmap</span><span class=\"params\">(struct file *file, unsignedlong addr, unsignedlong len, unsignedlong prot, unsignedlong flags,<span class=\"keyword\">vm_flags_t</span> vm_flags, unsignedlong pgoff, unsignedlong *populate)</span></span>;</span><br></pre></td></tr></table></figure>\n<p>Caller must hold <code>mm-&gt;mmap_sem</code> (RW semaphore). Maps the file <code>file</code> in the address space at address <code>addr</code> for length <code>len</code>. Mapping starts at offset <code>pgoff</code> in the file. <code>prot</code> specifies access permissions for the memory pages: <code>PROT READ</code>, <code>PROT WRITE</code>, <code>PROT EXEC</code>, <code>PROT NONE</code>.</p>\n<p><code>flags</code> specifies the rest of the <code>VMAoptions</code>:<br>\n<code>MAP SHARED</code>: mapping can be shared<br>\n<code>MAP PRIVATE</code>: mapping cannot be shared<br>\n<code>MAP FIXED</code>: created interval must start at addr<br>\n<code>MAP ANONYMOUS</code>: mapping is not file-backed<br>\n<code>MAP GROWSDOWN</code>: corresponds to VM GROWSDOWN<br>\n… …</p>\n<h3 id=\"removing-an-address-interval\">Removing an address interval<a title=\"#removing-an-address-interval\" href=\"#removing-an-address-interval\"></a></h3>\n<p>Removing an address interval is done through <code>do_munmap()</code> and <code>0</code> returned on success.</p>\n<p>Exported to user-space through <code>munmap()</code>.</p>\n<h2 id=\"part.4-page-tables\">Part.4 Page Tables<a title=\"#part.4-page-tables\" href=\"#part.4-page-tables\"></a></h2>\n<p>All memory accesses made by the CPU are virtual and translated to physical addresses through the page tables. Linux kernel set the page tables and the translation is made automatically by the hardware (MMU) according to the page tables content. Page size is machine dependent. Typical values for x86 are <strong>4K</strong>, 2M, and 1G. Most of the pages are used for (1) kernel/userspace memory (<em>anonymous mapping</em>) or (2) file mapping.</p>\n<p>The address space is defined by VMAs and is sparsely populated(One address space per process → one page table per process). A hierarchical tree structure is used to define the page table.</p>\n<img src=\"/Users/Mori/Library/Application Support/typora-user-images/Screen Shot 2020-10-25 at 11.07.47.png\" alt=\"Screen Shot 2020-10-25 at 11.07.47\" style=\"zoom:50%;\">\n<img src=\"https://tva1.sinaimg.cn/large/0081Kckwgy1gk1el0seruj30ta0c6gmv.jpg\" alt=\"Screen Shot 2020-10-25 at 11.09.15\" style=\"zoom:50%;\">\n<p>Each <strong>physical page</strong> is represented by a struct page. Assuming 8GB of RAM and 4K-sized pages: 128MB reserved for struct page objects(<em>∼</em>1.5%).</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* The kernel uses struct page to keep track of the owner of the page */</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">page</span> &#123;</span></span><br><span class=\"line\">  <span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> flags;            <span class=\"comment\">/* page status (permission,etc.) */</span></span><br><span class=\"line\">  <span class=\"keyword\">unsigned</span> counters;              <span class=\"comment\">/* usage count */</span></span><br><span class=\"line\">  <span class=\"keyword\">atomic_t</span> _mapcount;</span><br><span class=\"line\">  <span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> <span class=\"keyword\">private</span>;          <span class=\"comment\">/* private mapping */</span></span><br><span class=\"line\">  <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">address_space</span> *<span class=\"title\">mapping</span>;</span>  <span class=\"comment\">/* file mapping */</span></span><br><span class=\"line\">  <span class=\"keyword\">pgoff_t</span> index;                  <span class=\"comment\">/* offset within mapping */</span></span><br><span class=\"line\">  <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">list_head</span> <span class=\"title\">lru</span>;</span></span><br><span class=\"line\">  <span class=\"keyword\">void</span> *<span class=\"keyword\">virtual</span>;                  <span class=\"comment\">/* virtualaddres */</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"zones\">Zones<a title=\"#zones\" href=\"#zones\"></a></h3>\n<p>Because of hardware limitations, only certain physical pages can be used in certain contexts. Physical memory is divided into <strong>zones</strong>. Zones layout is completely architecture dependent.</p>\n<img src=\"https://tva1.sinaimg.cn/large/0081Kckwgy1gk2g0o5aojj30u80ecwgj.jpg\" alt=\"Screen Shot 2020-10-26 at 08.44.18\" style=\"zoom:33%;\">\n<p><code>ZONE DMA</code>: pages with which DMA(Direct Memory Access) can be used.<br>\n<code>ZONE DMA32</code>: memory for other DMA limited devices.<br>\n<code>ZONE NORMAL</code>: page always mapped in the address space.<br>\n<code>ZONE HIGHMEM:</code> pages only mapped temporary.</p>\n<p>Each zone is represented by a struct zone object and is defined in <code>include/linux/mmzone.h</code>.</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">zone</span> &#123;</span></span><br><span class=\"line\">  <span class=\"comment\">/* minimum,lowandhighwatermarksusedforper-area memory allocation. */</span></span><br><span class=\"line\">  <span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span>      watermark[NR_WMARK];</span><br><span class=\"line\">  <span class=\"keyword\">const</span> <span class=\"keyword\">char</span>         *name;</span><br><span class=\"line\">  spinlook           lock;     <span class=\"comment\">/* protects against concurrent access */</span></span><br><span class=\"line\">  <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">free_area</span>   <span class=\"title\">free_area</span>[<span class=\"title\">MAX_ORDER</span>];</span></span><br><span class=\"line\">  <span class=\"comment\">/*...*/</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","next":{"title":"Process Management","link":"2020/20201024-Process-Management"},"plink":"https://oreodu.github.io/2020/20201025-Memory-Management/","toc":[{"id":"memory-management","title":"Memory Management","index":"1","children":[{"id":"part.1-address-space-and-memory-descripter","title":"Part.1 Address space and memory descripter","index":"1.1"},{"id":"part.2-virtual-memory-area","title":"Part.2 Virtual Memory Area","index":"1.2"},{"id":"part.3-vma-manipulation","title":"Part.3 VMA manipulation","index":"1.3"},{"id":"part.4-page-tables","title":"Part.4 Page Tables","index":"1.4"}]}],"reward":true,"copyright":{"author":"Oreo Du","link":"<a href=\"https://oreodu.github.io/2020/20201025-Memory-Management/\" title=\"Memory Management\">https://oreodu.github.io/2020/20201025-Memory-Management/</a>","license":"Attribution-NonCommercial-NoDerivatives 4.0 International (<a href=\"https://creativecommons.org/licenses/by-nc-sa/4.0/\" rel=\"external nofollow noopener\" target=\"_blank\">CC BY-NC-ND 4.0</a>)"}}