{"title":"Memory Management","date":"2020-10-25T00:07:00.000Z","date_formatted":{"ll":"Oct 25, 2020","L":"10/25/2020","MM-DD":"10-25"},"link":"2020/20201025-Memory-Management","comments":true,"tags":["Operating System"],"categories":["Linux","Operating System"],"updated":"2020-10-30T12:51:25.322Z","content":"<h1 id=\"memory-management\">Memory Management<a title=\"#memory-management\" href=\"#memory-management\"></a></h1>\n<h2 id=\"part.1-address-space-and-memory-descripter\">Part.1 Address space and memory descripter<a title=\"#part.1-address-space-and-memory-descripter\" href=\"#part.1-address-space-and-memory-descripter\"></a></h2>\n<h3 id=\"address-space\">Address space<a title=\"#address-space\" href=\"#address-space\"></a></h3>\n<p>The memory that a process can access is called its address space.  It is defined by the process page table and set up by the kernel.</p>\n<img src=\"https://tva1.sinaimg.cn/large/0081Kckwly1gk19i68q35j30zu0akwi3.jpg\" alt=\"Screen Shot 2020-10-25 at 08.13.37\" style=\"zoom:45%;\">\n<p>Each process is given a flat(as opposed to segmented) 32/64-bits address space and a memory address is an index within the address space.</p>\n<img src=\"https://tva1.sinaimg.cn/large/0081Kckwly1gk19oatz2gj30ly07q40h.jpg\" alt=\"Screen Shot 2020-10-25 at 08.19.30\" style=\"zoom: 67%;\">\n<p>Interval of addresses that the process has the right to access: virtual memory areas (VMAs).</p>\n<p>VMAs can be dynamically added or removed to the process address space and have associated permissions: read, write, execute. When a process try to access an address outside of valid VMAs, or access a VMA with wrong permissions: segmentation fault.</p>\n<p>VMAs cancontain:<br>\nMapping of the executable file code (text section)<br>\nMapping of the executable file initialized variables (data section)<br>\nMapping of the zero page for uninitialized variables (bss section)<br>\nMapping of the zero page for the user-space stack<br>\nText, data, bss for each shared library used<br>\nMemory-mapped files, shared memory segment, anonymous mappings (used by malloc)</p>\n<img src=\"https://tva1.sinaimg.cn/large/0081Kckwgy1gk1ah62rodj310g0bygny.jpg\" alt=\"Screen Shot 2020-10-25 at 08.47.11\" style=\"zoom: 40%;\">\n<h3 id=\"memory-descriptor\">Memory descriptor<a title=\"#memory-descriptor\" href=\"#memory-descriptor\"></a></h3>\n<ol>\n<li>\n<p>The kernel represent a process address space through a struct <code>mm_struct</code> object, the memory descriptor which is defined in <code>include/linux/mm_types.h</code>.</p>\n<p>All <code>mm_struct</code> are linked together in a doubly linked list. Through the <code>mmlist </code> field if the <code>mm_struct</code>.</p>\n<p>See more from <a href=\"https://elixir.bootlin.com/linux/latest/ident/mm_struct\" target=\"_blank\">here</a>.</p>\n</li>\n<li>\n<p>Memory descriptor allocation</p>\n<p>A task memory descriptor is located in the <code>mm_field</code> of the corresponding <code>task_struct</code>. Current task memory descriptor: <code>current-&gt;m</code>. During <code>fork()</code>,<code>copy_mm()</code> is making a copy of the parent memory descriptor for the child. <code>copy_mm()</code>calls <code>dup_mm()</code> which calls <code>allocate_mm()</code> which allocates a <code>mm_struct</code> object from a slab cache.</p>\n<p>Two threads sharing the same address space have the <code>mm_field</code> of their <code>task_struct</code> pointing to the same <code>mm_struc</code> object. Threads are created using the <code>CLONE_VM</code> flag passed to <code>clone()</code> → <code>allocate_mm()</code> is not called.</p>\n</li>\n<li>\n<p>Memory descriptor destruction</p>\n<p>When a process exits, <code>do_exit()</code> is called. It calls <code>exit_mm()</code>. Performs some housekeeping/statistics updates.</p>\n<p>Call <code>mm_put()</code>. <code>mm_put()</code> decrements the <code>users</code> field and calls <code>_mmput()</code> if it reaches 0. <code>_mmput()</code> calls <code>mmdrop()</code>, that decrements the <code>count</code> field and calls <code>mm_drop()</code> if it reaches 0. <code>_mmdrop()</code> calls <code>free_mm()</code> which return the memory for the <code>mm_struct()</code> to the slab cache (i.e. free).</p>\n</li>\n<li>\n<p>Memory descriptor and kernel threads</p>\n<p>Kernel threads do not have a user-space address space. <code>mm</code> field of a kernel thread <code>task_struct</code> is <code>NULL</code>. When a kernel thread is scheduled, the kernel notice its <code>mm</code> is <code>NULL</code> so it keeps the previous address space loaded (page tables) and makes  the <code>active_mm</code> field of the kernel thread to point on the borrowed <code>mm_struct</code>.</p>\n</li>\n</ol>\n<h2 id=\"part.2-virtual-memory-area\">Part.2 Virtual Memory Area<a title=\"#part.2-virtual-memory-area\" href=\"#part.2-virtual-memory-area\"></a></h2>\n<h3 id=\"vm_area_struct\"><code>vm_area_struct</code><a title=\"#vm_area_struct\" href=\"#vm_area_struct\"></a></h3>\n<p>Each VMA is represented by an object of type <code>vm_area_struct</code> and defined in <code>include/linux/mm_types.h</code>. See more details from <a href=\"https://elixir.bootlin.com/linux/latest/C/ident/vm_area_struct\" target=\"_blank\">here</a>. Each VMA is unique to the associated <code>mm_struct</code>. Two processes mapping the same file will have two different <code>mm_struct</code> objects, and two different vm area struct objects. Two threads sharing a <code>mm_struct</code> object also share the <code>vm_area_struct</code> objects.</p>\n<h3 id=\"flags\">Flags<a title=\"#flags\" href=\"#flags\"></a></h3>\n<p>Flags specify properties and information for all the pages contained in the VMA.</p>\n<p><code>VM READ</code>: pages can be read from<br>\n<code>VM WRITE</code>: pages can be written to<br>\n<code>VM EXEC</code>: code inside pages can be executed<br>\n<code>VM SHARED</code>: pages are shared between multiple processes (if unset the mapping is private)</p>\n<p><code>VM MAYREAD</code>: the <code>VM READ</code> flag can be set<br>\n<code>VM MAYWRITE</code>: the <code>VM WRITE</code> flag can be set<br>\n<code>VM MAYEXEC</code>: the <code>VM EXEC</code> flag can be set<br>\n<code>VM MAYSHARE</code>: the <code>VM SHARED</code> flag can be set</p>\n<p><code>VM GROWSDOWN</code>: area can grow downwards<br>\n<code>VM GROWSUP</code>: area can grow upwards<br>\n<code>VM SHM</code>: area can be used for shared memory<br>\n<code>VM DENYWRITE</code>: area maps an unwritable file<br>\n<code>VM EXECUTABLE</code>: area maps an executable file<br>\n… …</p>\n<h3 id=\"vma-operations\">VMA operations<a title=\"#vma-operations\" href=\"#vma-operations\"></a></h3>\n<p><code>vm ops</code>  in <code>vm_area_struct</code> points to a <code>vm_operations_struct</code> object which contains function pointers to operate on a specific VMAs and is defined in include/linux/mm.h. See more details from <a href=\"https://elixir.bootlin.com/linux/latest/C/ident/vm_operations_struct\" target=\"_blank\">here</a>.</p>\n<p>Function pointers in vm operations struct:<br>\n<code>open()</code>: called when the area is added to an address space.<br>\n<code>close()</code>: called when the area is removed from an address space.<br>\n<code>fault()</code>: invoked by the page fault handler when a page that is not present in physical memory is accessed.<br>\n<code>page_mkwrite()</code>:invoked by the page fault handler when a previously read-only page is made writable.</p>\n<h3 id=\"vmas-in-real-life\">VMAs in real life<a title=\"#vmas-in-real-life\" href=\"#vmas-in-real-life\"></a></h3>\n<p>From userspace, one can observe the VMAs map for a given process: <code>cat /proc/&lt;pid&gt;/maps</code>.</p>\n<p>· <code>/proc/&lt;pid&gt;/maps</code>  columnsdescription:<br>\nAddress range Permissions<br>\nStart offset of file mapping<br>\nDevice containing the mapped file<br>\nMapped file inode number<br>\nMapped file pathname</p>\n<p>Can also use the command <code>pmap &lt;pid&gt;</code>.</p>\n<h2 id=\"part.3-vma-manipulation\">Part.3 VMA manipulation<a title=\"#part.3-vma-manipulation\" href=\"#part.3-vma-manipulation\"></a></h2>\n<h3 id=\"finding-a-vma\">Finding a VMA<a title=\"#finding-a-vma\" href=\"#finding-a-vma\"></a></h3>\n<p><code>find_vma()</code>: used to find a VMA in which a specific memory address resides, its prototype in include/linux/mm.h and  it is defined in mm/mmap.c. See more details from <a href=\"https://elixir.bootlin.com/linux/latest/C/ident/find_vma\" target=\"_blank\">here</a>.</p>\n<p><code>find_vma_prev()</code>: returns in addition the last VMA before a given address.</p>\n<p><code>find_vma_intersection()</code>: returns the first VMA overlapping a given address range.</p>\n<h3 id=\"creating-an-address-interval\">Creating an address interval<a title=\"#creating-an-address-interval\" href=\"#creating-an-address-interval\"></a></h3>\n<p><code>do_mmap()</code> is used to create a new linear address interval which can result in the creation of a new VMAs<br>\nor a merge of the create area with an adjacent one when they have the same permissions.</p>\n<p>On error <code>do_mmap()</code> returns a negative value.</p>\n<p>On success:<br>\nThe kernel tries to merge the new interval with an adjacent one having same permissions.<br>\nOtherwise, create a new VMA.<br>\nReturns a pointer to the start of the mapped memory area.</p>\n<p><code>do_mmap()</code> is exported to user-space through <code>mmap2()</code>.</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">externunsignedlong <span class=\"title\">do_mmap</span><span class=\"params\">(struct file *file, unsignedlong addr, unsignedlong len, unsignedlong prot, unsignedlong flags,<span class=\"keyword\">vm_flags_t</span> vm_flags, unsignedlong pgoff, unsignedlong *populate)</span></span>;</span><br></pre></td></tr></table></figure>\n<p>Caller must hold <code>mm-&gt;mmap_sem</code> (RW semaphore). Maps the file <code>file</code> in the address space at address <code>addr</code> for length <code>len</code>. Mapping starts at offset <code>pgoff</code> in the file. <code>prot</code> specifies access permissions for the memory pages: <code>PROT READ</code>, <code>PROT WRITE</code>, <code>PROT EXEC</code>, <code>PROT NONE</code>.</p>\n<p><code>flags</code> specifies the rest of the <code>VMAoptions</code>:<br>\n<code>MAP SHARED</code>: mapping can be shared<br>\n<code>MAP PRIVATE</code>: mapping cannot be shared<br>\n<code>MAP FIXED</code>: created interval must start at addr<br>\n<code>MAP ANONYMOUS</code>: mapping is not file-backed<br>\n<code>MAP GROWSDOWN</code>: corresponds to VM GROWSDOWN<br>\n… …</p>\n<h3 id=\"removing-an-address-interval\">Removing an address interval<a title=\"#removing-an-address-interval\" href=\"#removing-an-address-interval\"></a></h3>\n<p>Removing an address interval is done through <code>do_munmap()</code> and <code>0</code> returned on success.</p>\n<p>Exported to user-space through <code>munmap()</code>.</p>\n<h2 id=\"part.4-page-tables\">Part.4 Page Tables<a title=\"#part.4-page-tables\" href=\"#part.4-page-tables\"></a></h2>\n<p>All memory accesses made by the CPU are virtual and translated to physical addresses through the page tables. Linux kernel set the page tables and the translation is made automatically by the hardware (MMU) according to the page tables content. Page size is machine dependent. Typical values for x86 are <strong>4K</strong>, 2M, and 1G. Most of the pages are used for (1) kernel/userspace memory (<em>anonymous mapping</em>) or (2) file mapping.</p>\n<p>The address space is defined by VMAs and is sparsely populated(One address space per process → one page table per process). A hierarchical tree structure is used to define the page table.</p>\n<img src=\"/Users/Mori/Library/Application Support/typora-user-images/Screen Shot 2020-10-25 at 11.07.47.png\" alt=\"Screen Shot 2020-10-25 at 11.07.47\" style=\"zoom:50%;\">\n<img src=\"https://tva1.sinaimg.cn/large/0081Kckwgy1gk1el0seruj30ta0c6gmv.jpg\" alt=\"Screen Shot 2020-10-25 at 11.09.15\" style=\"zoom:50%;\">\n<p>Each <strong>physical page</strong> is represented by a struct page. Assuming 8GB of RAM and 4K-sized pages: 128MB reserved for struct page objects(<em>∼</em>1.5%).</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* The kernel uses struct page to keep track of the owner of the page */</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">page</span> &#123;</span></span><br><span class=\"line\">  <span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> flags;            <span class=\"comment\">/* page status (permission,etc.) */</span></span><br><span class=\"line\">  <span class=\"keyword\">unsigned</span> counters;              <span class=\"comment\">/* usage count */</span></span><br><span class=\"line\">  <span class=\"keyword\">atomic_t</span> _mapcount;</span><br><span class=\"line\">  <span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> <span class=\"keyword\">private</span>;          <span class=\"comment\">/* private mapping */</span></span><br><span class=\"line\">  <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">address_space</span> *<span class=\"title\">mapping</span>;</span>  <span class=\"comment\">/* file mapping */</span></span><br><span class=\"line\">  <span class=\"keyword\">pgoff_t</span> index;                  <span class=\"comment\">/* offset within mapping */</span></span><br><span class=\"line\">  <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">list_head</span> <span class=\"title\">lru</span>;</span></span><br><span class=\"line\">  <span class=\"keyword\">void</span> *<span class=\"keyword\">virtual</span>;                  <span class=\"comment\">/* virtualaddres */</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"zones\">Zones<a title=\"#zones\" href=\"#zones\"></a></h3>\n<p>Because of hardware limitations, only certain physical pages can be used in certain contexts. Physical memory is divided into <strong>zones</strong>. Zones layout is completely architecture dependent.</p>\n<img src=\"https://tva1.sinaimg.cn/large/0081Kckwgy1gk2g0o5aojj30u80ecwgj.jpg\" alt=\"Screen Shot 2020-10-26 at 08.44.18\" style=\"zoom:33%;\">\n<p><code>ZONE DMA</code>: pages with which DMA(Direct Memory Access) can be used.<br>\n<code>ZONE DMA32</code>: memory for other DMA limited devices.<br>\n<code>ZONE NORMAL</code>: page always mapped in the address space.<br>\n<code>ZONE HIGHMEM:</code> pages only mapped temporary.</p>\n<p>Each zone is represented by a struct zone object and is defined in <code>include/linux/mmzone.h</code>.</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">zone</span> &#123;</span></span><br><span class=\"line\">  <span class=\"comment\">/* minimum,lowandhighwatermarksusedforper-area memory allocation. */</span></span><br><span class=\"line\">  <span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span>      watermark[NR_WMARK];</span><br><span class=\"line\">  <span class=\"keyword\">const</span> <span class=\"keyword\">char</span>         *name;</span><br><span class=\"line\">  spinlook           lock;     <span class=\"comment\">/* protects against concurrent access */</span></span><br><span class=\"line\">  <span class=\"comment\">/* list of free pages to serve memory allocation requests */</span></span><br><span class=\"line\">  <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">free_area</span>   <span class=\"title\">free_area</span>[<span class=\"title\">MAX_ORDER</span>];</span></span><br><span class=\"line\">  <span class=\"comment\">/*...*/</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"part.5-low-level-memory-allocator\">Part.5 Low-level memory allocator<a title=\"#part.5-low-level-memory-allocator\" href=\"#part.5-low-level-memory-allocator\"></a></h2>\n<p>Low-level mechanisms allocating memory with page-sized granularity. Interface is in <code>include/linux/gfp.h</code>. For more details from <a href=\"https://elixir.bootlin.com/linux/latest/source/include/linux/gfp.h\" target=\"_blank\">here</a>.</p>\n<img src=\"https://tva1.sinaimg.cn/large/0081Kckwgy1gk2g8sh7hej30oa0iy77k.jpg\" alt=\"Screen Shot 2020-10-26 at 08.52.18\" style=\"zoom:50%;\">\n<p>· Allocates 2^<em>order</em> contiguous pages (1 <em>&lt; &lt; order</em> )<br>\n· Returns the address of the first allocated struct page.</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">struct page * <span class=\"title\">alloc_pages</span><span class=\"params\">(<span class=\"keyword\">gfp_t</span> gfp_mask, <span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> order)</span></span>;</span><br></pre></td></tr></table></figure>\n<p>To actually use the allocated memory, need to convert to virtual address.</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> * <span class=\"title\">page_address</span><span class=\"params\">(struct page *page)</span></span>;</span><br></pre></td></tr></table></figure>\n<p>Or we can allocate and get the virtual address directly.</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> <span class=\"title\">get_free_pages</span><span class=\"params\">(<span class=\"keyword\">gfp_t</span> gfp_mask, <span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> order)</span></span>;</span><br></pre></td></tr></table></figure>\n<p>To get a page filled with zeros.</p>\n<p>A page containing user space data (process A) that is freed can be later given to another process (process B) and we don’t want process B to read information from process A.</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> <span class=\"title\">get_zeroed_page</span><span class=\"params\">(<span class=\"keyword\">gfp_t</span> gfp_mask)</span></span>;</span><br></pre></td></tr></table></figure>\n<p>Free pages, only free the pages you allocate!</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">free_pages</span><span class=\"params\">(struct page *page, <span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> order)</span></span>; </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">free_pages</span><span class=\"params\">(<span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> addr, <span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> order)</span></span>; </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">free_page</span><span class=\"params\">(struct page *page)</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">free_page</span><span class=\"params\">(<span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> addr)</span></span>;</span><br></pre></td></tr></table></figure>\n<p>Buddy system :</p>\n<img src=\"https://tva1.sinaimg.cn/large/0081Kckwly1gk2zog05xij30ta0jatco.jpg\" alt=\"Screen Shot 2020-10-26 at 20.04.44\" style=\"zoom:50%;\">\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* Low-level memory allocator, Usage example */</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;linux/module.h&gt; </span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;linux/kernel.h&gt; </span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;linux/init.h&gt; </span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;linux/gfp.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> PRINT_PREE <span class=\"meta-string\">&quot;[LOWLEVEL]:&quot;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> PAEG_ORDER_REQUESTED 3</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> INTS_IN_PAGE (PAGE_SIZE/sizeof(int))</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> virt_addr;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">struct <span class=\"keyword\">int</span> _int <span class=\"title\">my_mod_init</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">int</span> *int_array;</span><br><span class=\"line\">  <span class=\"keyword\">int</span> i;</span><br><span class=\"line\">  printk(PRINT_PREE <span class=\"string\">&quot;Entering module.¥n&quot;</span>);</span><br><span class=\"line\">  </span><br><span class=\"line\">  virt_addr =get_free_pages(GFP_KERNEL,</span><br><span class=\"line\">                            PAGES_ORDER_REQUESTED); </span><br><span class=\"line\">  <span class=\"keyword\">if</span>(!virt_addr) &#123;</span><br><span class=\"line\">    printk(PRINT_PREF <span class=\"string\">&quot;Error in allocation¥n &quot;</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  int_array = (<span class=\"keyword\">int</span> *)virt_addr;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(i=<span class=\"number\">0</span>; i&lt;INTS_IN_PAGE; i++) int_array[i] = i;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(i=<span class=\"number\">0</span>; i&lt;INTS_IN_PAGE; i++) printk(PRINT_PREF <span class=\"string\">&quot;array[%d] = %d¥n&quot;</span>, </span><br><span class=\"line\">                                       i, int_array[i]);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> _exit <span class=\"title\">my_mod_exit</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span> </span>&#123;</span><br><span class=\"line\">  free_pages(virt_addr,</span><br><span class=\"line\">            PAGES_ORDER_REQUESTED);</span><br><span class=\"line\">  printk(PRINT_PREE <span class=\"string\">&quot;Exiting module ¥n&quot;</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">module_init(my_mod_init);</span><br><span class=\"line\">module_exit(my_mod_exit);</span><br></pre></td></tr></table></figure>\n<h2 id=\"part.6-kmalloc()-and-vmalloc()\">Part.6 <code>kmalloc()</code> and <code>vmalloc()</code><a title=\"#part.6-kmalloc()-and-vmalloc()\" href=\"#part.6-kmalloc()-and-vmalloc()\"></a></h2>\n<p><code>kmalloc()</code> (declared in <code>includes/linux/slab.h</code>)  allocates byte-sized chunks of memory which is physically contiguous and return a pointer to the first allocated byte on success.</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> * <span class=\"title\">kmalloc</span><span class=\"params\">(<span class=\"keyword\">size_t</span> size, <span class=\"keyword\">gfp_t</span> flags)</span></span>;</span><br></pre></td></tr></table></figure>\n<h3 id=\"kmalloc-flags\"><code>kmalloc</code> flags<a title=\"#kmalloc-flags\" href=\"#kmalloc-flags\"></a></h3>\n<p><code>gfp_t</code> is an unsigned int defined in <code>include/linux/types.h</code> and other types and modifier are declared and documented in <code>include/linux/gfp.h</code>.</p>\n<p>Specify options for the allocated memory:<br>\n·  Action modifiers ( How should the memory be allocated? )</p>\n<img src=\"/Users/Mori/Library/Application Support/typora-user-images/Screen Shot 2020-10-26 at 20.58.40.png\" alt=\"Screen Shot 2020-10-26 at 20.58.40\" style=\"zoom: 33%;\">\n<p>· Zone modifiers ( From which zone should the allocated memory come )</p>\n<img src=\"https://tva1.sinaimg.cn/large/0081Kckwly1gk31gtxbzzj30tg058aay.jpg\" alt=\"Screen Shot 2020-10-26 at 21.01.52\" style=\"zoom:40%;\">\n<p>Kernel allocates from <code>ZONE_NORMAL</code> or <code>ZONE_DMA</code> with a strong preference for <code>ZONE NORMAL</code> when there is no flag specified.</p>\n<p>· Type flags ( Combination of action and zone modifiers )</p>\n<p><code>GFP_ATOMIC</code>, <code>GEP_NOWAIT</code>, <code>GFP_NOIO</code>, <code>GFP_NOFS</code>, <code>GFP_KERNEL</code>, <code>GFP_USER</code>, <code>GFP_DMA</code>, <code>GFP_HIGHUSER</code></p>\n<p>Which flag to use.</p>\n<img src=\"https://tva1.sinaimg.cn/large/0081Kckwly1gk31vx5ps8j30vk0g2go6.jpg\" alt=\"Screen Shot 2020-10-26 at 21.21.10\" style=\"zoom:40%;\">\n<h3 id=\"kfree\"><code>kfree</code><a title=\"#kfree\" href=\"#kfree\"></a></h3>\n<p>Memory allocated with <code>kmalloc()</code> needs to be freed with <code>kfree()</code>(declared in <code>include/linux/slab.h</code>).</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">my_struct</span> *<span class=\"title\">ptr</span>;</span></span><br><span class=\"line\">ptr = kmalloc(<span class=\"keyword\">sizeof</span>(struct my_struct), GEP_KERNEL);</span><br><span class=\"line\"><span class=\"keyword\">if</span>(!ptr)&#123;</span><br><span class=\"line\">  <span class=\"comment\">/* handle error. */</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* work with ptr. */</span></span><br><span class=\"line\">kfree(ptr);</span><br></pre></td></tr></table></figure>\n<h3 id=\"vmalloc()\"><code>vmalloc()</code><a title=\"#vmalloc()\" href=\"#vmalloc()\"></a></h3>\n<p><code>vmalloc()</code>  allocates virtually contiguous pages that are not guarantee to map to physically contiguous ones.</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> *<span class=\"title\">vmalloc</span><span class=\"params\">(<span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> s i z e )</span> </span>; <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">vfree</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">void</span> *addr)</span></span>;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">my_struct</span> *<span class=\"title\">ptr</span>;</span></span><br><span class=\"line\"></span><br><span class=\"line\">ptr = vmalloc(<span class=\"keyword\">sizeof</span>(struct my_struct));</span><br><span class=\"line\"><span class=\"keyword\">if</span>(!ptr) &#123;</span><br><span class=\"line\">  <span class=\"comment\">/* handler error. */</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">/* work with ptr. */</span></span><br><span class=\"line\"></span><br><span class=\"line\">vfree(ptr);</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* kmalloc() allocatedsizelimitation */</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;linux/module.h&gt; </span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;linux/kernel.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;linux/init.h&gt; </span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;linux/slab.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> PRINT_PREF <span class=\"meta-string\">&quot;[KMALLOC_TEST]: &quot;</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">int</span> _init <span class=\"title\">my_mod_init</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> i ; <span class=\"keyword\">void</span> *ptr;</span><br><span class=\"line\">\tprintk(PRINT_PREF <span class=\"string\">&quot;Entering module.¥n&quot;</span>);</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(i=<span class=\"number\">1</span>;;i*=<span class=\"number\">2</span>) &#123;</span><br><span class=\"line\">\t\tptr = kmalloc(i, GFP_KERNEL); </span><br><span class=\"line\">    <span class=\"keyword\">if</span>(!ptr) &#123;</span><br><span class=\"line\">\t\t\tprintk(PRINT_PREF <span class=\"string\">&quot;could not allocate %lu bytes¥n&quot;</span>, i);</span><br><span class=\"line\">      <span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tkfree(ptr);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> _exit <span class=\"title\">my_mod_exit</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span> </span>&#123;</span><br><span class=\"line\">  printk(KERN_INFO <span class=\"string\">&quot;Exiting module.¥n&quot;</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">module_init(my_mod_init);</span><br><span class=\"line\">module_exit(my_mod_exit); </span><br><span class=\"line\">MODULE_LICENSE(<span class=\"string\">&quot;GPL&quot;</span>);</span><br></pre></td></tr></table></figure>\n<h2 id=\"part.7-slab-layer\">Part.7 Slab layer<a title=\"#part.7-slab-layer\" href=\"#part.7-slab-layer\"></a></h2>\n<p>Allocating/freeing data structures is done very often in the kernel and the data should be cached. An allocator aware of data structure size, page size, and total cache size is more efficient and should be <a href=\"https://en.wikipedia.org/wiki/Non-uniform_memory_access\" target=\"_blank\">NUMA-aware</a> and implement <a href=\"https://en.wikipedia.org/wiki/Cache_coloring\" target=\"_blank\">cache-coloring</a>.</p>\n<p>Slab layer/slab allocator: Linux’s generic allocation caching interface. Each cache contains one or several slabs( physically contiguous pages). Slabs contain objects(actual data structure slots). In order to reduce the fragmentation, allocation requests are served from partial slabs if present and a new empty slab is actually allocated in case the cache is full.</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* a new cache is crested using: */</span></span><br><span class=\"line\"><span class=\"function\">struct kmem_cache *<span class=\"title\">kmem_cache_create</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *name, </span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                                     <span class=\"keyword\">size_t</span> size,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                                     <span class=\"keyword\">size_t</span> align, </span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                                     <span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> flags,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                                     <span class=\"keyword\">void</span> (*ctor)(<span class=\"keyword\">void</span> *))</span></span>;</span><br></pre></td></tr></table></figure>\n<ol>\n<li>Flags</li>\n</ol>\n<p><code>SLAB_HW_CACHEALIGN</code>: Each object in a slab is aligned to a cache line.</p>\n<p><code>SLAB_POISON</code> : Fill the slab with know values (a5a5a5a5) to detect accesses to uninitialized memory.</p>\n<p><code>SLAB_PANIC</code>: Slab layer panics if the allocation fails.</p>\n<p><code>SLAB_CACHE_DMA</code>: Allocation made from DMA-enabled memory.</p>\n<p><code>SLAB_RED_ZONE</code> : Extra padding around objects to detect buffer overflows.</p>\n<img src=\"https://tva1.sinaimg.cn/large/0081Kckwgy1gk3lnszab3j30pe0c4tag.jpg\" alt=\"Screen Shot 2020-10-27 at 08.45.15\" style=\"zoom:33%;\">\n<img src=\"https://tva1.sinaimg.cn/large/0081Kckwgy1gk3ln8s2vyj30py0c075q.jpg\" alt=\"Screen Shot 2020-10-27 at 08.44.45\" style=\"zoom:33%;\">\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* Slab layer usage example */</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;linux/module.h&gt; </span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;linux/kernel.h&gt; </span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;linux/init.h&gt; </span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;linux/slab.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> PRINT_PREF <span class=\"meta-string\">&quot;[SLAB_TEST] &quot;</span></span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">my_struct</span> &#123;</span> </span><br><span class=\"line\">  <span class=\"keyword\">int</span> int_param;</span><br><span class=\"line\">  <span class=\"keyword\">long</span> long_param; &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">int</span> _init <span class=\"title\">my_mod_init</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">int</span> ret=<span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">my_struct</span> *<span class=\"title\">ptr1</span>, *<span class=\"title\">ptr2</span>;</span> </span><br><span class=\"line\">  <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">kmem_cache</span> *<span class=\"title\">my_cache</span>;</span></span><br><span class=\"line\">\tprintk(PRINT_PREF <span class=\"string\">&quot;Entering module.¥n&quot;</span>);</span><br><span class=\"line\">\tmy_cache = kmem_cache_create(<span class=\"string\">&quot;pierre-cache&quot;</span>, </span><br><span class=\"line\">                               <span class=\"keyword\">sizeof</span>(struct my_struct), <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"literal\">NULL</span>);</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(!my_cache) <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">  ptr1 = kmem_cache_alloc(my_cache, GFP_KERNEL);</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(!ptr1)&#123;</span><br><span class=\"line\">    ret = -ENOMEM;</span><br><span class=\"line\">\t\t<span class=\"keyword\">goto</span> destroy_cache;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">\tptr2 = kmem_cache_alloc(my_cache, GFP_KERNEL);</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(!ptr2)&#123;</span><br><span class=\"line\">    ret = -ENOMEM; </span><br><span class=\"line\">    <span class=\"keyword\">goto</span> freeptr1;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tptr1-&gt;int_param =<span class=\"number\">42</span>; </span><br><span class=\"line\">  ptr1-&gt;long_param = <span class=\"number\">42</span>; </span><br><span class=\"line\">  ptr2-&gt;int_param =<span class=\"number\">43</span>;</span><br><span class=\"line\">  ptr2-&gt;long_param = <span class=\"number\">43</span>;</span><br><span class=\"line\">  </span><br><span class=\"line\">  printk(PRINT_PREF <span class=\"string\">&quot;ptr1 = &#123;%d, %ld&#125; ; ptr2 = &#123;%d, %ld&#125;¥n&quot;</span>, </span><br><span class=\"line\">         ptr1-&gt;int_param, ptr1-&gt;long_param, ptr2-&gt;int_param, </span><br><span class=\"line\">         ptr2-&gt;long_param);</span><br><span class=\"line\">  </span><br><span class=\"line\">  kmem_cache_free(my_cache, ptr2);</span><br><span class=\"line\">  freeptr1:</span><br><span class=\"line\">  \t\tkmem_cache_free(my_cache, ptr1);</span><br><span class=\"line\">  destroy_cache: </span><br><span class=\"line\">  \t\tkmem_cache_destroy(my_cache);</span><br><span class=\"line\">      <span class=\"keyword\">return</span> ret;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> _exit <span class=\"title\">my_mod_exit</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span> </span>&#123;</span><br><span class=\"line\">  printk(KERN_INFO <span class=\"string\">&quot;Exiting module.¥n&quot;</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">module_init(my_mod_init); </span><br><span class=\"line\">module_exit(my_mod_exit);</span><br><span class=\"line\">MODULE_LICENSE(<span class=\"string\">&quot;GPL&quot;</span>);</span><br></pre></td></tr></table></figure>\n<h2 id=\"part.8-stack,-high-memory-and-per-cpu-allocation\">Part.8 Stack, high memory and per-cpu allocation<a title=\"#part.8-stack,-high-memory-and-per-cpu-allocation\" href=\"#part.8-stack,-high-memory-and-per-cpu-allocation\"></a></h2>\n<h3 id=\"stack\">Stack<a title=\"#stack\" href=\"#stack\"></a></h3>\n<p>A user-space stack for execution in user space and it is is large and grows dynamically.</p>\n<p>A kernel stack for execution in the kernel and it is small and has a fixed-size (Generally 8KB on 32-bit architectures and 16KB on 64-bit).</p>\n<p>Use a per-cpu stack (1 single page) dedicated to interrupt handlers.</p>\n<h3 id=\"high-memory-allocation\">High memory allocation<a title=\"#high-memory-allocation\" href=\"#high-memory-allocation\"></a></h3>\n<p>On x86_32, physical memory above 896MB is not permanently mapped within the kernel address space. Because of the limited size of the address space and the 1G/3G kernel/user-space physical memory split. Before usage, pages from highmem must be mapped after allocation.</p>\n<p>Permanent mapping (<code>include/linux/highmem.h</code>):</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> *<span class=\"title\">kmap</span><span class=\"params\">(struct page *page)</span></span>;</span><br></pre></td></tr></table></figure>\n<p>· Works on low and high memory.<br>\n· Maps (update the page table) and return the given<br>\n· May sleep, use only in process context<br>\n· Number of permanent mappings is limited, unmap when done:</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">kunmap</span><span class=\"params\">(struct page *page)</span></span>;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;linux/module.h&gt; </span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;linux/kernel.h&gt; </span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;linux/init.h&gt; </span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;linux/gfp.h&gt; </span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;linux/highmem.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> PRINT_PREF <span class=\"meta-string\">&quot;[HIGHMEM]: &quot;</span> </span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> INTS_IN_PAGE (PAGE_SIZE/sizeof(int))</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">int</span> _init <span class=\"title\">my_mod_init</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">page</span> *<span class=\"title\">my_page</span>;</span> </span><br><span class=\"line\">  <span class=\"keyword\">void</span> *my_ptr;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> i, *int_array;</span><br><span class=\"line\">\tprintk(PRINT_PREF <span class=\"string\">&quot;Entering module.¥n&quot;</span>); </span><br><span class=\"line\">  </span><br><span class=\"line\">  my_page = alloc_page(GFP_HIGHUSER);</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(!my_page) <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">  </span><br><span class=\"line\">\tmy_ptr = kmap(my_page); </span><br><span class=\"line\">  int_array = (<span class=\"keyword\">int</span> *)my_ptr;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"keyword\">for</span>(i=<span class=\"number\">0</span>; i&lt;INTS_IN_PAGE; i++) &#123; </span><br><span class=\"line\">    int_array[i] = i;</span><br><span class=\"line\">    printk(PRINT_PREF <span class=\"string\">&quot;array[%d] = %d¥n&quot;</span>, i, int_array[i]);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  kunmap(my_page); </span><br><span class=\"line\">  free_pages(my_page, <span class=\"number\">0</span>);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> _exit <span class=\"title\">my_mod_exit</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span> </span>&#123;</span><br><span class=\"line\">  printk(PRINT_PREF <span class=\"string\">&quot;Exiting module.¥n&quot;</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">module_init(my_mod_init); </span><br><span class=\"line\">module_exit(my_mod_exit);</span><br></pre></td></tr></table></figure>\n<p>Temporary mappings: Also called atomic mappings as they can be used from interrupt context and uses a per-cpu pre-reserved slot. Do not sleep while holding a temporary mapping.</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> *<span class=\"title\">kmap_atomic</span><span class=\"params\">(struct page *page)</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">kunmap_atomic</span><span class=\"params\">(<span class=\"keyword\">void</span> *addr)</span></span>;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;linux/module.h&gt; </span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;linux/kernel.h&gt; </span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;linux/init.h&gt; </span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;linux/gfp.h&gt; </span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;linux/highmem.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> PRINT_PREF <span class=\"meta-string\">&quot;[HIGHMEM_ATOMIC]: &quot;</span> </span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> INTS_IN_PAGE (PAGE_SIZE/sizeof(int))</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">int</span> _init <span class=\"title\">my_mod_init</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">page</span> *<span class=\"title\">my_page</span>;</span> </span><br><span class=\"line\">  <span class=\"keyword\">void</span> *my_ptr;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> i, *int_array;</span><br><span class=\"line\">\tprintk(PRINT_PREF <span class=\"string\">&quot;Entering module.¥n&quot;</span>);</span><br><span class=\"line\">  </span><br><span class=\"line\">  my_page = alloc_page(GFP_HIGHUSER);</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(!my_page) <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">  my_ptr = kmap_atomic(my_page); </span><br><span class=\"line\">  int_array = (<span class=\"keyword\">int</span> *)my_ptr;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"keyword\">for</span>(i=<span class=\"number\">0</span>; i&lt;INTS_IN_PAGE; i++) &#123;</span><br><span class=\"line\">    int_array[i] = i;</span><br><span class=\"line\">\t\tprintk(PRINT_PREF <span class=\"string\">&quot;array[%d] = %d¥n&quot;</span>, i , int_array[i]);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">\tkunmap_atomic(my_ptr); </span><br><span class=\"line\">  __free_pages(my_page, <span class=\"number\">0</span>);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> _exit <span class=\"title\">my_mod_exit</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span> </span>&#123;</span><br><span class=\"line\">  printk(PRINT_PREF <span class=\"string\">&quot;Exiting module.¥n&quot;</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">module_init(my_mod_init); </span><br><span class=\"line\">module_exit(my_mod_exit);</span><br></pre></td></tr></table></figure>\n<h3 id=\"per-cpu\">Per-cpu<a title=\"#per-cpu\" href=\"#per-cpu\"></a></h3>\n<p>Per-cpu data: data that is unique to each CPU (i.e. each core)  and is implemented through arrays in which each index corresponds to a CPU.</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> my_percpu[NR_CPUS]; <span class=\"comment\">/* NR_CPUS contains the number of cores */</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> cpu;</span><br><span class=\"line\"></span><br><span class=\"line\">cpu = get_cpu(); <span class=\"comment\">/* get current CPU, disable kernel preemption */</span></span><br><span class=\"line\">my_percpu[cpu]++; <span class=\"comment\">/* access the data */</span></span><br><span class=\"line\">put_cpu(); <span class=\"comment\">/* re-enable kernel preemption */</span></span><br></pre></td></tr></table></figure>\n<p>Disabling kernel preemption(<code>get cpu()</code>/<code>put cpu()</code>) while accessing per-cpu data is necessary.<br>\nPreemption then reschedule on another core <em>→</em> cpu not valid anymore.<br>\nAnother task preempting the current one might access the per-cpu data <em>→</em> race condition.</p>\n<p>Linux provides an API to manipulate per-cpu data: <code>percpu</code> in <code> include/linux/percpu.h</code></p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* Compile-time per-cpu data structure usage: */</span></span><br><span class=\"line\">DEFINE_PER_CPU(type, name) ; <span class=\"comment\">/* Creation */</span></span><br><span class=\"line\"><span class=\"comment\">/* To refer to a per-cpu data structure declared elsewhere */</span></span><br><span class=\"line\">DECLARE_PER_CPU(name, type); </span><br><span class=\"line\"><span class=\"comment\">/* Data manipulation */</span></span><br><span class=\"line\">get_cpu_var(name)++; <span class=\"comment\">/* increment name on this CPU */</span> </span><br><span class=\"line\">put_cpu_var(name);  <span class=\"comment\">/* Done, disable kernel preemption */</span></span><br><span class=\"line\"><span class=\"comment\">/* Access another CPU data */</span></span><br><span class=\"line\">per_cpu(name, cpu)++; <span class=\"comment\">/* increment name on the given CPU */</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* Per-cpu data at runtime */</span></span><br><span class=\"line\"><span class=\"comment\">/* Allocation */</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">my_struct</span> *<span class=\"title\">my_var</span> =</span> alloc_percpu(struct my_struct); </span><br><span class=\"line\"><span class=\"keyword\">if</span>(!my_var) &#123;</span><br><span class=\"line\"><span class=\"comment\">/* allocation error */</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">/* Manipulation: */</span></span><br><span class=\"line\">get_cpu_var(my_var)++;</span><br><span class=\"line\">put_cpu_var(my_var);</span><br><span class=\"line\"><span class=\"comment\">/* Deallocation: */</span></span><br><span class=\"line\">free_percpu(my_var);</span><br></pre></td></tr></table></figure>\n<p>Benefits of per-cpu data:<br>\n· Removes/minimizes the need for locking.<br>\n· Reduces cache thrashing.Processor access local data so there is less cache coherency overhead (invalidation) in multicore systems.</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* Per-CPU allocation: usage example (static) */</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;linux/module.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;linux/kernel.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;linux/init.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;linux/percpu.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;linux/kthread.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;linux/sched.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;linux/delay.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;linux/smp.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> PRINT_PREF <span class=\"meta-string\">&quot;[PERCPU] &quot;</span></span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">task_struct</span> *<span class=\"title\">thread1</span>, *<span class=\"title\">thread2</span>, *<span class=\"title\">thread3</span>;</span></span><br><span class=\"line\">DEFINE_PER_CPU(<span class=\"keyword\">int</span>, my_var) ; </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">thread_function</span><span class=\"params\">(<span class=\"keyword\">void</span> *data)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">while</span>(!kthread_should_stop()) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> cpu;</span><br><span class=\"line\">    get_cpu_var(my_var)++;</span><br><span class=\"line\">    cpu = smp_processor_id();</span><br><span class=\"line\">\t\tprintk(<span class=\"string\">&quot;cpu[%d] = %d¥n&quot;</span>,</span><br><span class=\"line\">           cpu, get_cpu_var(my_var)); </span><br><span class=\"line\">    put_cpu_var(my_var);</span><br><span class=\"line\">    msleep(<span class=\"number\">500</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  do_exit(<span class=\"number\">0</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">int</span> _init <span class=\"title\">my_mod_init</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">int</span> cpu;</span><br><span class=\"line\">\tprintk(PRINT_PREF <span class=\"string\">&quot;Entering module.¥n&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">for</span>(cpu=<span class=\"number\">0</span>; cpu&lt;NR_CPUS; cpu++) per_cpu(my_var, cpu) = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t</span><br><span class=\"line\">  wmb();</span><br><span class=\"line\">\tthread1 = kthread_run(thread_function, <span class=\"literal\">NULL</span>, <span class=\"string\">&quot;percpu-thread1&quot;</span>);</span><br><span class=\"line\">\tthread2 = kthread_run(thread_function, <span class=\"literal\">NULL</span>, <span class=\"string\">&quot;percpu-thread2&quot;</span>);</span><br><span class=\"line\">\tthread3 = kthread_run(thread_function, <span class=\"literal\">NULL</span>, <span class=\"string\">&quot;percpu-thread3&quot;</span>);</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"built_in\">exit</span> <span class=\"title\">my_mod_exit</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span> </span>&#123;</span><br><span class=\"line\">  kthread_stop(thread1); </span><br><span class=\"line\">  kthread_stop(thread2); </span><br><span class=\"line\">  kthread_stop(thread3);</span><br><span class=\"line\">\tprintk(KERN_INFO <span class=\"string\">&quot;Exiting module.¥n&quot;</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">module_init(my_mod_init); </span><br><span class=\"line\">module_exit(my_mod_exit);</span><br><span class=\"line\"></span><br><span class=\"line\">MODULE_LICENSE(<span class=\"string\">&quot;GPL&quot;</span>);</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* Per-CPU allocation: usage example (dynamic) */</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;linux/module.h&gt; </span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;linux/kernel.h&gt; </span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;linux/init.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;linux/percpu.h&gt; </span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;linux/kthread.h&gt; </span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;linux/sched.h&gt; </span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;linux/delay.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;linux/smp.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> PRINT_PREF <span class=\"meta-string\">&quot;[PERCPU] &quot;</span></span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">task_struct</span> *<span class=\"title\">thread1</span>, *<span class=\"title\">thread2</span>, * <span class=\"title\">thread3</span>;</span></span><br><span class=\"line\"><span class=\"keyword\">void</span> my_var2;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">thread_function</span><span class=\"params\">(<span class=\"keyword\">void</span> *data)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">while</span>(!kthread_should_stop()) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> *local_ptr, cpu;</span><br><span class=\"line\">    local_ptr = get_cpu_ptr(my_var2); </span><br><span class=\"line\">    cpu = smp_processor_id(); </span><br><span class=\"line\">    (*local_ptr)++;</span><br><span class=\"line\">\t\tprintk(<span class=\"string\">&quot;cpu[%d] = %d¥n&quot;</span>, cpu, *local_ptr); </span><br><span class=\"line\">    put_cpu_ptr(my_var2); </span><br><span class=\"line\">    msleep(<span class=\"number\">500</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  do_exit(<span class=\"number\">0</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">int</span> _init <span class=\"title\">my_mod_init</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">int</span> *local_ptr;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> cpu;</span><br><span class=\"line\">\tprintk(PRINT_PREF <span class=\"string\">&quot;Entering module.¥n&quot;</span>);</span><br><span class=\"line\">  </span><br><span class=\"line\">\tmy_var2 = alloc_percpu(<span class=\"keyword\">int</span>);</span><br><span class=\"line\">  <span class=\"keyword\">if</span>(!my_var2) <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"keyword\">for</span>(cpu=<span class=\"number\">0</span>; cpu&lt;NR_CPUS; cpu++) &#123;</span><br><span class=\"line\">    local_ptr = per_cpu_ptr(my_var2, cpu);</span><br><span class=\"line\">    *local_ptr = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t\tput_cpu();</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">\twmb();</span><br><span class=\"line\">\tthread1 = kthread_run(thread_function, <span class=\"literal\">NULL</span>, <span class=\"string\">&quot;percpu-thread1&quot;</span>);</span><br><span class=\"line\">\tthread2 = kthread_run(thread_function, <span class=\"literal\">NULL</span>, <span class=\"string\">&quot;percpu-thread2&quot;</span>);</span><br><span class=\"line\">\tthread2 = kthread_run(thread_function, <span class=\"literal\">NULL</span>, <span class=\"string\">&quot;percpu-thread2&quot;</span>);</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"built_in\">exit</span> <span class=\"title\">my_mod_exit</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span> </span>&#123;</span><br><span class=\"line\">  kthread_stop(thread1);</span><br><span class=\"line\">  kthread_stop(thread2);</span><br><span class=\"line\">  kthread_stop(thread3);</span><br><span class=\"line\">  free_percpu(my_var2);</span><br><span class=\"line\">  printk(KERN_INFO <span class=\"string\">&quot;Exiting module.¥n&quot;</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">module_init(my_mod_init);</span><br><span class=\"line\">module_exit(my_mod_exit); </span><br><span class=\"line\"></span><br><span class=\"line\">sMODULE_LICENSE(<span class=\"string\">&quot;GPL&quot;</span>);</span><br></pre></td></tr></table></figure>\n<h3 id=\"choosing-the-right-allocation-method\">Choosing the right allocation method<a title=\"#choosing-the-right-allocation-method\" href=\"#choosing-the-right-allocation-method\"></a></h3>\n<p>Need physically contiguous memory?<br>\n· <code>kmalloc()</code> or low-level allocator, with flags:<br>\nGFP_KERNELif sleeping is allowed.<br>\nGFP_ATOMIC otherwise.</p>\n<p>Need large amount of memory, not physically contiguous:<br>\n· <code>vmalloc()</code></p>\n<p>Frequently creating/destroying large amount of the same data structure:<br>\n· Use the slab layer</p>\n<p>Need to allocate from high memory?<br>\n· Use <code>alloc_page()</code> then <code>kmap()</code> or <code>kmap_atomic()</code>.</p>\n","prev":{"title":"Process Scheduling","link":"2020/20201026-Process-Scheduling"},"next":{"title":"Process Management","link":"2020/20201024-Process-Management"},"plink":"https://oreodu.github.io/2020/20201025-Memory-Management/","toc":[{"id":"memory-management","title":"Memory Management","index":"1","children":[{"id":"part.1-address-space-and-memory-descripter","title":"Part.1 Address space and memory descripter","index":"1.1"},{"id":"part.2-virtual-memory-area","title":"Part.2 Virtual Memory Area","index":"1.2"},{"id":"part.3-vma-manipulation","title":"Part.3 VMA manipulation","index":"1.3"},{"id":"part.4-page-tables","title":"Part.4 Page Tables","index":"1.4"},{"id":"part.5-low-level-memory-allocator","title":"Part.5 Low-level memory allocator","index":"1.5"},{"id":"part.6-kmalloc()-and-vmalloc()","title":"Part.6 kmalloc() and vmalloc()","index":"1.6"},{"id":"part.7-slab-layer","title":"Part.7 Slab layer","index":"1.7"},{"id":"part.8-stack,-high-memory-and-per-cpu-allocation","title":"Part.8 Stack, high memory and per-cpu allocation","index":"1.8"}]}],"reward":true,"copyright":{"author":"Oreo Du","link":"<a href=\"https://oreodu.github.io/2020/20201025-Memory-Management/\" title=\"Memory Management\">https://oreodu.github.io/2020/20201025-Memory-Management/</a>","license":"Attribution-NonCommercial-NoDerivatives 4.0 International (<a href=\"https://creativecommons.org/licenses/by-nc-sa/4.0/\" rel=\"external nofollow noopener\" target=\"_blank\">CC BY-NC-ND 4.0</a>)"}}