{"title":"Synchronization","date":"2020-12-17T13:06:00.000Z","date_formatted":{"ll":"Dec 17, 2020","L":"12/17/2020","MM-DD":"12-17"},"link":"2020/20201217-Synchronization","comments":true,"tags":["Linux","Operating System","Synchronization"],"categories":["Linux","Operating System"],"updated":"2020-12-27T12:55:56.268Z","content":"<h1 id=\"synchronization\">Synchronization<a title=\"#synchronization\" href=\"#synchronization\"></a></h1>\n<p>The kernel is programmed using the shared memory model  and shared data must be protected against concurrent access.</p>\n<p>Causes of Concurrency:<br>\n• For a single core :<br>\n• interleaving asynchronousexecution threads (Interruption/preemption)<br>\n• In the kernel:<br>\n• Interrupts<br>\n• Softirqs<br>\n• Kernel preemption<br>\n• Sleeping and synchronization<br>\n• Symmetrical multiprocessing<br>\nIn order to understand and prepare for these, we have to identify shared data and related critical regions. And this needs to be done from the start as concurrency bugs are difficult to detect and solve.</p>\n<p>Critical region/section: part of the code manipulating shared data<br>\n• must execute atomically, i.e. without interruption<br>\n• should not be executed in parallel on SMP<br>\nRace condition: two threads concurrently executing the same critical region.</p>\n<p>• Code safe from access from an interrupt handler: interrupt-safe. This code can be interrupted by an interrupt handler and this will not cause any issue.<br>\n• Code safe from access from multiple cores: SMPsafe. This code can be executed on multiple cores at the same time without issue.<br>\n• Code safe from concurrency with kernel preemption: preempt-safe. This code can be preempted without issue</p>\n<p>Need a mechanism to assure a critical region is executed atomically by only one core at the same time → locks.<br>\nWhen writing some code, observe the data manipulated by the code. If anyone else (thread/handler) can see it, lock it.<br>\nLocking is implemented by the programmer voluntarily (own willing)<br>\n• No indication from the compiler!<br>\n• No protection generally ends up in data corruption<br>\n• → inconsistent behavior for the program<br>\n• → difficult to debug and trace back the source of the issue<br>\n• Locking/unlocking primitives are implemented through atomic operations</p>\n<p>Deadlocks:<br>\nSituations in which one or several threads are waiting on locks for one or several resources that will never be freed.</p>\n<p>Prevent deadlocks:<br>\n• Implement lock ordering.<br>\n• Do not double-acquire the same lock.</p>\n<p>A lock is said to be contented when there are often threads waiting for it. A highly contented lock can become a bottleneck for the system performance.</p>\n<p>• Coarse lock example: protecting an entire subsystem’s shared data structures<br>\n• Simple Implementation<br>\n• Low Scalability<br>\n• Fine-grained locks:<br>\n• Complex Implementation<br>\n• High Scalability</p>\n<h2 id=\"part.1-atomic-operations\">Part.1 Atomic Operations<a title=\"#part.1-atomic-operations\" href=\"#part.1-atomic-operations\"></a></h2>\n<p>It performs (simple) operations in memory and either succeed or fail in their entirety.<br>\n• Regardless of what operations are executed on other cores<br>\n• Without interruption</p>\n<p>Examples:<br>\n• Fetch-and-add: does atomic increment.<br>\n• Test-and-set: sets a value at a memory location and returns the previous value.<br>\n• Compare-and-swap: modifies the content of a memory location only if the previous content is equal to a given value.</p>\n<p>Linux provides two APIs:<br>\n• Integers atomic operations (<code>include/linux/types.h</code>)<br>\n(API defined in <code>include/asm/atomic.h</code>)</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> &#123;</span></span><br><span class=\"line\">  <span class=\"keyword\">int</span> counter;</span><br><span class=\"line\">&#125; <span class=\"keyword\">atomic_t</span>;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Usage</span></span><br><span class=\"line\"><span class=\"keyword\">atomic_t</span> v; <span class=\"comment\">/* define v */</span></span><br><span class=\"line\"><span class=\"keyword\">atomic_t</span> u = ATOMIC_INIT(<span class=\"number\">0</span>); <span class=\"comment\">/* define and initialize u to 0 */</span></span><br><span class=\"line\">atomic_set(&amp;v, <span class=\"number\">4</span>); <span class=\"comment\">/* v = 4 (atomically) */</span></span><br><span class=\"line\">atomic_add(<span class=\"number\">2</span>, &amp;v); <span class=\"comment\">/* v = v + 2 == 6 (atomically) */</span></span><br><span class=\"line\">atomic_inc(&amp;v); <span class=\"comment\">/* v = v + 1 == 7 (atomically) */</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Atomic Integer Operations: Usage Example</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;linux/module.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;linux/kernel.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;linux/init.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;linux/slab.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;linux/delay.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;linux/kthread.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;linux/sched.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;linux/types.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> PRINT_PREF <span class=\"meta-string\">&quot;[SYNC_ATOMIC] &quot;</span></span></span><br><span class=\"line\"><span class=\"keyword\">atomic_t</span> counter; <span class=\"comment\">/* shared data: */</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">task_struct</span> *<span class=\"title\">read_thread</span>, *<span class=\"title\">write_thread</span>;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">writer_function</span><span class=\"params\">(<span class=\"keyword\">void</span> *data)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">while</span> (!kthread_should_stop()) &#123;</span><br><span class=\"line\">  atomic_inc(&amp;counter);</span><br><span class=\"line\">  msleep(<span class=\"number\">500</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  do_exit(<span class=\"number\">0</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">read_function</span><span class=\"params\">(<span class=\"keyword\">void</span> *data)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">while</span> (!kthread_should_stop()) &#123;</span><br><span class=\"line\">  printk(PRINT_PREF <span class=\"string\">&quot;counter: %d¥n&quot;</span>, atomic_read(&amp;counter));</span><br><span class=\"line\">  msleep(<span class=\"number\">500</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  do_exit(<span class=\"number\">0</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">int</span> __init <span class=\"title\">my_mod_init</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span> </span>&#123;</span><br><span class=\"line\">\tprintk(PRINT_PREF <span class=\"string\">&quot;Entering module.¥n&quot;</span>);</span><br><span class=\"line\">\tatomic_set(&amp;counter, <span class=\"number\">0</span>);</span><br><span class=\"line\">\tread_thread = kthread_run(read_function, <span class=\"literal\">NULL</span>, <span class=\"string\">&quot;read-thread&quot;</span>);</span><br><span class=\"line\">\twrite_thread = kthread_run(writer_function, <span class=\"literal\">NULL</span>, <span class=\"string\">&quot;write-thread&quot;</span>);</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> __exit <span class=\"title\">my_mod_exit</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span> </span>&#123;</span><br><span class=\"line\">\tkthread_stop(read_thread);</span><br><span class=\"line\">\tkthread_stop(write_thread);</span><br><span class=\"line\">\tprintk(KERN_INFO <span class=\"string\">&quot;Exiting module.¥n&quot;</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">module_init(my_mod_init);</span><br><span class=\"line\">module_exit(my_mod_exit);</span><br><span class=\"line\">MODULE_LICENSE(<span class=\"string\">&quot;GPL&quot;</span>);</span><br></pre></td></tr></table></figure>\n<p>• Bitwise atomic operations (<code>include/linux/bitops.h</code>)<br>\n(API functions operate on generic pointers (<code>void *</code>)</p>\n<p>​    Example with long on 32-bits systems:<br>\n​      • Bit 31 is the most significant bit<br>\n​     • Bit 0 is the least significant bit</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> word = <span class=\"number\">0</span>; <span class=\"comment\">/* 32 / 64 bits according to the system */</span></span><br><span class=\"line\"></span><br><span class=\"line\">set_bit(<span class=\"number\">0</span>, &amp;word); <span class=\"comment\">/* bit zero is set atomically */</span></span><br><span class=\"line\">set_bit(<span class=\"number\">1</span>, &amp;word); <span class=\"comment\">/* bit one is set atomically */</span></span><br><span class=\"line\">printk(<span class=\"string\">&quot;&amp;ul¥n&quot;</span>, word); <span class=\"comment\">/* print &quot;3&quot; */</span></span><br><span class=\"line\">clear_bit(<span class=\"number\">1</span>, &amp;word); <span class=\"comment\">/* bit one is unset atomically */</span></span><br><span class=\"line\">change_bit(<span class=\"number\">0</span>, &amp;word); <span class=\"comment\">/* flip bit zero atomically (now unset) */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* set bit as zero and return its previous value (atomically) */</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> (test_and_set_bit(<span class=\"number\">0</span>, &amp;word)) &#123;</span><br><span class=\"line\"><span class=\"comment\">/* not true in the case of our example */</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">/* you can mix atomic bit operations and normal C */</span></span><br><span class=\"line\">word = <span class=\"number\">7</span>;</span><br></pre></td></tr></table></figure>\n<h2 id=\"part.2-spin-locks\">Part.2 Spin Locks<a title=\"#part.2-spin-locks\" href=\"#part.2-spin-locks\"></a></h2>\n<p>The most common lock used in the kernel which can be held by at most one thread of execution.</p>\n<p>When a thread tries to acquire an already held lock:<br>\n• Active waiting (spinning)<br>\nHurts performance when spinning for too long. However spin-locks are needed in context where one cannot sleep (interrupt)<br>\n• As opposed to putting the thread to sleep (semaphores/mutexes)</p>\n<p>In process context, do not sleep while holding a spin-lock. Another thread trying to acquire the spin-lock hangs the CPU, preventing you to wake up.</p>\n<p>Usage: (API in <code>include/linux/spinlock.h</code>)</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">DEFINE_SPINLOCK(my_lock);</span><br><span class=\"line\">spin_lock(&amp;my_lock);</span><br><span class=\"line\"><span class=\"comment\">/* critical region */</span></span><br><span class=\"line\">spin_unlock(&amp;my_lock);</span><br></pre></td></tr></table></figure>\n<p>Lock/unlock methods disable/enable kernel preemption and acquire/release the lock. Lock is compiled away on uniprocessor systems and still needs do disabled/re-enable preemption.</p>\n<p>For Interrupt Handlers:<br>\nSpin locks do not sleep: it is safe to use them in interrupt context. In an interruption handler, need to disable local interrupts before taking the lock!</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;linux/module.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;linux/kernel.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;linux/init.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;linux/slab.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;linux/delay.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;linux/spinlock.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;linux/kthread.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;linux/sched.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> PRINT_PREF <span class=\"meta-string\">&quot;[SYNC_SPINLOCK] &quot;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> counter; <span class=\"comment\">/* shared data: */</span></span><br><span class=\"line\">DEFINE_SPINLOCK(counter_lock);</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">task_struct</span> *<span class=\"title\">read_thread</span>, *<span class=\"title\">write_thread</span>;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">writer_function</span><span class=\"params\">(<span class=\"keyword\">void</span> *data)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (!kthread_should_stop()) &#123;</span><br><span class=\"line\">\tspin_lock(&amp;counter_lock);</span><br><span class=\"line\">\tcounter++;</span><br><span class=\"line\">\tspin_unlock(&amp;counter_lock);</span><br><span class=\"line\">\tmsleep(<span class=\"number\">500</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tdo_exit(<span class=\"number\">0</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">read_function</span><span class=\"params\">(<span class=\"keyword\">void</span> *data)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (!kthread_should_stop()) &#123;</span><br><span class=\"line\">\tspin_lock(&amp;counter_lock);</span><br><span class=\"line\">\tprintk(PRINT_PREF <span class=\"string\">&quot;counter: %d¥n&quot;</span>, counter);</span><br><span class=\"line\">\tspin_unlock(&amp;counter_lock);</span><br><span class=\"line\">\tmsleep(<span class=\"number\">500</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  do_exit(<span class=\"number\">0</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">int</span> __init <span class=\"title\">my_mod_init</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span> </span>&#123;</span><br><span class=\"line\">\tprintk(PRINT_PREF <span class=\"string\">&quot;Entering module.¥n&quot;</span>);</span><br><span class=\"line\">\tcounter = <span class=\"number\">0</span>;</span><br><span class=\"line\">\tread_thread = kthread_run(read_function, <span class=\"literal\">NULL</span>, <span class=\"string\">&quot;read-thread&quot;</span>);</span><br><span class=\"line\">\twrite_thread = kthread_run(writer_function, <span class=\"literal\">NULL</span>, <span class=\"string\">&quot;write-thread&quot;</span>);</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> __exit <span class=\"title\">my_mod_exit</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span> </span>&#123;</span><br><span class=\"line\">\tkthread_stop(read_thread);</span><br><span class=\"line\">\tkthread_stop(write_thread);</span><br><span class=\"line\">\tprintk(KERN_INFO <span class=\"string\">&quot;Exiting module.¥n&quot;</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">module_init(my_mod_init);</span><br><span class=\"line\">module_exit(my_mod_exit);</span><br><span class=\"line\">MODULE_LICENSE(<span class=\"string\">&quot;GPL&quot;</span>);</span><br></pre></td></tr></table></figure>\n<p>Reader-Writer Spin Locks:<br>\nWhen entities accessing shared data can be clearly divided into readers and writers.</p>\n<p>Example: list updated (write) and searched (read)<br>\n• When updated, no other entity should update nor search<br>\n• When searched, no other entity should update<br>\n• Safe to allow multiple readers in parallel</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">DEFINE_RWLOCK(my_rwlock); <span class=\"comment\">/* declaration &amp; initialization */</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Reader code</span></span><br><span class=\"line\">read_lock(&amp;my_rwlock);</span><br><span class=\"line\"><span class=\"comment\">/* critical region */</span></span><br><span class=\"line\">read_unlock(&amp;my_rwlock);</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Writer code</span></span><br><span class=\"line\">write_lock(&amp;my_rwlock);</span><br><span class=\"line\"><span class=\"comment\">/* critical region */</span></span><br><span class=\"line\">write_unlock(&amp;my_rwlock);</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Deadlock</span></span><br><span class=\"line\">read_lock(&amp;my_rwlock);</span><br><span class=\"line\">write_lock(&amp;my_rwlock);</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;linux/module.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;linux/kernel.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;linux/init.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;linux/slab.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;linux/delay.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;linux/spinlock.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;linux/kthread.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;linux/sched.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> PRINT_PREF <span class=\"meta-string\">&quot;[SYNC_RWSPINLOCK] &quot;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> counter; <span class=\"comment\">/* shared data: */</span></span><br><span class=\"line\">DEFINE_RWLOCK(counter_lock);</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">task_struct</span> *<span class=\"title\">read_thread1</span>, *<span class=\"title\">read_thread2</span>,</span></span><br><span class=\"line\"><span class=\"class\">*<span class=\"title\">read_thread3</span>, *<span class=\"title\">write_thread</span>;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">writer_function</span><span class=\"params\">(<span class=\"keyword\">void</span> *data)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (!kthread_should_stop()) &#123;</span><br><span class=\"line\">\twrite_lock(&amp;counter_lock);</span><br><span class=\"line\">\tcounter++;</span><br><span class=\"line\">\twrite_unlock(&amp;counter_lock);</span><br><span class=\"line\">\tmsleep(<span class=\"number\">500</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tdo_exit(<span class=\"number\">0</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">read_function</span><span class=\"params\">(<span class=\"keyword\">void</span> *data)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (!kthread_should_stop()) &#123;</span><br><span class=\"line\">\tread_lock(&amp;counter_lock);</span><br><span class=\"line\">\tprintk(PRINT_PREF <span class=\"string\">&quot;counter: %d¥n&quot;</span>, counter);</span><br><span class=\"line\">\tread_unlock(&amp;counter_lock);</span><br><span class=\"line\">\tmsleep(<span class=\"number\">500</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tdo_exit(<span class=\"number\">0</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">int</span> __init <span class=\"title\">my_mod_init</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span> </span>&#123;</span><br><span class=\"line\">\tprintk(PRINT_PREF <span class=\"string\">&quot;Entering module.¥n&quot;</span>);</span><br><span class=\"line\">\tcounter = <span class=\"number\">0</span>;</span><br><span class=\"line\">\tread_thread1 = kthread_run(read_function, <span class=\"literal\">NULL</span>, <span class=\"string\">&quot;read-thread1&quot;</span>);</span><br><span class=\"line\">\tread_thread2 = kthread_run(read_function, <span class=\"literal\">NULL</span>, <span class=\"string\">&quot;read-thread2&quot;</span>);</span><br><span class=\"line\">\tread_thread3 = kthread_run(read_function, <span class=\"literal\">NULL</span>, <span class=\"string\">&quot;read-thread3&quot;</span>);</span><br><span class=\"line\">\twrite_thread = kthread_run(writer_function, <span class=\"literal\">NULL</span>, <span class=\"string\">&quot;write-thread&quot;</span>);</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"part.3-semaphores-and-mutexes\">Part.3 Semaphores and Mutexes<a title=\"#part.3-semaphores-and-mutexes\" href=\"#part.3-semaphores-and-mutexes\"></a></h2>\n<p>Semaphores: sleeping locks (API in <code>include/linux/semaphore.h</code>)<br>\n• A thread trying to acquire an already held lock is put on a waitqueue. When the semaphore becomes available, one task on the waitqueue is awaken.<br>\n• Well suited towards locks held for a long time. On the contrary, large overhead for locks held for short periods.<br>\n• No usable in interrupt context.<br>\n• A thread can sleep while holding a semaphore. Another thread trying to acquire it will sleep and let you continue.<br>\n• A thread cannot hold a spinlock while trying to acquire a semaphore. Might sleep!</p>\n<p>• Contrary to spin locks, semaphores allow multiples holders.<br>\n• Counter initialized to a given value. Decremented each time a thread acquires the<br>\nsemaphore. The semaphore becomes unavailable when the counter reaches 0.<br>\n• In the kernel, most of the semaphores used are binary semaphores<br>\nCounter initialized to:  1 -&gt; initially available, 0 -&gt; initially disabled.</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">semaphore</span> *<span class=\"title\">sem1</span>;</span></span><br><span class=\"line\"></span><br><span class=\"line\">sem1 = kmalloc(<span class=\"keyword\">sizeof</span>(struct semaphore),</span><br><span class=\"line\">GFP_KERNEL);</span><br><span class=\"line\"><span class=\"keyword\">if</span> (!sem1)</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* counter == 1: binary semaphore */</span></span><br><span class=\"line\">sema_init(&amp;sema, <span class=\"number\">1</span>);</span><br><span class=\"line\">down(sem1);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* critical region */</span></span><br><span class=\"line\">up(sem1);</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* Binary semaphore static declaration */</span></span><br><span class=\"line\">DECLARE_MUTEX(sem2);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> (down_interruptible(&amp;sem2)) &#123;</span><br><span class=\"line\"><span class=\"comment\">/* signal received, semaphore not acquired */</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* critical region */</span></span><br><span class=\"line\">up(sem2);</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">DECLARE_RWSEM(rwsem1);</span><br><span class=\"line\"></span><br><span class=\"line\">init_rwsem(&amp;rwsem1);</span><br><span class=\"line\">down_read(rwsem1);</span><br><span class=\"line\"><span class=\"comment\">/* critical (read) region */</span></span><br><span class=\"line\">up_read(&amp;rwsem1);</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">rw_semaphore</span> *<span class=\"title\">rwsem2</span>;</span></span><br><span class=\"line\">rwsem2 = kmalloc(<span class=\"keyword\">sizeof</span>(struct rw_semaphore),</span><br><span class=\"line\">GFP_KERNEL);</span><br><span class=\"line\"><span class=\"keyword\">if</span> (!rwsem2)</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">init_rwsem(rwsem2);</span><br><span class=\"line\">down_write(rwsem2);</span><br><span class=\"line\"><span class=\"comment\">/* critical (write) region */</span></span><br><span class=\"line\">up_write(rwsem2);</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;linux/module.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;linux/kernel.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;linux/init.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;linux/slab.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;linux/delay.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;linux/kthread.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;linux/sched.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;linux/rwsem.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> PRINT_PREF <span class=\"meta-string\">&quot;[SYNC_SEM] &quot;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* shared data: */</span></span><br><span class=\"line\"><span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> counter;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">rw_semaphore</span> *<span class=\"title\">counter_rwsemaphore</span>;</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">task_struct</span> *<span class=\"title\">read_thread</span>, *<span class=\"title\">read_thread2</span>, *<span class=\"title\">write_thread</span>;</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">writer_function</span><span class=\"params\">(<span class=\"keyword\">void</span> *data)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (!kthread_should_stop()) &#123;</span><br><span class=\"line\">\tdown_write(counter_rwsemaphore);</span><br><span class=\"line\">\tcounter++;</span><br><span class=\"line\">  downgrade_write(counter_rwsemaphore);</span><br><span class=\"line\">\tprintk(PRINT_PREF <span class=\"string\">&quot;(writer) counter: %d¥n&quot;</span>, counter);</span><br><span class=\"line\">\tup_read(counter_rwsemaphore);</span><br><span class=\"line\">\tmsleep(<span class=\"number\">500</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tdo_exit(<span class=\"number\">0</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">read_function</span><span class=\"params\">(<span class=\"keyword\">void</span> *data)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (!kthread_should_stop()) &#123;</span><br><span class=\"line\">\tdown_read(counter_rwsemaphore);</span><br><span class=\"line\">\tprintk(PRINT_PREF <span class=\"string\">&quot;counter: %d¥n&quot;</span>, counter);</span><br><span class=\"line\">\tup_read(counter_rwsemaphore);</span><br><span class=\"line\">\tmsleep(<span class=\"number\">500</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tdo_exit(<span class=\"number\">0</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">int</span> __init <span class=\"title\">my_mod_init</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span> </span>&#123;</span><br><span class=\"line\">\tprintk(PRINT_PREF <span class=\"string\">&quot;Entering module.¥n&quot;</span>);</span><br><span class=\"line\">\tcounter = <span class=\"number\">0</span>;</span><br><span class=\"line\">  </span><br><span class=\"line\">\tcounter_rwsemaphore = kmalloc(<span class=\"keyword\">sizeof</span>(struct rw_semaphore), GFP_KERNEL);</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (!counter_rwsemaphore)</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">  </span><br><span class=\"line\">\tinit_rwsem(counter_rwsemaphore);</span><br><span class=\"line\">\tread_thread = kthread_run(read_function, <span class=\"literal\">NULL</span>, <span class=\"string\">&quot;read-thread&quot;</span>);</span><br><span class=\"line\">\tread_thread2 = kthread_run(read_function, <span class=\"literal\">NULL</span>, <span class=\"string\">&quot;read-thread2&quot;</span>);</span><br><span class=\"line\">\twrite_thread = kthread_run(writer_function, <span class=\"literal\">NULL</span>, <span class=\"string\">&quot;write-thread&quot;</span>);</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> __exit <span class=\"title\">my_mod_exit</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span> </span>&#123;</span><br><span class=\"line\">\tkthread_stop(read_thread);</span><br><span class=\"line\">\tkthread_stop(write_thread);</span><br><span class=\"line\">\tkthread_stop(read_thread2);</span><br><span class=\"line\">\tkfree(counter_rwsemaphore);</span><br><span class=\"line\">\tprintk(KERN_INFO <span class=\"string\">&quot;Exiting module.¥n&quot;</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">module_init(my_mod_init);</span><br><span class=\"line\">module_exit(my_mod_exit);</span><br><span class=\"line\">MODULE_LICENSE(<span class=\"string\">&quot;GPL&quot;</span>);</span><br></pre></td></tr></table></figure>\n<p>Mutexes are binary semaphore with stricter use cases: (API in <code>include/linux/mutex.h</code>)<br>\n• Only one thread can hold the mutex at a time.<br>\n• A thread locking a mutex must unlock it.<br>\n• No recursive lock and unlock operations.<br>\n• A thread cannot exit while holding a mutex.<br>\n• A mutex cannot be acquired in interrupt context.<br>\n• A mutex can be managed only through the API.</p>\n<p>With special debugging mode: (CONFIG_DEBUG_MUTEXES)<br>\nThe kernel can check and warn if these constraints are not met.</p>\n<p>If these constraints disallow the use of mutexes, use semaphores. Otherwise always use mutexes.</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">DEFINE_MUTEX(mut1); <span class=\"comment\">/* static */</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">mutex</span> *<span class=\"title\">mut2</span> =</span> kmalloc(<span class=\"keyword\">sizeof</span>(struct mutex), GFP_KERNEL); <span class=\"comment\">/* dynamic */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> (!mut2)</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">mutex_init(mut2);</span><br><span class=\"line\">mutex_lock(&amp;mut1);</span><br><span class=\"line\"><span class=\"comment\">/* critical region */</span></span><br><span class=\"line\">mutex_unlock(&amp;mut1);</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;linux/module.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;linux/kernel.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;linux/init.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;linux/slab.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;linux/delay.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;linux/kthread.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;linux/sched.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;linux/mutex.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> PRINT_PREF <span class=\"meta-string\">&quot;[SYNC_MUTEX]: &quot;</span></span></span><br><span class=\"line\"><span class=\"comment\">/* shared data: */</span></span><br><span class=\"line\"><span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> counter;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">mutex</span> *<span class=\"title\">mut</span>;</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">task_struct</span> *<span class=\"title\">read_thread</span>, *<span class=\"title\">write_thread</span>;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">writer_function</span><span class=\"params\">(<span class=\"keyword\">void</span> *data)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (!kthread_should_stop()) &#123;</span><br><span class=\"line\">\tmutex_lock(mut);</span><br><span class=\"line\">\tcounter++;</span><br><span class=\"line\">\tmutex_unlock(mut);</span><br><span class=\"line\">\tmsleep(<span class=\"number\">500</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tdo_exit(<span class=\"number\">0</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">read_function</span><span class=\"params\">(<span class=\"keyword\">void</span> *data)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (!kthread_should_stop()) &#123;</span><br><span class=\"line\">\tmutex_lock(mut);</span><br><span class=\"line\">\tprintk(PRINT_PREF <span class=\"string\">&quot;counter: %d¥n&quot;</span>, counter);</span><br><span class=\"line\">\tmutex_unlock(mut);</span><br><span class=\"line\">\tmsleep(<span class=\"number\">500</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tdo_exit(<span class=\"number\">0</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">int</span> __init <span class=\"title\">my_mod_init</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span> </span>&#123;</span><br><span class=\"line\">\tprintk(PRINT_PREF <span class=\"string\">&quot;Entering module.¥n&quot;</span>);</span><br><span class=\"line\">\tcounter = <span class=\"number\">0</span>;</span><br><span class=\"line\">  </span><br><span class=\"line\">\tmut = kmalloc(<span class=\"keyword\">sizeof</span>(struct mutex), GFP_KERNEL);</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (!mut)</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">\tmutex_init(mut);</span><br><span class=\"line\">\tread_thread = kthread_run(read_function, <span class=\"literal\">NULL</span>, <span class=\"string\">&quot;read-thread&quot;</span>);</span><br><span class=\"line\">\twrite_thread = kthread_run(writer_function, <span class=\"literal\">NULL</span>, <span class=\"string\">&quot;write-thread&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> __exit <span class=\"title\">my_mod_exit</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span> </span>&#123;</span><br><span class=\"line\">\tkthread_stop(read_thread);</span><br><span class=\"line\">\tkthread_stop(write_thread);</span><br><span class=\"line\">\tkfree(mut);</span><br><span class=\"line\">\tprintk(KERN_INFO <span class=\"string\">&quot;Exiting module.¥n&quot;</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">module_init(my_mod_init);</span><br><span class=\"line\">module_exit(my_mod_exit);</span><br><span class=\"line\">MODULE_LICENSE(<span class=\"string\">&quot;GPL&quot;</span>);</span><br></pre></td></tr></table></figure>\n<p>Spin Lock vs Mutex Usage<br>\n• Low overhead locking needed? use spin lock<br>\n• Short lock hold time? use spin lock<br>\n• Long lock hold time? use mutex<br>\n• Need to lock in interrupt context? use spin lock<br>\n• Need to sleep while holding? use mutex</p>\n<h2 id=\"part.4-other-synchronization-mechanisms\">Part.4 Other Synchronization Mechanisms<a title=\"#part.4-other-synchronization-mechanisms\" href=\"#part.4-other-synchronization-mechanisms\"></a></h2>\n<h3 id=\"completion-variables:\">Completion Variables:<a title=\"#completion-variables:\" href=\"#completion-variables:\"></a></h3>\n<p>(API in <code>include/linux/completion.h</code>)<br>\nCompletion variables are used when a thread needs to signal another one of some event. Waiting thread sleeps.</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">DECLARE_COMPLETION(comp1); <span class=\"comment\">/* static */</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">completion</span> *<span class=\"title\">comp2</span> =</span> kmalloc(<span class=\"keyword\">sizeof</span>(struct completion), GFP_KERNEL); <span class=\"comment\">/* dynamic */</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> (!comp2)</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">init_completion(comp2);</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Thread A</span></span><br><span class=\"line\"><span class=\"comment\">/* signal event: */</span></span><br><span class=\"line\">complete(comp1);</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Thread B</span></span><br><span class=\"line\"><span class=\"comment\">/* wait for signal: */</span></span><br><span class=\"line\">wait_for_completion(comp1);</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;linux/module.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;linux/kernel.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;linux/init.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;linux/slab.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;linux/delay.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;linux/kthread.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;linux/sched.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;linux/completion.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> PRINT_PREF <span class=\"meta-string\">&quot;[SYNC_COMP] &quot;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> counter; <span class=\"comment\">/* shared data: */</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">completion</span> *<span class=\"title\">comp</span>;</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">task_struct</span> *<span class=\"title\">read_thread</span>, *<span class=\"title\">write_thread</span>;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">writer_function</span><span class=\"params\">(<span class=\"keyword\">void</span> *data)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (counter != <span class=\"number\">1234</span>)</span><br><span class=\"line\">\t\tcounter++;</span><br><span class=\"line\">\tcomplete(comp);</span><br><span class=\"line\">\tdo_exit(<span class=\"number\">0</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">read_function</span><span class=\"params\">(<span class=\"keyword\">void</span> *data)</span> </span>&#123;</span><br><span class=\"line\">\twait_for_completion(comp);</span><br><span class=\"line\">\tprintk(PRINT_PREF <span class=\"string\">&quot;counter: %d¥n&quot;</span>, counter);</span><br><span class=\"line\">\tdo_exit(<span class=\"number\">0</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">int</span> __init <span class=\"title\">my_mod_init</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span> </span>&#123;</span><br><span class=\"line\">\tprintk(PRINT_PREF <span class=\"string\">&quot;Entering module.¥n&quot;</span>);</span><br><span class=\"line\">\tcounter = <span class=\"number\">0</span>;</span><br><span class=\"line\">  </span><br><span class=\"line\">\tcomp = kmalloc(<span class=\"keyword\">sizeof</span>(struct completion), GFP_KERNEL);</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (!comp) <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">  </span><br><span class=\"line\">\tinit_completion(comp);</span><br><span class=\"line\">\tread_thread = kthread_run(read_function, <span class=\"literal\">NULL</span>, <span class=\"string\">&quot;read-thread&quot;</span>);</span><br><span class=\"line\">\twrite_thread = kthread_run(writer_function, <span class=\"literal\">NULL</span>, <span class=\"string\">&quot;write-thread&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> __exit <span class=\"title\">my_mod_exit</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span> </span>&#123;</span><br><span class=\"line\">\tkfree(comp);</span><br><span class=\"line\">\tprintk(KERN_INFO <span class=\"string\">&quot;Exiting module.¥n&quot;</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">module_init(my_mod_init);</span><br><span class=\"line\">module_exit(my_mod_exit);</span><br><span class=\"line\">MODULE_LICENSE(<span class=\"string\">&quot;GPL&quot;</span>);</span><br></pre></td></tr></table></figure>\n<h3 id=\"preemption-disabling:\">Preemption Disabling:<a title=\"#preemption-disabling:\" href=\"#preemption-disabling:\"></a></h3>\n<p>When a spin lock is held and preemption is disabled. Some situations require preemption disabling without involving spin locks.</p>\n<p>API to disable kernel preemption<br>\n• can nest and be implemented through a counter<br>\n• preempt_disable(). Disable kernel preemption, increment preemption counter<br>\n• preempt_enable(). Decrement counter and enable preemption if it reaches 0<br>\n• preempt_enable_no_resched(). Enables kernel preemption and does not check for any pending reschedule.<br>\n• preempt_count(). Returns preemption counter.<br>\n• get_cpu(). Disables preemption and return the current CPU id.</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> cpu = get_cpu(); <span class=\"comment\">/* disable preemption and return current CPU id */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> *<span class=\"title\">my_struct</span> <span class=\"title\">my_variable</span> =</span> per_cpu_structs_array[cpu];</span><br><span class=\"line\"><span class=\"comment\">/* manipulate my_variable */</span></span><br><span class=\"line\">put_cpu(); <span class=\"comment\">/* re-enable preemption */</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"sequential-locks\">Sequential Locks<a title=\"#sequential-locks\" href=\"#sequential-locks\"></a></h3>\n<p>(API in <code>include/linux/seqlock.h</code>)<br>\nReader-writer spinlock scaling to many readers and favoring writers.<br>\n• Implemented with a counter (sequence number).<br>\n• Before and after reading the data, the counter is checked.</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">seqlock_t</span> my_seq_lock = DEFINE_SEQLOCK(my_seq_lock);</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Write path</span></span><br><span class=\"line\">write_seqlock(&amp;my_seq_lock);</span><br><span class=\"line\"><span class=\"comment\">/* critical (write) region */</span></span><br><span class=\"line\">write_sequnlock(&amp;my_seq_lock);</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Read path</span></span><br><span class=\"line\"><span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> seq;</span><br><span class=\"line\"><span class=\"keyword\">do</span> &#123;</span><br><span class=\"line\">\tseq = read_seqbegin(&amp;my_seq_lock);</span><br><span class=\"line\">\t<span class=\"comment\">/* read data here ... */</span></span><br><span class=\"line\">&#125; <span class=\"keyword\">while</span> (read_seqretry(&amp;my_seq_lock, seq));</span><br></pre></td></tr></table></figure>\n<p>Seq locks are useful when:<br>\n• There are many readers and few writers.<br>\n• Writers should be favored over readers.</p>\n<p>Example: jiffies.</p>\n<h2 id=\"part.5-ordering-and-memory-barriers\">Part.5 Ordering and Memory Barriers<a title=\"#part.5-ordering-and-memory-barriers\" href=\"#part.5-ordering-and-memory-barriers\"></a></h2>\n<p>Memory reads (load) and write (store) operations can be reordered.<br>\n• By the compiler (compile time)<br>\n• By the CPU (run time)</p>\n<p>CPU/compiler are not aware about code in other context.<br>\n• Communication with hardware<br>\n• Symmetric multiprocessing</p>\n<p>Memory barriers instruction allows to force the actual execution of load and stores at some point in the program.</p>\n<p>• rmb() (read memory barrier):<br>\n• No load prior to the code will be reordered after the call<br>\n• No load after the call will be reordered before the call<br>\n• i.e. commit all pending loads before continuing<br>\n• wmb() (write memory barrier):<br>\n• Same as rmb() with stores instead of loads<br>\n• mb(): Concerns loads and stores<br>\n• barrier(): Same as mb() but only for the compiler<br>\n• read_barrier_depends(). Prevent data-dependent loads (b = a) to be reordered across the barrier. Less costly than rmb() as we block only on a subset of pending loads</p>\n<p>Usage: SMP Optimizations<br>\n• smp_rmb(): rmb() on SMP and barrier() on UP<br>\n• smp_read_barrier_depends(): read_barrier_depends() on SMP and barrier() on UP<br>\n• smp_wmb(): wmb() on SMP and barrier() on UP<br>\n• smp_mb(): mb() on SMP and barrier() on UP</p>\n","prev":{"title":"Trie","link":"2020/20201219-Trie"},"next":{"title":"Heap","link":"2020/2020-12-09-Heap"},"plink":"https://oreodu.github.io/2020/20201217-Synchronization/","toc":[{"id":"synchronization","title":"Synchronization","index":"1","children":[{"id":"part.1-atomic-operations","title":"Part.1 Atomic Operations","index":"1.1"},{"id":"part.2-spin-locks","title":"Part.2 Spin Locks","index":"1.2"},{"id":"part.3-semaphores-and-mutexes","title":"Part.3 Semaphores and Mutexes","index":"1.3"},{"id":"part.4-other-synchronization-mechanisms","title":"Part.4 Other Synchronization Mechanisms","index":"1.4"},{"id":"part.5-ordering-and-memory-barriers","title":"Part.5 Ordering and Memory Barriers","index":"1.5"}]}],"reward":true,"copyright":{"author":"Oreo Du","link":"<a href=\"https://oreodu.github.io/2020/20201217-Synchronization/\" title=\"Synchronization\">https://oreodu.github.io/2020/20201217-Synchronization/</a>","license":"Attribution-NonCommercial-NoDerivatives 4.0 International (<a href=\"https://creativecommons.org/licenses/by-nc-sa/4.0/\" rel=\"external nofollow noopener\" target=\"_blank\">CC BY-NC-ND 4.0</a>)"}}