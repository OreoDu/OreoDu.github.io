{"title":"Process Scheduling","date":"2020-10-26T01:25:00.000Z","date_formatted":{"ll":"Oct 26, 2020","L":"10/26/2020","MM-DD":"10-26"},"link":"2020/20201026-Process-Scheduling","comments":true,"tags":["Operating System"],"categories":["Linux","Operating System"],"updated":"2020-10-30T12:06:50.816Z","content":"<h1 id=\"process-scheduling\">Process Scheduling<a title=\"#process-scheduling\" href=\"#process-scheduling\"></a></h1>\n<h2 id=\"part.1-general-information\">Part.1 General information<a title=\"#part.1-general-information\" href=\"#part.1-general-information\"></a></h2>\n<h3 id=\"scheduling\">Scheduling<a title=\"#scheduling\" href=\"#scheduling\"></a></h3>\n<p>When in the system there are more ready-to-run processes than the number of cores. The scheduler is responsible for making the best use of the resource that is the CPU time and decides which process should run,  when, and for how long.</p>\n<p>Now: <strong>Completely Fair Scheduler (CFS)</strong> is used in Linux.</p>\n<h3 id=\"multitasking\">Multitasking<a title=\"#multitasking\" href=\"#multitasking\"></a></h3>\n<p>Single core: gives the illusion that multiple processes are running concurrently.<br>\nMulti-cores: enable true parallelism.</p>\n<p>2 types of multitasking OS:<br>\n· Cooperative multitasking: a process does not stop running until it decides to do so (yield the CPU).<br>\n· Preemptive multitasking: The OS can interrupt the execution of a process: preemption. Generally after the process expires its timeslice. It is based on tasks priorities.</p>\n<h3 id=\"scheduling-policy\">Scheduling policy<a title=\"#scheduling-policy\" href=\"#scheduling-policy\"></a></h3>\n<p>Scheduling policy are the set of rules determining the choices made by a given model of scheduler.</p>\n<p>· I/O-bound processes<br>\nSpend most of their time <em>waiting for I/O</em>: disk, network, but also keyboard, mouse, etc. Should run often and for a small time frame.</p>\n<p>· Compute-bound processes<br>\nHeavy use of the CPU. Should not run often, but for a long time.</p>\n<ol>\n<li>Priority</li>\n</ol>\n<p>Order process according to their ”importance” from the scheduler standpoint.</p>\n<p>Linux has 2 priority ranges:</p>\n<img src=\"https://tva1.sinaimg.cn/large/0081Kckwly1gk2i0y1dnpj30za05a0uq.jpg\" alt=\"Screen Shot 2020-10-26 at 09.53.58\" style=\"zoom: 33%;\">\n<p>· Nice value : ranges from <code>-20 to +19</code>, default is 0 (High values of nice means lower priority)<br>\nList process and their nice values with <code>ps ax -o pid,ni,cmd</code></p>\n<p>· Real-time priority : range configurable (default 0 to 99) (Higher values mean higher priority）<br>\nProcesses labeled real-time always execute before standard (nice) processes.<br>\nList processes and their real-time priority using <code>ps ax -o pid,rtprio,cmd</code></p>\n<ol start=\"2\">\n<li>Timeslice</li>\n</ol>\n<p>How much time a process should execute before being preempted. The timeslice a process receives is function of the load of the systems and is also weighted by the process priority. It is <em>a proportion</em> of the CPU.</p>\n<h2 id=\"part.2-linux-completely-fair-scheduler-(cfs)\">Part.2 Linux Completely Fair Scheduler (CFS)<a title=\"#part.2-linux-completely-fair-scheduler-(cfs)\" href=\"#part.2-linux-completely-fair-scheduler-(cfs)\"></a></h2>\n<h3 id=\"scheduling-classes\">Scheduling classes<a title=\"#scheduling-classes\" href=\"#scheduling-classes\"></a></h3>\n<p>· CPU classes : coexisting CPU algorithms. Each task belongs to a class.</p>\n<p>CFS: <code>SCHED_OTHER</code>, implemented in <code>kernel/sched/fair.c</code>.</p>\n<p>· Real-time classes : For predictable schedule. <code>SCHED_RR</code>, <code>SCHED_FIFO</code>, <code>SCHED_DEADLINE</code></p>\n<p><code>sched_class</code> data structure :</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">sched_class</span> &#123;</span></span><br><span class=\"line\">   <span class=\"comment\">/* Called when a task enters a runnable stat */</span></span><br><span class=\"line\">  <span class=\"keyword\">void</span> (*enqueue_task) (<span class=\"comment\">/* . . . */</span>);</span><br><span class=\"line\">  <span class=\"comment\">/* Called when a task becomes unrunnable */</span></span><br><span class=\"line\">\t<span class=\"keyword\">void</span> (*dequeue_task) (<span class=\"comment\">/* . . . */</span>);</span><br><span class=\"line\">  <span class=\"comment\">/* Yield the processor (dequeue then enqueue back immediatly) */</span></span><br><span class=\"line\">\t<span class=\"keyword\">void</span> (*yield_task) (<span class=\"comment\">/* . . . */</span>);</span><br><span class=\"line\">  <span class=\"comment\">/* Checks if a task that entered the runnable state should preempt the currently running task */</span></span><br><span class=\"line\">\t<span class=\"keyword\">void</span> (*check_preempt_curr) (<span class=\"comment\">/* . . . */</span>);</span><br><span class=\"line\">  <span class=\"comment\">/* Chooses the next task to run */</span></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">task_struct</span> * (*<span class=\"title\">pick_next_task</span>) (/* . . . */);</span> </span><br><span class=\"line\">  <span class=\"comment\">/* Called when the currentluy running task changes its scheduling class or task group to the related scheduler */</span></span><br><span class=\"line\">  <span class=\"keyword\">void</span> (*set_cur_task) (<span class=\"comment\">/* \t...*/</span>);</span><br><span class=\"line\">  <span class=\"comment\">/* Called regularly (default: 10 ms) from the system timer tick handler, might lead to context switch */</span></span><br><span class=\"line\">\t<span class=\"keyword\">void</span> (*task_tick) (<span class=\"comment\">/* . . . */</span>);</span><br><span class=\"line\">\t<span class=\"comment\">/*...*/</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"fair-scheduling\">Fair scheduling<a title=\"#fair-scheduling\" href=\"#fair-scheduling\"></a></h3>\n<p>3 main (high-level) CFS concepts;<br>\n· CFS runs a process for some times, then swaps it for the runnable process that has run the least.<br>\n· No default timeslice, CFS calculates how long a process should run according to the number of runnable processes.<br>\n· No default timeslice, CFS calculates how long a process should run according to the number of runnable processes.</p>\n<p><strong>Targeted latency</strong> : period during which all runnable processes should be scheduled at least once.</p>\n<h2 id=\"part.3-cfs-implementation\">Part.3 CFS implementation<a title=\"#part.3-cfs-implementation\" href=\"#part.3-cfs-implementation\"></a></h2>\n<h3 id=\"time-accounting\">Time accounting<a title=\"#time-accounting\" href=\"#time-accounting\"></a></h3>\n<p><code>sched_entity</code> structure in the <code>task_struct</code> (se field).</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">sched_entity</span> &#123;</span></span><br><span class=\"line\">  <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">load_weight</span> <span class=\"title\">load</span>;</span> </span><br><span class=\"line\">  <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">rb_node</span> <span class=\"title\">run_node</span>;</span> </span><br><span class=\"line\">  <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">list_head</span> <span class=\"title\">group_node</span>;</span> </span><br><span class=\"line\">  <span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> on_rq;</span><br><span class=\"line\">  </span><br><span class=\"line\">  u64 exec_start;</span><br><span class=\"line\">\tu64 sum_exec_runtime;</span><br><span class=\"line\">\tu64 vruntime;</span><br><span class=\"line\">\tu64 prev_sum_exec_runtime;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"comment\">/* additional statistics not shown here */</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>Virtual runtime: How much time a process has been executed (ns).</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">update_curr</span><span class=\"params\">(struct cfs_rq * cfs_rq)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">sched_entity</span> *<span class=\"title\">curr</span> =</span> cfs_rq -&gt; curr;</span><br><span class=\"line\">  u64 now  = rq_clock_task(rq_of(cfs_rq));</span><br><span class=\"line\">  u64 delta_exec;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"keyword\">if</span> (unlikely(!curr)) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">  </span><br><span class=\"line\">  delta_exec = now - curr-&gt;exec_start;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (unlikely(s64)delta_exec &lt;= <span class=\"number\">0</span>) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">  </span><br><span class=\"line\">  curr-&gt;exec_start = now;</span><br><span class=\"line\">  </span><br><span class=\"line\">  schedstat_set(curr-&gt;statistics.exec_max, max(delta_exec, curr-&gt;statistics.exec_max));</span><br><span class=\"line\">  curr-&gt;sum_exec_runtime += delta_exec;</span><br><span class=\"line\">  schedstat_add(cfs_rq-&gt;exec_clock, delta_exec);</span><br><span class=\"line\">  </span><br><span class=\"line\">  curr-&gt;vruntome += calc_delta_fair(delta_exec,curr);</span><br><span class=\"line\">  update_min_vruntme(cfs_rq);</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"keyword\">if</span>(entity_is_task(curr)) &#123;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">task_struct</span> *<span class=\"title\">currtask</span> =</span> task_of(curr);</span><br><span class=\"line\">    </span><br><span class=\"line\">    trace_sched_stat_runtime(curtask, delta_exec, curr-&gt;vruntime);</span><br><span class=\"line\">    cpuacct_charge(curtask, delta_exec);</span><br><span class=\"line\">    account_group_exec_runtime(curtask, delta_exec);</span><br><span class=\"line\">    </span><br><span class=\"line\">    account_cfs_rq_runtime(cfs_rq, delta_exec);</span><br><span class=\"line\">  &#125;  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>Invoked regularly by the system timer, and when a process becomes runnable/unrunnable.</p>\n<h3 id=\"process-selection\">Process selection<a title=\"#process-selection\" href=\"#process-selection\"></a></h3>\n<p>When CFS needs to choose which runnable process to run next:<br>\nThe process with the smallest runtime is selected. It is the leftmost node in the tree.</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">struct sched_entity * <span class=\"title\">pick_first_entity</span><span class=\"params\">(struct cfs_rq *cfs_rq)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">rb_node</span> *<span class=\"title\">left</span> =</span>cfs_rq-&gt;rb_leftmost;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (!left) <span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> rb_entry(left, struct sched_entity, run_node);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ol>\n<li>adding a process to the tree</li>\n</ol>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* Aprocess is added through enqueue entity. */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">enqueue_entity</span><span class=\"params\">(struct cfs_rq *cfs_rq, </span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                           struct sched_entity *se, <span class=\"keyword\">int</span> flags)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">bool</span> renorm = ! (flags &amp; ENQUEUE_WAKEUP) || (flags &amp; ENQUEUE_MIGRATED); </span><br><span class=\"line\">  <span class=\"keyword\">bool</span> curr = cfs_rq-&gt;curr == se;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (renorm &amp;&amp;curr) se-&gt;vruntime += cfs_rq-&gt;min_vruntime;</span><br><span class=\"line\">\t</span><br><span class=\"line\">  update_curr(cfs_rq);</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"keyword\">if</span> (renorm &amp;&amp;!curr) se-&gt;vruntime += cfs_rq-&gt;min_vruntime;</span><br><span class=\"line\">  </span><br><span class=\"line\">\tupdate_load_avg(se, UPDATE_TG);</span><br><span class=\"line\">  enqueue_entity_load_avg(cfs_rq, se);</span><br><span class=\"line\">  account_entity_enqueue(cfs_rq, se);</span><br><span class=\"line\">  update_cfs_shares(cfs_rq);</span><br><span class=\"line\">  </span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(flags &amp; ENQUEUE_WAKEUP) place_entity(cfs_rq, se, <span class=\"number\">0</span>);</span><br><span class=\"line\">  </span><br><span class=\"line\">  check_schedstat_required(); </span><br><span class=\"line\">  update_stats_enqueue(cfs_rq, se, flags); </span><br><span class=\"line\">  check_spread(cfs_rq, se);</span><br><span class=\"line\">  </span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(!curr) enqueue_entity(cfs_rq, se);</span><br><span class=\"line\">  se-&gt;on_rq = <span class=\"number\">1</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (cfs_rq-&gt;nr_running == <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">    list_add_leaf_cfs_rq(cfs_rq);</span><br><span class=\"line\">    check_enqueue_throttle(cfs_rq);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">enqueue_entity</span><span class=\"params\">(struct cfs_rq, *cfs_rq, </span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                           struct sched_entity *se)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">rb_node</span> **<span class=\"title\">link</span> =</span> &amp;cfs_rq-&gt;tasks_timeline.rb_node; </span><br><span class=\"line\">  <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">rb_node</span> *<span class=\"title\">parent</span> =</span> <span class=\"literal\">NULL</span>; </span><br><span class=\"line\">  <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">sched_entity</span> *<span class=\"title\">entry</span>;</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> leftmost = <span class=\"number\">1</span>;</span><br><span class=\"line\">\t<span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">\t* Find the right place in the rbtree: </span></span><br><span class=\"line\"><span class=\"comment\">\t*/</span></span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (*link) &#123;</span><br><span class=\"line\">    parent = *link;</span><br><span class=\"line\">\t  entry = rb_entry(parent, struct sched_entity, run_node);</span><br><span class=\"line\">\t<span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">\t* Wedont care about collisions. </span></span><br><span class=\"line\"><span class=\"comment\">\t* Nodes with\tthe same key stay together. </span></span><br><span class=\"line\"><span class=\"comment\">\t*/</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (entity_before(se, entry)) &#123;</span><br><span class=\"line\">    link = &amp;parent-&gt;rb_left;</span><br><span class=\"line\">   &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">    link =&amp;parent-&gt;rb_right;</span><br><span class=\"line\">    leftmost = <span class=\"number\">0</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">* Maintain a cache of leftmost tree </span></span><br><span class=\"line\"><span class=\"comment\">* entries (it is frequently used): </span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> (leftmost) cfs_rq-&gt;rb_leftmost = &amp;se-&gt;run_node; </span><br><span class=\"line\">rb_link_node(&amp;se-&gt;run_node, parent, link);</span><br><span class=\"line\">rb_insert_color(&amp;se-&gt;run_node, &amp;cfs_rq-&gt;tasks_timeline);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">    </span><br></pre></td></tr></table></figure>\n<ol start=\"2\">\n<li>removing a process from the tree</li>\n</ol>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">struct <span class=\"keyword\">void</span> <span class=\"title\">dequeue_entity</span><span class=\"params\">(struct cfs_rq *cfs_rq, </span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                           struct sched_entity *se, <span class=\"keyword\">int</span> flags)</span> </span>&#123;</span><br><span class=\"line\">  update_curr(cfs_rq); </span><br><span class=\"line\">  dequeue_entity_load_avg(cfs_rq, se);</span><br><span class=\"line\">  update_stats_dequeue(cfs_rq, se, flags );</span><br><span class=\"line\">  </span><br><span class=\"line\">  clear_buddies(cfs_rq, se);</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"keyword\">if</span> (se != cfs_rq-&gt;curr) dequeue_entity(cfs_rq, se);</span><br><span class=\"line\">  se-&gt;on_rq = <span class=\"number\">0</span>;</span><br><span class=\"line\">  account_entity_dequeue(cfs_rq, se);</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!(flags &amp; DEQUEUE_SLEEP)) se-&gt;vruntime -= cfs_rq-&gt;min_vruntime; </span><br><span class=\"line\">  </span><br><span class=\"line\">  return_cfs_rq_runtime(cfs_rq);</span><br><span class=\"line\">  update_cfs_shares(cfs_rq);</span><br><span class=\"line\">  </span><br><span class=\"line\">\t<span class=\"keyword\">if</span> ((flags &amp;(DEQUEUE_SAVE| DEQUEUE_MOVE)) == DEQUEUE_SAVE)</span><br><span class=\"line\">    update_min_vruntime(cfs_rq);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">dequeue_entity</span><span class=\"params\">(struct cfs_rq *cfs_rq, s</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                           truct sched_entity *se)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (cfs_rq-&gt;rb_leftmost == &amp;se-&gt;run_node) &#123; </span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">rb_node</span> *<span class=\"title\">next_node</span>;</span></span><br><span class=\"line\">    next_node = rb_next(&amp;se-&gt;run_node);</span><br><span class=\"line\">    cfs_rq-&gt;rb_leftmost = next_node;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">\trb_erase(&amp;se-&gt;run_node, &amp;cfs_rq-&gt;tasks_timeline);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ol start=\"3\">\n<li>Entry point: <code>schedule()</code></li>\n</ol>\n<p>The kernel calls <code>schedule()</code> anytime it wants to invoke the scheduler. Calls <code>pick_next_task()</code>.</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">inline</span> struct task_struct * <span class=\"title\">pick_next_task</span><span class=\"params\">(struct rq *rq, struct</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">task_struct *prev, struct pin_cookie cookie)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">sched_class</span> *<span class=\"keyword\">class</span> =</span> &amp; fair_sched_class; </span><br><span class=\"line\">  <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">task_struct</span> *<span class=\"title\">p</span>;</span></span><br><span class=\"line\">  </span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (likely(prev-&gt;sched_class ==class &amp;&amp; </span><br><span class=\"line\">             rq-&gt;nr_running == rq-&gt;cfs.h_nr_running)) &#123;</span><br><span class=\"line\">    p = fair_sched_class.pick_next_task(rq, prev, cookie);</span><br><span class=\"line\">    </span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (unlikely(p == RETRY_TASK)) <span class=\"keyword\">goto</span> again;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (unlikely(!p)) p = idle_sched_class.pick_next_task(rq, prev, cookie);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">return</span> p;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">again: </span><br><span class=\"line\">  for_each_class(class) &#123;</span><br><span class=\"line\">    p =class-&gt;pick_next_task(rq, prev, cookie);</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(p)&#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (unlikely(p == RETRY_TASK)) <span class=\"keyword\">goto</span> again; </span><br><span class=\"line\">      <span class=\"keyword\">return</span> p;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"> BUG(); </span><br><span class=\"line\"> <span class=\"comment\">/* the idle class will always have a runnable task */</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"sleeping-and-waking-up\">Sleeping and waking up<a title=\"#sleeping-and-waking-up\" href=\"#sleeping-and-waking-up\"></a></h3>\n<p>Multiple reasons for a task to sleep:<br>\nSpecified amount of time, waiting for I/O, blocking on a mutex, etc.</p>\n<p>Going to sleep - steps:<br>\n· Task marks itself as sleeping<br>\n· Task enters a waitqueue<br>\n· Task leaves the rbtree of runnable processes<br>\n· Task calls <code>schedule()</code>  to select a new process to run</p>\n<p>Two states associated with sleeping:<br>\n<code>TASK INTERRUPTIBLE</code>: Will be awaken on signal reception<br>\n<code>TASK UNINTERRUPTIBLE</code>: Ignore signals</p>\n<p>Wait queue: List of processes waiting for an event to occur.</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">wait_queue_head</span> <span class=\"title\">wait_queue_head_t</span></span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">wait_queue_head</span> &#123;</span></span><br><span class=\"line\">  <span class=\"keyword\">spinlock_t</span> lock;</span><br><span class=\"line\">  <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">list_head</span> <span class=\"title\">task_list</span>;</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>Some simple interfaces used to go to sleep have races: It is possible to go to sleep <em>after</em> the event we are waiting for has occurred.</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* We assume the wait queue we want to wait on is accessible through a variable q */</span> </span><br><span class=\"line\">DEFINE_WAIT(wait); <span class=\"comment\">/* initialize a wait queue entry */</span></span><br><span class=\"line\">add_wait_queue(q, &amp;wait);</span><br><span class=\"line\"><span class=\"keyword\">while</span> (!condition) &#123; </span><br><span class=\"line\">  <span class=\"comment\">/* event weare waiting for */</span></span><br><span class=\"line\">  prepare_to_wait(&amp;q, &amp;wait, TASK_INTERRUPTIBLE);</span><br><span class=\"line\">  <span class=\"keyword\">if</span>(signal_pending(current))</span><br><span class=\"line\">   <span class=\"comment\">/* handle signal */</span></span><br><span class=\"line\">    schedule();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">finish_wait(&amp;q, &amp;wait);</span><br></pre></td></tr></table></figure>\n<p><strong>Steps for waiting on a waitqueue:</strong><br>\n· Create a wait queue entry (<code>DEFINE_WAIT()</code>).<br>\n· Add the calling process to a wait queue (<code>add_wait_queue()</code>).<br>\n· Call <code>prepare_to_wait()</code> to change the  process state.<br>\n· If the state is <code>TASK_INTERRUPTIBLE</code>, a signal can wake the task up <em>→</em> need to check.<br>\n· Executes another process with <code>schedule()</code>.<br>\n· When the task awakens, check the condition.<br>\n· When the condition is true, get out of the wait queue and set the state accordingly using <code>finish_wait()</code>.</p>\n<p><strong>Waking up</strong> is taken care of by <code>wake_up()</code>. Awakes all the processes on a wait queue by default.</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> wake_up(x) wake_up(x, TASK_NORMAL, 1 , NULL)</span></span><br><span class=\"line\"> <span class=\"comment\">/* type of x i s wait_queue_head_t */</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">wake_up_common</span><span class=\"params\">(<span class=\"keyword\">wait_queue_head_t</span> *q, </span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                           <span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> mode, <span class=\"keyword\">int</span> nr_exclusive, </span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                           <span class=\"keyword\">int</span> wake_flags, <span class=\"keyword\">void</span> *key)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">wait_queue_t</span> *curr, *next;</span><br><span class=\"line\">  </span><br><span class=\"line\">  list_for_each_entry_safe(curr, next, &amp;q-&gt;task_list, task_list) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">unsigned</span> flags = curr-&gt;flags;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (curr-&gt;func(curr, mode, wake_flags, key) &amp;&amp; (flags &amp; WQ_FLAG_EXCLUSIVE) &amp;&amp; !--nr_exclusive)</span><br><span class=\"line\">      <span class=\"keyword\">break</span>; <span class=\"comment\">/* wakes up only a subset of ’exclusive’ tasks */</span> </span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>Exclusive tasks are added through <code>prepare_to_wait_exclusive()</code>.</p>\n<p>A wait queue entry contains a pointer to a wake-up function : <code>include/linux/wait.h</code>.</p>\n<p><code>default_wake_function()</code>  calls <code>try_to_wake up()</code> -&gt; which calls ttwu_queue() -&gt; which calls <code>ttwu_do_activate()</code>  (put the task back on runqueue)  -&gt; which calls <code>ttwu_do_wakeup</code> which sets the task state to TASK RUNNING.</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">typedefstruct wait_queue <span class=\"keyword\">wait_queue_t</span>;</span><br><span class=\"line\">typedefint (*<span class=\"keyword\">wait_queue_func_t</span>)(<span class=\"keyword\">wait_queue_t</span> *wait, <span class=\"keyword\">unsigned</span> mode, <span class=\"keyword\">int</span> flags, <span class=\"keyword\">void</span> *key); </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">default_wake_function</span><span class=\"params\">(*<span class=\"keyword\">wait_queue_func_t</span>)</span><span class=\"params\">(<span class=\"keyword\">wait_queue_t</span> *wait, <span class=\"keyword\">unsigned</span> mode,<span class=\"keyword\">int</span> flags, <span class=\"keyword\">void</span> *key)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* ... */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">wait_queue</span> &#123;</span> </span><br><span class=\"line\">  <span class=\"comment\">/* ... */</span></span><br><span class=\"line\">  <span class=\"keyword\">wait_queue_func_t</span> func;</span><br><span class=\"line\">  <span class=\"comment\">/* ... */</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>· Per-CPU runqueues (rbtrees): To avoid costly accesses to shared data structures.</p>\n<p>· Runqueues must be kept balanced.<br>\nEx: dual-core with one large runqueue of high-priority processes, and a small one with low-priority processes. High-priority processes get less CPU time than low-priority ones.<br>\nA load balancing algorithm is run periodically. Balances the queues based on processes priorities and their actual CPU usage.</p>\n<h2 id=\"part.4-preemptions-and-context-switching\">Part.4 Preemptions and context switching<a title=\"#part.4-preemptions-and-context-switching\" href=\"#part.4-preemptions-and-context-switching\"></a></h2>\n<h3 id=\"context-switch\">Context switch<a title=\"#context-switch\" href=\"#context-switch\"></a></h3>\n<p>A <strong>context switch</strong> is the action of swapping the process currently running on the CPU to another one which is performed by the <code>context_switch()</code> function. The function is called by <code>schedule()</code>.</p>\n<p>1.Switch the address space through <code>switch_mm()</code>.<br>\n2.Switch the CPU state (registers) through <code>switch_to()</code>.</p>\n<p>A task can voluntarily relinquish the CPU by calling <code>schedule()</code>.</p>\n<p>The kernel check if there is a need of preemption based on the <code>need_resched</code> flag.</p>\n<p><code>need_resched</code> is set by:<br>\n1.<code>scheduler_tick()</code> when the currently running task needs to be preempted.<br>\n2.<code>try_to_wake_up()</code> when a process with higher priority wakes up.</p>\n<p><code>need_resched</code> flag is checked:<br>\nUpon returning to user space (from a syscall or an interrupt).<br>\nUpon returning from an interrupt.</p>\n<p>If the flag is set, <code>schedule()</code> is called.</p>\n<p>User preemption happens:<br>\nWhen return to user space from a syscall.<br>\nWhen return to user space from an interrupt.<br>\nWith Linux,  the kernel is also subject to preemption.</p>\n<h3 id=\"kernel-preemption\">Kernel preemption<a title=\"#kernel-preemption\" href=\"#kernel-preemption\"></a></h3>\n<p>In linux, a task can be preempted in the kernel as long as execution is in a safe state (Not holding any lock (kernel is SMP safe)).</p>\n<p>If <code>need_resched &amp;&amp; !preempt_count</code> <em>→</em> safe to preempt. <code>preempt_count</code> in the <code>thread_info</code> structure (Indicates the current lock depth).</p>\n<p>Checked when returning to the kernel from interrupt. <code>need_resched</code> is also checked when releasing a lock and preempt count is 0.</p>\n<p>Kernel code can also call directly <code>schedule()</code>.</p>\n<p>Kernel preemption can occur :<br>\n1.On return from interrupt to kernel space.<br>\n2.When kernel code becomes preemptible again.<br>\n3.If a task explicitly calls <code>schedule()</code> from the kernel.<br>\n4.If a task in the kernel blocks (ex: mutex, result in a call to <code>schedule()</code>)</p>\n<h3 id=\"real-time-scheduling-policies\">Real-time scheduling policies<a title=\"#real-time-scheduling-policies\" href=\"#real-time-scheduling-policies\"></a></h3>\n<p>Real-time task of any scheduling class will always run before non-real time ones (<code>CFS</code>, <code>SCHED_OTHER</code>). <code>schedule()</code> → <code>pick next task()</code> → <code>for_each_class()</code>.</p>\n<p>Two classical RT scheduling policies (<code>kernel/sched/rt.c</code>):<br>\n· <code>SCHED_FIFO</code>:<br>\nTasks run until it blocks/yield, only a higher priority RT task can preempt it.<br>\nRound-robin for tasks of same priority.<br>\n· <code>SCHED_RR</code>:<br>\nSame as <code>SCHED_FIFO</code>, but with a fixed timeslice.</p>\n<h3 id=\"scheduling-related-syscalls\">Scheduling-related syscalls<a title=\"#scheduling-related-syscalls\" href=\"#scheduling-related-syscalls\"></a></h3>\n<p>See more details from <a href=\"https://www.informit.com/articles/article.aspx?p=101760&amp;seqNum=5\" target=\"_blank\">here</a>.</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> _GNU_SOURCE</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdio.h&gt; </span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdlib.h&gt; </span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;sys/types.h&gt; </span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;unistd.h&gt; </span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;sched.h&gt; #include &lt;assert.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">handle_err</span><span class=\"params\">(<span class=\"keyword\">int</span> ret, <span class=\"keyword\">char</span> *func)</span> </span>&#123; </span><br><span class=\"line\">  perror(func);</span><br><span class=\"line\">\t<span class=\"built_in\">exit</span>(EXIT_FAILURE);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">pid_t</span> pid = <span class=\"number\">-1</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> ret = <span class=\"number\">-1</span>;</span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">sched_param</span> <span class=\"title\">sp</span>;</span></span><br><span class=\"line\">  <span class=\"keyword\">int</span> max_rr_prio, min_rr_prio = <span class=\"number\">-42</span>; </span><br><span class=\"line\">  <span class=\"keyword\">size_t</span> cpu_set_size = <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"keyword\">cpu_set_t</span> cs;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"comment\">/* GetthePIDofthecallingprocess */</span></span><br><span class=\"line\">  pid = getpid();</span><br><span class=\"line\">\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;Mypidis:%d¥n&quot;</span>, pid); </span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"comment\">/* Gettheschedulingclass */</span></span><br><span class=\"line\">\tret = sched_getscheduler(pid); </span><br><span class=\"line\">  <span class=\"keyword\">if</span>(ret == <span class=\"number\">-1</span>) handle_err(ret,<span class=\"string\">&quot;sched_getscheduler&quot;</span>); </span><br><span class=\"line\">  <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;sched_getschedulerreturns:&quot;</span><span class=\"string\">&quot;%d¥n&quot;</span>, ret);</span><br><span class=\"line\">  assert(ret == SCHED_OTHER);</span><br><span class=\"line\">  </span><br><span class=\"line\">\t<span class=\"comment\">/* Getthepriority(nice/RT) */</span></span><br><span class=\"line\">\tsp.sched_priority = <span class=\"number\">-1</span>;</span><br><span class=\"line\">\tret = sched_getparam(pid, &amp;sp);</span><br><span class=\"line\">  <span class=\"keyword\">if</span>(ret == <span class=\"number\">-1</span>) handle_err(ret,<span class=\"string\">&quot;sched_getparam&quot;</span>); </span><br><span class=\"line\">  <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;Mypriorityis:%d¥n&quot;</span>,</span><br><span class=\"line\">\tsp.sched_priority);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">/* Setthepriority(nicevalue) */</span></span><br><span class=\"line\">\tret = nice(<span class=\"number\">1</span>); </span><br><span class=\"line\">  <span class=\"keyword\">if</span>(ret == <span class=\"number\">-1</span>)\thandle_err(ret,<span class=\"string\">&quot;nice&quot;</span>);</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"comment\">/* Getthepriority */</span></span><br><span class=\"line\">\tsp.sched_priority = <span class=\"number\">-1</span>;</span><br><span class=\"line\">\tret = sched_getparam(pid, &amp;sp); </span><br><span class=\"line\">  <span class=\"keyword\">if</span>(ret == <span class=\"number\">-1</span>) handle_err(ret,<span class=\"string\">&quot;sched_getparam&quot;</span>);</span><br><span class=\"line\">  <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;Mypriorityis:%d¥n&quot;</span>,</span><br><span class=\"line\">\tsp.sched_priority);</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"comment\">/* SwtichscheduleingclasstoFIFOandthepriorityto99 */</span></span><br><span class=\"line\">  sp.sched_priority = <span class=\"number\">99</span>;</span><br><span class=\"line\">\tret = sched_setscheduler(pid, SCHED_FIFO, &amp;sp); </span><br><span class=\"line\">  <span class=\"keyword\">if</span>(ret == <span class=\"number\">-1</span>) handle_err(ret,<span class=\"string\">&quot;sched_setscheduler&quot;</span>);</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"comment\">/* Gettheschedulingclass */</span></span><br><span class=\"line\">\tret = sched_getscheduler(pid); </span><br><span class=\"line\">  <span class=\"keyword\">if</span>(ret == <span class=\"number\">-1</span>) handle_err(ret,<span class=\"string\">&quot;sched_getscheduler&quot;</span>); </span><br><span class=\"line\">  <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;sched_getschedulerreturns:&quot;</span><span class=\"string\">&quot;%d¥n&quot;</span>, ret);</span><br><span class=\"line\">  assert(ret == SCHED_FIFO);</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"comment\">/* Getthepriority */</span></span><br><span class=\"line\">\tsp.sched_priority = <span class=\"number\">-1</span>;</span><br><span class=\"line\">\tret = sched_getparam(pid, &amp;sp); </span><br><span class=\"line\">  <span class=\"keyword\">if</span>(ret == <span class=\"number\">-1</span>) handle_err(ret,<span class=\"string\">&quot;sched_getparam&quot;</span>);</span><br><span class=\"line\">  <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;Mypriorityis:%d¥n&quot;</span>,</span><br><span class=\"line\">         sp.sched_priority);</span><br><span class=\"line\">  </span><br><span class=\"line\">\t<span class=\"comment\">/* SettheRTpriority */</span></span><br><span class=\"line\">\tsp.sched_priority = <span class=\"number\">42</span>;</span><br><span class=\"line\">\tret = sched_setparam(pid, &amp;sp);</span><br><span class=\"line\">  <span class=\"keyword\">if</span>(ret == <span class=\"number\">-1</span>) handle_err(ret,<span class=\"string\">&quot;sched_setparam&quot;</span>);</span><br><span class=\"line\">  <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;Prioritychangedto%d¥n&quot;</span>,</span><br><span class=\"line\">\tsp.sched_priority);</span><br><span class=\"line\">\t</span><br><span class=\"line\">  <span class=\"comment\">/* Getthepriority */</span></span><br><span class=\"line\">\tsp.sched_priority = <span class=\"number\">-1</span>;</span><br><span class=\"line\">\tret = sched_getparam(pid, &amp;sp);</span><br><span class=\"line\">  <span class=\"keyword\">if</span>(ret == <span class=\"number\">-1</span>) handle_err(ret,<span class=\"string\">&quot;sched_getparam&quot;</span>);</span><br><span class=\"line\">  <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;Mypriorityis:%d¥n&quot;</span>,</span><br><span class=\"line\">\tsp.sched_priority);</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"comment\">/* GetthemaxpriorityvalueforSCHED_RR */</span></span><br><span class=\"line\">\tmax_rr_prio = sched_get_priority_max(SCHED_RR); </span><br><span class=\"line\">  <span class=\"keyword\">if</span>(max_rr_prio == <span class=\"number\">-1</span>)</span><br><span class=\"line\">    handle_err(max_rr_prio,<span class=\"string\">&quot;sched_get_priority_max&quot;</span>); </span><br><span class=\"line\">  <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;MaxRRprio:%d¥n&quot;</span>, max_rr_prio);</span><br><span class=\"line\">  </span><br><span class=\"line\">\t<span class=\"comment\">/* GettheminpriorityvalueforSCHED_RR */</span></span><br><span class=\"line\">\tmin_rr_prio = sched_get_priority_min(SCHED_RR); </span><br><span class=\"line\">  <span class=\"keyword\">if</span>(min_rr_prio == <span class=\"number\">-1</span>)</span><br><span class=\"line\">    handle_err(min_rr_prio,<span class=\"string\">&quot;sched_get_priority_min&quot;</span>);</span><br><span class=\"line\">  <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;MinRRprio:%d¥n&quot;</span>, min_rr_prio);</span><br><span class=\"line\">  cpu_set_size = <span class=\"keyword\">sizeof</span>(<span class=\"keyword\">cpu_set_t</span>);</span><br><span class=\"line\">  CPU_ZERO(&amp;cs); <span class=\"comment\">/* clearthemask */</span></span><br><span class=\"line\">  CPU_SET(<span class=\"number\">0</span>, &amp;cs);</span><br><span class=\"line\">  CPU_SET(<span class=\"number\">1</span>, &amp;cs);</span><br><span class=\"line\">  <span class=\"comment\">/* SettheaffinitytoCPUs0and1only */</span></span><br><span class=\"line\">\tret = sched_setaffinity(pid, cpu_set_size, &amp;cs);</span><br><span class=\"line\">  <span class=\"keyword\">if</span>(ret == <span class=\"number\">-1</span>) handle_err(ret,<span class=\"string\">&quot;sched_setaffinity&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">/* GettheCPUaffinity */</span></span><br><span class=\"line\">\tCPU_ZERO(&amp;cs);</span><br><span class=\"line\">\tret = sched_getaffinity(pid,cpu_set_size, &amp;cs);</span><br><span class=\"line\">  <span class=\"keyword\">if</span>(ret == <span class=\"number\">-1</span>) handle_err(ret, <span class=\"string\">&quot;sched_getaffinity&quot;</span>);</span><br><span class=\"line\">  assert(CPU_ISSET(<span class=\"number\">0</span>, &amp;cs));</span><br><span class=\"line\">  assert(CPU_ISSET(<span class=\"number\">1</span>, &amp;cs));</span><br><span class=\"line\">  <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;AffinitytestsOK¥n&quot;</span>);</span><br><span class=\"line\">  <span class=\"comment\">/* YieldtheCPU */</span></span><br><span class=\"line\">  ret = sched_yield(); </span><br><span class=\"line\">  <span class=\"keyword\">if</span>(ret == <span class=\"number\">-1</span>) handle_err(ret, <span class=\"string\">&quot;sched_yield&quot;</span>);</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> EXIT_SUCCESS;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","next":{"title":"Memory Management","link":"2020/20201025-Memory-Management"},"plink":"https://oreodu.github.io/2020/20201026-Process-Scheduling/","toc":[{"id":"process-scheduling","title":"Process Scheduling","index":"1","children":[{"id":"part.1-general-information","title":"Part.1 General information","index":"1.1"},{"id":"part.2-linux-completely-fair-scheduler-(cfs)","title":"Part.2 Linux Completely Fair Scheduler (CFS)","index":"1.2"},{"id":"part.3-cfs-implementation","title":"Part.3 CFS implementation","index":"1.3"},{"id":"part.4-preemptions-and-context-switching","title":"Part.4 Preemptions and context switching","index":"1.4"}]}],"reward":true,"copyright":{"author":"Oreo Du","link":"<a href=\"https://oreodu.github.io/2020/20201026-Process-Scheduling/\" title=\"Process Scheduling\">https://oreodu.github.io/2020/20201026-Process-Scheduling/</a>","license":"Attribution-NonCommercial-NoDerivatives 4.0 International (<a href=\"https://creativecommons.org/licenses/by-nc-sa/4.0/\" rel=\"external nofollow noopener\" target=\"_blank\">CC BY-NC-ND 4.0</a>)"}}