{"title":"Interrupts","date":"2020-11-09T12:05:00.000Z","date_formatted":{"ll":"Nov 9, 2020","L":"11/09/2020","MM-DD":"11-09"},"link":"2020/20201109-Interrupts","comments":true,"tags":["Operating System"],"categories":["Linux","Operating System"],"updated":"2020-11-09T14:03:40.312Z","content":"<h1 id=\"interrupts\">Interrupts<a title=\"#interrupts\" href=\"#interrupts\"></a></h1>\n<h2 id=\"part.1-general-information\">Part.1 General information<a title=\"#part.1-general-information\" href=\"#part.1-general-information\"></a></h2>\n<p>Because the device is slow compared to the CPU, we can have hardware devices signal the CPU that they are ready.</p>\n<img src=\"https://tva1.sinaimg.cn/large/0081Kckwgy1gkj75qsgrcj313y08uacn.jpg\" alt=\"Screen Shot 2020-11-09 at 20.32.05\" style=\"zoom: 33%;\">\n<p><strong>Exceptions</strong> are interrupt issued by the CPU executing some code which happen synchronously with respect to the CPU clock. (Software interrupts, as opposed to hardware devices.) They are also managed by the kernel the same way as hardware interrupts.<br>\nProgram faults: divide-by-zero, page fault, general protection fault, etc.<br>\nVoluntary exceptions: <code>INT</code> assembly instruction, for example for syscall invocation</p>\n<p>Interrupts are electrical signals multiplexed by the interrupt controller. They can be received in a completely non-deterministic way. The kernel/user space can be interrupted at (nearly) any time to process an interrupt.</p>\n<p><strong>Device identifier</strong>: interrupt line or Interrupt ReQuest (IRQ)<br>\n<strong>Function executed by the CPU</strong>: interrupt handler or Interrupt Service Routine (ISR)</p>\n<p>The interrupt handlers (ISR) are kernel C fuctions associated to interrupt lines.<br>\nSpecific prototype, run in interrupt context, opposite to process context (system call).<br>\nAlso called atomic context as one cannot sleep in an ISR. It is not a schedulable entity.</p>\n<p>Managing an interrupt involves two high-level steps:<br>\n· Acknowledging the reception (mandatory, fast)<br>\n· Potentially performing additional work (possibly slow)</p>\n<p>Processing an interrupt is broken down between:<br>\n· Top-half: time-critical operations (ex: ack), run immediately upon reception.<br>\n· Bottom-half: less critical/time-consuming work, run later with other interrupts enabled</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* (block 1) */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">omap_kp_probe</span><span class=\"params\">(struct platform_device *pdev)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">/*...*/</span></span><br><span class=\"line\">  omap_kp-&gt;irq = platform_get_irq(pdev, <span class=\"number\">0</span>); </span><br><span class=\"line\">  <span class=\"keyword\">if</span>(omap_kp-&gt;irq &gt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(request_irq(omap_kp-&gt;irq, omap_kp_interrupt, <span class=\"number\">0</span>,<span class=\"string\">&quot;omap-keypad&quot;</span>, omap_kp) &lt; <span class=\"number\">0</span>) </span><br><span class=\"line\">      <span class=\"keyword\">goto</span> err4;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* (block 2) */</span></span><br><span class=\"line\"><span class=\"comment\">/* Tophalf: interrupt handler (ISR) */</span> </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">irqreturn_t</span> <span class=\"title\">omap_kp_interrupt</span><span class=\"params\">(<span class=\"keyword\">int</span> irq, <span class=\"keyword\">void</span> *dev_id)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">/* disable keyboard interrupt */</span> </span><br><span class=\"line\">  omap_writew(<span class=\"number\">1</span>, <span class=\"comment\">/* . . . */</span>);</span><br><span class=\"line\">  tasklet_schedule(&amp;kp_tasklet);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> IRQ_HANDLED;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* (block 3) */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"title\">DECLARE_TASKLET_DISABLED</span><span class=\"params\">(kp_tasklet, omap_kp_tasklet, <span class=\"number\">0</span>)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* (block 4) */</span> </span><br><span class=\"line\"><span class=\"comment\">/* Bottom half */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">omap_kp_tasklet</span><span class=\"params\">(<span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> data)</span> </span>&#123;</span><br><span class=\"line\"> <span class=\"comment\">/* performs lot of work */</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"part.2-registering-&amp;-writing-an-interrupt-handler\">Part.2 Registering &amp; writing an interrupt handler<a title=\"#part.2-registering-&amp;-writing-an-interrupt-handler\" href=\"#part.2-registering-&amp;-writing-an-interrupt-handler\"></a></h2>\n<h3 id=\"interrupt-handler-registration:-request_irq()\">Interrupt handler registration: <code>request_irq()</code><a title=\"#interrupt-handler-registration:-request_irq()\" href=\"#interrupt-handler-registration:-request_irq()\"></a></h3>\n<p>Return 0 on success or standard error code and can sleep.</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* in the includes/linux/interrupt.h */</span></span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">inline</span> <span class=\"keyword\">int</span> must_check</span><br><span class=\"line\">request_irq(<span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> irq, <span class=\"keyword\">irq_handler_t</span> handler, <span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> flags,<span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *name, <span class=\"keyword\">void</span> *dev)</span><br></pre></td></tr></table></figure>\n<p><code>irp</code>: interrupt number.<br>\n<code>handler</code>: function pointer to the actual handler.<br>\n<code>name</code>: String describing the associated device.<br>\n<code>dev</code>: unique value identifying a device among a set of devices sharing an interrupt line.<br>\n<code>flag</code>:  IRQF_DISABLED, IRQF_SAMPLE_RANDOM, IRQF_TIMER, IRQF_SHARED</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// registration</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">omap_kp_probe</span><span class=\"params\">(struct platform_device *pdev)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">/*...*/</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span>(request_irq(omap_kp-&gt;irq, omap_kp_interrupt, <span class=\"number\">0</span>, <span class=\"string\">&quot;omap-keypad&quot;</span>, omap_kp) &lt; <span class=\"number\">0</span>)</span><br><span class=\"line\">    <span class=\"keyword\">goto</span> err4;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// handler</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">irqreturn_t</span> <span class=\"title\">omap_kp_interrupt</span><span class=\"params\">(<span class=\"keyword\">int</span> irq, <span class=\"keyword\">void</span> *dev_id)</span> </span>&#123;</span><br><span class=\"line\">  omap_writew(<span class=\"number\">1</span>, OMAP1_MPUIO_BASE+ OMAP_MPUIO_KBD_MASKIT);</span><br><span class=\"line\">  tasklet_schedule(&amp;kp_tasklet);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> IRQ_HANDLED;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// free an irq </span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">omap_kp_remove</span><span class=\"params\">(struct platform_device *pdev)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">/*...*/</span></span><br><span class=\"line\">  free_irq(omap_kp-&gt;irq, omap_kp);</span><br><span class=\"line\">  <span class=\"comment\">/*...*/</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"inside-the-interrupt\">Inside the interrupt<a title=\"#inside-the-interrupt\" href=\"#inside-the-interrupt\"></a></h3>\n<p>prototype:</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">irqreturn_t</span> <span class=\"title\">handler_name</span><span class=\"params\">(<span class=\"keyword\">int</span> irq, <span class=\"keyword\">void</span> *dev)</span></span>;</span><br></pre></td></tr></table></figure>\n<p><code>dev</code> parameter:<br>\nMust be unique between handlers sharing an interrupt line. Set when registering the handler and can be accessed by the handler.</p>\n<p>Return value:<br>\n<code>IRQ_NONE</code>: the expected device was not the source of the interrupt.<br>\n<code>IRQ_HANDLED</code>: correct invocation</p>\n<h3 id=\"shared-handlers\">Shared handlers<a title=\"#shared-handlers\" href=\"#shared-handlers\"></a></h3>\n<p>On registration: <code>IRQ_SHARED</code> flag, <code>dev</code> must be unique (ex: a pointer to a data structure representing the device in question).</p>\n<p>Handler must be able to detect that the device actually generated the interrupt it is called from. When an interrupt occurs on a shared line, the kernel executes sequentially all the handlers sharing this line. Need hardware support at the device level and detection code in the handler.</p>\n<h2 id=\"part.3-interrupt-context\">Part.3 Interrupt context<a title=\"#part.3-interrupt-context\" href=\"#part.3-interrupt-context\"></a></h2>\n<p>The kernel can execute in Interrupt vs process context.<br>\n· In process context following a syscall/an exception<br>\n· In interrupt context upon a hardware interrupt reception</p>\n<p>In interrupt context, sleeping/blocking is not possible.<br>\n· The handler is not a schedulable entity (user/kernel thread)<br>\n· No kmalloc(x, GFP KERNEL). Use GFP ATOMIC<br>\n· No use of blocking synchronization primitives (ex: mutex). Use spinlocks</p>\n<p>Interrupt context is time-critical. Other code is interrupted.</p>\n<p>Interrupt handler stack: 1 dedicated stack per core for handlers (1 page)</p>\n<h2 id=\"part.4-interrupt-handling-internals-in-linux\">Part.4 Interrupt handling internals in Linux<a title=\"#part.4-interrupt-handling-internals-in-linux\" href=\"#part.4-interrupt-handling-internals-in-linux\"></a></h2>\n<h3 id=\"interrupt-processing-path\">Interrupt processing path<a title=\"#interrupt-processing-path\" href=\"#interrupt-processing-path\"></a></h3>\n<img src=\"https://tva1.sinaimg.cn/large/0081Kckwgy1gkj948fvn5j317g0hk0z6.jpg\" alt=\"Screen Shot 2020-11-09 at 21.39.58\" style=\"zoom:33%;\">\n<p>Specific entry point for each interrupt line.<br>\n· Saves the interrupt number and the current registers.<br>\n· call <code>do_IRQ()</code>.</p>\n<p>do IRQ():<br>\n· Acknowledge interrupt reception and disable the line.<br>\n· calls architecture specific functions.</p>\n<p>Call chain ends up by calling <code>_handle_irq_event_percpu()</code><br>\n· Re-enable interrupts on the line if IRQF DISABLED was not, specified during handler registration.<br>\n· Call the handler if the line is not shared.<br>\n· Otherwise iterate over all the handlers registered on that line.<br>\n· Disable interrupts on the line again if they were previously enabled.</p>\n<p><code>do_IRQ()</code> returns to entry point that call <code>ret_from_intr()</code>.<br>\n· Checks if reschedule is needed (need resched).<br>\n· Restore register values.</p>\n<h2 id=\"part.5-/proc/interrupts\">Part.5 /proc/interrupts<a title=\"#part.5-/proc/interrupts\" href=\"#part.5-/proc/interrupts\"></a></h2>\n<img src=\"https://tva1.sinaimg.cn/large/0081Kckwgy1gkj9dtp630j312c08eq53.jpg\" alt=\"Screen Shot 2020-11-09 at 21.49.17\" style=\"zoom:33%;\">\n<p>Columns:<br>\n· Interrupt line (not showed if no handler installed).<br>\n· Per-cpu occurrence count.<br>\n· Related interrupt controller name.<br>\n·  Edge/level (fasteoi): way the interrupt is triggered.<br>\n· Associated device name.</p>\n<h2 id=\"part.6-interrupt-control\">Part.6 Interrupt control<a title=\"#part.6-interrupt-control\" href=\"#part.6-interrupt-control\"></a></h2>\n<p>Kernel code sometimes needs to disable interrupts to ensure atomic execution of a section of code.</p>\n<p>The kernel provides an API to disable/enable interrupts:<br>\n· Disable interrupts for the current CPU.<br>\n· Mask an interrupt line for the entire machine.</p>\n<p>Note that disabling interrupts does not protect against concurrent access from other cores. Need locking, often used in conjunction with interrupts disabling.</p>\n<h3 id=\"disabling-interrupts-on-the-local-core\">Disabling interrupts on the local core<a title=\"#disabling-interrupts-on-the-local-core\" href=\"#disabling-interrupts-on-the-local-core\"></a></h3>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">local_irq_disable();</span><br><span class=\"line\"><span class=\"comment\">/*...*/</span></span><br><span class=\"line\">local_irq_enable();</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* Need to save the interrupts state in order not to disable them twice */</span></span><br><span class=\"line\"><span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> flags; </span><br><span class=\"line\">local_irq_save(flags);     <span class=\"comment\">/* disable interrupts if needed */</span></span><br><span class=\"line\">local_irq_restore(flags); <span class=\"comment\">/* restores interrupts to the previous state */</span> </span><br><span class=\"line\"><span class=\"comment\">/* flags is passed as value but both functions are actually macros */</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"disabling-/-enabling-a-specific-interrupt-line\">Disabling / enabling a specific interrupt line<a title=\"#disabling-/-enabling-a-specific-interrupt-line\" href=\"#disabling-/-enabling-a-specific-interrupt-line\"></a></h3>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">disable_irq</span><span class=\"params\">(<span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> irq)</span></span>;        <span class=\"comment\">/* Does not return until any currently running handler finishe */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">disable_irq_nosync</span><span class=\"params\">(<span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> irq)</span></span>; <span class=\"comment\">/* Do not wait for handler termination */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">enable_irq</span><span class=\"params\">(<span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> irq)</span></span>;      <span class=\"comment\">/* Enables interrupt line */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">synchronize_irq</span><span class=\"params\">(<span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> irq)</span></span>; <span class=\"comment\">/* Wait for a specific line handler to terminate before returning */</span></span><br></pre></td></tr></table></figure>\n<p>These enable/disable calls can nest. Must enable as much times as the previous disabling call number.<br>\nThese functions do not sleep. They can be called from interrupt context.</p>\n<h3 id=\"querying-the-status-of-the-interrupt-system\">Querying the status of the interrupt system<a title=\"#querying-the-status-of-the-interrupt-system\" href=\"#querying-the-status-of-the-interrupt-system\"></a></h3>\n<p><code>in_interrupt()</code> returns nonzero if the calling code is in interrupt context. Handler or bottom-half.<br>\n<code>in_irq()</code> returns nonzero only if in a handler.<br>\nTo check if the code is in process context: <code>!in_interrupt()</code>.</p>\n<p>Interrupts: <a href=\"http://www.mathcs.emory.edu/~jallen/Courses/355/Syllabus/6-io/0-External/interupt.html\">http://www.mathcs.emory.edu/~jallen/Courses/355/Syllabus/6-io/0-External/interupt.html</a><br>\nMore details on Linux interrupt management (v3.18): <a href=\"https://0xax.gitbooks.io/linux-insides/content/interrupts/\">https://0xax.gitbooks.io/linux-insides/content/interrupts/</a></p>\n","prev":{"title":"File Systems","link":"2020/20201118-File-Systems"},"next":{"title":"Device Drivers","link":"2020/20201109-Device-Drivers"},"plink":"https://oreodu.github.io/2020/20201109-Interrupts/","toc":[{"id":"interrupts","title":"Interrupts","index":"1","children":[{"id":"part.1-general-information","title":"Part.1 General information","index":"1.1"},{"id":"part.2-registering-&amp;-writing-an-interrupt-handler","title":"Part.2 Registering &amp; writing an interrupt handler","index":"1.2"},{"id":"part.3-interrupt-context","title":"Part.3 Interrupt context","index":"1.3"},{"id":"part.4-interrupt-handling-internals-in-linux","title":"Part.4 Interrupt handling internals in Linux","index":"1.4"},{"id":"part.5-/proc/interrupts","title":"Part.5 &#x2F;proc&#x2F;interrupts","index":"1.5"},{"id":"part.6-interrupt-control","title":"Part.6 Interrupt control","index":"1.6"}]}],"reward":true,"copyright":{"author":"Oreo Du","link":"<a href=\"https://oreodu.github.io/2020/20201109-Interrupts/\" title=\"Interrupts\">https://oreodu.github.io/2020/20201109-Interrupts/</a>","license":"Attribution-NonCommercial-NoDerivatives 4.0 International (<a href=\"https://creativecommons.org/licenses/by-nc-sa/4.0/\" rel=\"external nofollow noopener\" target=\"_blank\">CC BY-NC-ND 4.0</a>)"}}