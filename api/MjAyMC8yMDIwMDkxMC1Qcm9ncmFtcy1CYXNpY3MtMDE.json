{"title":"Programs Basics 01","date":"2020-09-10T05:07:00.000Z","date_formatted":{"ll":"Sep 10, 2020","L":"09/10/2020","MM-DD":"09-10"},"link":"2020/20200910-Programs-Basics-01","comments":true,"tags":["Basics"],"categories":["Programming"],"updated":"2020-10-03T18:16:16.604Z","content":"<h1 id=\"programs-basis-01\">Programs Basis 01<a title=\"#programs-basis-01\" href=\"#programs-basis-01\"></a></h1>\n<h3 id=\"overview\">Overview<a title=\"#overview\" href=\"#overview\"></a></h3>\n<p>(概略图)</p>\n<p><strong>· materials:</strong><br>\n· <i>Structure and Interpretation of Computer Programs</i> by Harold Abelson and Gerald Jay Sussman with Julie Sussman<br>\n· <a href=\"https://inst.eecs.berkeley.edu/~cs61a/su19/\" target=\"_blank\"><u>CS61A Summer 2019 at UCB</u></a><br>\n· Wikipedia</p>\n<p>Goals of Program Decomposition<br>\n1.Complexity Management<br>\n2.Reusability and abstraction</p>\n<h3 id=\"part.1-building-abstractions-with-procedures\">Part.1 Building Abstractions with Procedures<a title=\"#part.1-building-abstractions-with-procedures\" href=\"#part.1-building-abstractions-with-procedures\"></a></h3>\n<p>A <strong>function</strong> should solve one problem.</p>\n<p>A function should have the <strong>smallest</strong> <strong>number of parameters</strong> possible to solve its problem.</p>\n<p>A repeated sequence should be put in its own function.<br>\nAvoid repeating more than a couple lines of code.</p>\n<p>micro level - take one of those smaller functions and identify smaller problems within that that WONT necessarily identifying separate questions and reusing them</p>\n<h3 id=\"part.2-building-abstractions-with-data\">Part.2 Building Abstractions with Data<a title=\"#part.2-building-abstractions-with-data\" href=\"#part.2-building-abstractions-with-data\"></a></h3>\n<p>Data abstraction lets us manipulate compound values as units.</p>\n<p>Isolate two parts of any program that uses data:<br>\nHow data are represented (as parts)<br>\nHow data are manipulated (as units)<br>\nData abstraction: A methodology by which functions enforce an abstraction barrier between representation and use.</p>\n<p><strong>Abstraction Barriers:</strong></p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># constructor rational(n,d)  returns a rational number </span></span><br><span class=\"line\"><span class=\"comment\"># Selector numerator(x),     returns the numerator of x</span></span><br><span class=\"line\"><span class=\"comment\">#          denominator(x)    returns the denominator of x</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">mul_rational</span>(<span class=\"params\">x, y</span>):</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> rational(numer(x) * numer(y),</span><br><span class=\"line\">                    denom(x) * denom(y))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">add_rational</span>(<span class=\"params\">x, y</span>):</span></span><br><span class=\"line\">    nx, dx = numer(x), denom(x)</span><br><span class=\"line\">    ny, dy = numer(y), denom(y)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> rational(nx * dy + ny * dx, dx * dy)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">print_rational</span>(<span class=\"params\">x</span>):</span></span><br><span class=\"line\">    print(numer(x), <span class=\"string\">&#x27;/&#x27;</span>, denom(x))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">rationals_are_equal</span>(<span class=\"params\">x, y</span>):</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> numer(x) * denom(y) == numer(y) * denom(x)</span><br></pre></td></tr></table></figure>\n<div class=\"φcy\"><div class=\"φda\"><table><thead>\n<tr>\n<th>Parts of the program that…</th>\n<th>Treat rationals as…</th>\n<th>Using…</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Use rational numbers to perform computation</td>\n<td>whole data values</td>\n<td>add_rational, mul_rational, rationals_are_equal, print_rational</td>\n</tr>\n<tr>\n<td>Create rationals or implement rational operations</td>\n<td>numerators and denominators</td>\n<td>rational, numer, denom</td>\n</tr>\n<tr>\n<td>Implement selectors and constructor for rationals</td>\n<td>two-element lists</td>\n<td>list literals and element selection</td>\n</tr>\n</tbody>\n</table></div></div><ul>\n<li>\n<p>Decomposition</p>\n<p><strong>Program Decomposition</strong> is a process for breaking down large problems into logical sub-problems.</p>\n</li>\n</ul>\n<p>1.A well decomposed function is sometimes likened to a “black box”. The black box presents the simplest possible abstraction to describe what the output will be and hides the implementation. Its inner workings are not revealed.</p>\n<p>Data abstraction is an example of this. For constructors &amp; selectors, we don’t care about the body of the function. We only need to know what they take as input and their intended result.</p>\n<p>2.Decomposition is a divide and conquer strategy. （The process of breaking a large problem into more manageable sub-problems）</p>\n<p>From the outside, black boxes are simply defined in terms of their input and output, so they are easy to piece together.</p>\n<h3 id=\"part.3-program-paradigms\">Part.3 Program Paradigms<a title=\"#part.3-program-paradigms\" href=\"#part.3-program-paradigms\"></a></h3>\n<p>Program is the way approach writing program and program’s relationship to how it’s executed by  the interpreter or complier.</p>\n<p><strong>Imperative program</strong> contain explicit instructions to tell the computer <strong>how</strong> to accomplish something. The interpreter(which is designed to execute as optimally as possible) then executes those instructions.</p>\n<p><strong>Declarative programming</strong>, where we can just tell the computer <strong>what</strong> we want, instead of how we want it done. The interpreter then figures out how to accomplish that.</p>\n<h3 id=\"part.4-interpreting-computer-programs\">Part.4 Interpreting Computer Programs<a title=\"#part.4-interpreting-computer-programs\" href=\"#part.4-interpreting-computer-programs\"></a></h3>\n<p>**Ⅰ. Interpreter **</p>\n<p>There are two languages involved:<br>\nImplemented language: this is the language the user types in.<br>\nImplementation language: this is the language that interpreter is implemented in.<br>\n(Implemented Language is translated into the Implementation Language)</p>\n<p>The translation step in a couple forms:\t<br>\nCompiled (pre-translated) - translate all at once and run later. (C, C++…)<br>\nInterpreted (translated on-the-fly) - translate while the program is running. (Python, Java…)</p>\n<p>An interpreter does 3 things:<br>\nReads input from user in a specific programming language.<br>\nTranslates input to be computer readable and evaluates the result.<br>\nPrints the result for the user.</p>\n<img src=\"https://i.loli.net/2020/09/15/jOYo8UFcEsZbHhB.png\" alt=\"12\" style=\"zoom:80%;\">\n<p>​                                                    (from CS61A Summer 2019 at UCB)</p>\n<p><strong>1.Read</strong></p>\n<p>1.Lexical Analysis (Lexer):<br>\nTurning the input into a collection of <em>tokens</em>. A token: single input of the input string, e.g. literals, names, keywords, delimiters.</p>\n<p>2.Syntactic Analysis (Parser):<br>\nTurning tokens into a representation of the expression in the implementing language.</p>\n<p><strong>2.Evaluate</strong></p>\n<p>Rules for evaluating an expression depends on the expression’s type.</p>\n<p><strong>· Frames and Environments</strong></p>\n<p>When evaluating expressions, the current environment consists of the current frame, its parent frame, and all its ancestor frames until the Global Frame.</p>\n<p>Frames are represented in our interpreter as instances of the <strong>Frame</strong> class. Each frame instance has two instance attributes:<br>\n<strong>bindings</strong>: a dictionary that binds strings to values.<br>\n<strong>parent</strong>: the parent frame, another <strong>Frame</strong> instance.</p>\n<p>The evaluator needs to know the current environment, given as a single <strong>Frame</strong> instance, in order to look up names in expressions.</p>\n<p><a href=\"https://oreodu.github.io/2020/09/15/20200915-Scheme-Language-Basis/\" target=\"_blank\"><u>See the evaluating process of Scheme here</u></a></p>\n<h3 id=\"part.3-modularity,-objects,-and-state\">Part.3 Modularity, Objects, and State<a title=\"#part.3-modularity,-objects,-and-state\" href=\"#part.3-modularity,-objects,-and-state\"></a></h3>\n<h3 id=\"part.4-meta-linguistic-abstraction\">Part.4 Meta-Linguistic Abstraction<a title=\"#part.4-meta-linguistic-abstraction\" href=\"#part.4-meta-linguistic-abstraction\"></a></h3>\n<h3 id=\"part.5-register-machine'-model-of-control\">Part.5 Register Machine’ Model of Control<a title=\"#part.5-register-machine'-model-of-control\" href=\"#part.5-register-machine'-model-of-control\"></a></h3>\n","prev":{"title":"Scheme Basics","link":"2020/20200915-Scheme-Basics"},"next":{"title":"Python Basis 03","link":"2020/20200908-Python-Basics-03"},"plink":"https://oreodu.github.io/2020/20200910-Programs-Basics-01/","toc":[{"id":"programs-basis-01","title":"Programs Basis 01","index":"1"}],"reward":true,"copyright":{"author":"Oreo Du","link":"<a href=\"https://oreodu.github.io/2020/20200910-Programs-Basics-01/\" title=\"Programs Basics 01\">https://oreodu.github.io/2020/20200910-Programs-Basics-01/</a>","license":"Attribution-NonCommercial-NoDerivatives 4.0 International (<a href=\"https://creativecommons.org/licenses/by-nc-sa/4.0/\" rel=\"external nofollow noopener\" target=\"_blank\">CC BY-NC-ND 4.0</a>)"}}