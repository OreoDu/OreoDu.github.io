{"title":"Scheme Basics","date":"2020-09-15T02:42:00.000Z","date_formatted":{"ll":"Sep 15, 2020","L":"09/15/2020","MM-DD":"09-15"},"link":"2020/20200915-Scheme-Basics","comments":true,"tags":["Scheme"],"categories":["Programming"],"updated":"2020-10-03T18:16:21.647Z","content":"<h1 id=\"scheme-basics\">Scheme Basics<a title=\"#scheme-basics\" href=\"#scheme-basics\"></a></h1>\n<h3 id=\"overview\">Overview<a title=\"#overview\" href=\"#overview\"></a></h3>\n<p>(概略图)</p>\n<p><strong>· materials:</strong><br>\n· <a href=\"https://inst.eecs.berkeley.edu/~cs61a/su19/\" target=\"_blank\"><u>CS61A Summer 2019 at UCB</u></a></p>\n<h3 id=\"part.1-scheme-values\">Part.1 Scheme values<a title=\"#part.1-scheme-values\" href=\"#part.1-scheme-values\"></a></h3>\n<p><strong>Ⅰ. Atoms:</strong> primitive values that cannot be broken up into smaller parts</p>\n<ul>\n<li>numbers: <code>10, -6, 5.7, 4021</code></li>\n<li>booleans: <code> #t, #f</code></li>\n<li>symbols: <code>hello, world</code></li>\n</ul>\n<p><strong>Ⅱ. Pairs and Lists:</strong>  a sequence of zero or more values<br>\n<code>(1 2 3 4 5 6)</code><br>\nThe pair is the basic compound value in Scheme. Lists in Scheme are created using pairs. They’re linked lists.</p>\n<p>1.Pair<br>\nPairs are created using the <code>cons</code> expression in Scheme<br>\n<code>car</code> selects the first element in a pair<br>\n<code>cdr</code> selects the second element in a pair<br>\nThe second element of a pair must be another pair, or <code>nil</code></p>\n<figure class=\"highlight scheme\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">scm&gt; (define x (cons 1 (cons 3 nil))</span><br><span class=\"line\">x</span><br><span class=\"line\">scm&gt; x</span><br><span class=\"line\">(<span class=\"name\">1</span> <span class=\"number\">3</span>)</span><br><span class=\"line\">scm&gt; (car x)</span><br><span class=\"line\"><span class=\"number\">1</span></span><br><span class=\"line\">scm&gt; (cdr x)</span><br><span class=\"line\">(<span class=\"name\">3</span>)</span><br></pre></td></tr></table></figure>\n<p>2.List<br>\nThe list constructor takes in any number of elements and puts each element as a single element in a list.</p>\n<figure class=\"highlight scheme\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">scm&gt; (list 1 2 3)</span><br><span class=\"line\">(<span class=\"name\">1</span> <span class=\"number\">2</span> <span class=\"number\">3</span>)</span><br><span class=\"line\">scm&gt; (list 0 (list 1 2 3))</span><br><span class=\"line\">(<span class=\"name\">0</span> (<span class=\"name\">1</span> <span class=\"number\">2</span> <span class=\"number\">3</span>))</span><br></pre></td></tr></table></figure>\n<p>The quote special form takes in a single argument and returns an unevaluated version of the argument. Quoting a symbol gives a symbol back. Quoting the representation of a list gives a list.</p>\n<figure class=\"highlight scheme\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">scm&gt; ‘(0 (1 2 3))</span><br><span class=\"line\">(<span class=\"name\">0</span> (<span class=\"name\">1</span> <span class=\"number\">2</span> <span class=\"number\">3</span>))</span><br></pre></td></tr></table></figure>\n<p><strong>cons</strong>: When you want to add an element on to the start of a list.<br>\nEx: add an element to the start of the list returned by a recursive call<br>\n<strong>list:</strong>  When you have multiple elements you want to put into a list all at once.<br>\nEx: want to create a two element list containing x and y<br>\n<strong>quote:</strong>  When you know the exact structure of the list and the values it contains.<br>\nEx: create a list to pass in as an argument in an interactive session</p>\n<p><strong>Ⅲ. Procedures:</strong>  function objects, either built-in or user-defined<br>\n<code>(lambda (x) (* x x))</code></p>\n<h3 id=\"part.2-scheme-expressions\">Part.2 Scheme expressions<a title=\"#part.2-scheme-expressions\" href=\"#part.2-scheme-expressions\"></a></h3>\n<p>Scheme programs consist only of expressions, all of which can be categorized into either atomic expressions or combinations.<br>\n<strong>Ⅰ. Atomic expressions</strong><br>\n<em>Self-evaluating:</em> numbers, booleans<br>\n<code>3, 5.5, -10, #t, #f</code><br>\n<em>Symbols:</em> names bound to values<br>\n<code>+, modulo, list, x, foo, hello-world</code></p>\n<p><strong>Ⅱ. Combinations</strong></p>\n<p><code>(&lt;operator&gt; &lt;operand1&gt; &lt;operand2&gt; …)</code><br>\nA combination is either a <strong>call expression</strong> or a <strong>special form expression</strong>.<br>\n<code>(+ 2 3)</code>, <code>(abs (/ 20 5))</code>, <code>(&lt; 4 8.5)</code><br>\n<code>(define x 5)</code>, <code>(if #t 10 20)</code>, <code>(lambda (x) (* x x))</code></p>\n<p><strong>· Call expressions</strong><br>\nA call expression applies a procedure to some arguments.</p>\n<p>Evaluate call expressions:<br>\nStep 1.  Evaluate the operator to get a procedure.<br>\nStep 2.  Evaluate all operands left to right to get the arguments.<br>\nStep 3. Apply the procedure to the arguments.</p>\n<p><strong>· Special form expressions</strong><br>\n1.Assigning values to names<br>\nThe define special form assigns a value to a name:<br>\n<code>(define &lt;name&gt; &lt;expr&gt;)</code><br>\nEvaluate:<br>\nStep 1. Evaluate the given expression.<br>\nStep 2. Bind the resulting value to the given name in the current frame.<br>\nStep 3. Return the name as a symbol.</p>\n<p>2.Defining functions with names<br>\nThe second version of define is a shorthand for creating a function with a name:<br>\n<code>(define (&lt;name&gt; &lt;param1&gt; &lt;param2&gt; …) &lt;body&gt;)</code><br>\nEvaluate:<br>\nStep 1. Create a lambda procedure with the given parameters and body.<br>\nStep 2. Bind it to the given name in the current frame.<br>\nStep 3. Return the function name as a symbol.<br>\n(If there is more than one expression in the body, the function returns the value of the last expression.)</p>\n<p>3.Creating functions<br>\nThe lambda special form returns a lambda procedure.<br>\n<code>(lambda (&lt;param1&gt; &lt;param2&gt; …) &lt;body&gt;)</code><br>\nEvaluate:<br>\nStep 1. Create a lambda procedure with the given parameters and body.<br>\nStep 2. Return the lambda procedure.</p>\n<p>4.Control flow<br>\nThe if special form allows us to evaluate an expression based on a condition:<br>\n<code>(if &lt;predicate&gt; &lt;if-true&gt; &lt;if-false&gt;)</code><br>\nEvaluate:<br>\nStep 1. Evaluate the <code>&lt;predicate&gt;</code>.<br>\nStep 2. If <code>&lt;predicate&gt;</code> evaluates to anything but #f, evaluate <code>&lt;if-true&gt;</code> and return the value. Otherwise, evaluate <code>&lt;if-false&gt;</code> if provided and return the value.</p>\n<p>The cond special form allows us to specify many conditions and consequences:<br>\n<code>(cond (&lt;pred1&gt; &lt;expr1&gt;) (&lt;pred2&gt; &lt;expr2&gt;) … (else &lt;else-expr&gt;))</code><br>\nEvaluate:<br>\nStep 1. Evaluate <code>&lt;pred1&gt;</code>, <code>&lt;pred2&gt;</code>, etc. until one evaluates to a truth-y value.<br>\nStep 2. Evaluate and return the expression corresponding to the first truth-y predicate. If no predicate evaluates to a truth-y value, evaluate and return <code>&lt;else-expr&gt;</code> if provided.</p>\n<p>5.Others<br>\n<code>(equal? e1 e2)</code> checks if e1 and e2 evaluate to equivalent values.<br>\n<code>(eq? e1 e2)</code> checks if e1 and e2 evaluate to identical values.</p>\n<h3 id=\"part.3-tail-recursion\">Part.3 Tail Recursion<a title=\"#part.3-tail-recursion\" href=\"#part.3-tail-recursion\"></a></h3>\n<p>We know that a function call will form a “call record” in memory, also known as a “call frame”, which saves information such as the call location and internal variables. If function B is called inside function A, then a call frame of B will be formed above the call frame of A. Wait until the end of B runs and return the result to A, then the call frame of B will disappear. If function B also calls function C, then there is a call frame of C, and so on. All call frames form a “call stack” (call stack).</p>\n<p><strong>· Tail Call</strong><br>\nIn computer science, a tail call is a subroutine call performed as the final action of a procedure.  If all recursive calls are in tail contexts, we say that function is  tail recursive. If a language supports tail call optimization, a tail recursive function will only ever open a constant number of frames.</p>\n<p>Tail calls can be implemented without adding a new stack frame to the call stack. Most of the frame of the current procedure is no longer needed, and can be replaced by the frame of the tail call, modified as appropriate (similar to overlay for processes, but for function calls). The program can then jump to the called subroutine.</p>\n<figure class=\"highlight scheme\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">; original recursive call</span></span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">define</span></span> (<span class=\"name\">fact</span> n)</span><br><span class=\"line\">  (<span class=\"name\"><span class=\"builtin-name\">if</span></span> (<span class=\"name\"><span class=\"builtin-name\">=</span></span> n <span class=\"number\">0</span>)</span><br><span class=\"line\">   <span class=\"number\">1</span></span><br><span class=\"line\">   (<span class=\"name\"><span class=\"builtin-name\">*</span></span> n (<span class=\"name\">fact</span> (<span class=\"name\"><span class=\"builtin-name\">-</span></span> n <span class=\"number\">1</span>)))))  </span><br><span class=\"line\"><span class=\"comment\">;We need to keep these frames open because the last step in the function is to multiply n with the result of the recursive call.</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">; tail call</span></span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">define</span></span> (<span class=\"name\">fact</span> n)</span><br><span class=\"line\">  (<span class=\"name\"><span class=\"builtin-name\">define</span></span> (<span class=\"name\">fact-tail</span> n result)</span><br><span class=\"line\">    (<span class=\"name\"><span class=\"builtin-name\">if</span></span> (<span class=\"name\"><span class=\"builtin-name\">&lt;=</span></span> n <span class=\"number\">1</span>)</span><br><span class=\"line\">        result</span><br><span class=\"line\">        (<span class=\"name\">fact-tail</span> (<span class=\"name\"><span class=\"builtin-name\">-</span></span> n <span class=\"number\">1</span>) (<span class=\"name\"><span class=\"builtin-name\">*</span></span> n result))))</span><br><span class=\"line\">  (<span class=\"name\">fact-tail</span> n <span class=\"number\">1</span>))</span><br></pre></td></tr></table></figure>\n<h3 id=\"part.5-macros\">Part.5 Macros<a title=\"#part.5-macros\" href=\"#part.5-macros\"></a></h3>\n<p>In Scheme,  expressions are lists (or primitive values) and quoting prevents evaluation of an expression. Calling <code>eval</code> on an unevaluated expression will evaluate that value. So it means that they’re also a form of data. And we can assign expressions to variables, pass expressions into functions, and create and return new expressions within functions.</p>\n<p><code>'</code> : takes in a single argument and returns an unevaluated version of the argument.<br>\n<code>list</code>: takes in any number of elements and puts each element as a single element in a list.</p>\n<figure class=\"highlight scheme\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">scm&gt; (list &#x27;quotient 10 2)</span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">quotient</span></span> <span class=\"number\">10</span> <span class=\"number\">2</span>)</span><br><span class=\"line\">scm&gt; (eval (list &#x27;quotient 10 2))</span><br><span class=\"line\"><span class=\"number\">5</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight scheme\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">define</span></span> (<span class=\"name\">dounle</span> expr)</span><br><span class=\"line\">        (<span class=\"name\"><span class=\"builtin-name\">begin</span></span> (<span class=\"name\"><span class=\"builtin-name\">eval</span></span> expr) (<span class=\"name\"><span class=\"builtin-name\">eval</span></span> expr))</span><br><span class=\"line\">scm&gt; (<span class=\"name\">double</span> &#x27;(print <span class=\"number\">2</span>))</span><br><span class=\"line\"><span class=\"number\">2</span></span><br><span class=\"line\"><span class=\"number\">2</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight scheme\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">define</span></span> (<span class=\"name\">dounle</span> expr)</span><br><span class=\"line\">        (<span class=\"name\"><span class=\"builtin-name\">list</span></span> <span class=\"symbol\">&#x27;begin</span> expr expr))</span><br><span class=\"line\">scm&gt; (eval  (double &#x27;(print 2)))</span><br><span class=\"line\"><span class=\"number\">2</span></span><br><span class=\"line\"><span class=\"number\">2</span></span><br></pre></td></tr></table></figure>\n<p><code>Macros</code> are a more convenient way to transform or create expressions. The <code>define-macro</code> special form will create a macro procedure. Macros take in and return expressions, which are then evaluated <strong>in place of</strong> the call to the macro.</p>\n<figure class=\"highlight scheme\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"name\">define-macro</span> (<span class=\"name\">twice</span> expr)</span><br><span class=\"line\">  (<span class=\"name\"><span class=\"builtin-name\">list</span></span> <span class=\"symbol\">&#x27;begin</span> expr expr))</span><br><span class=\"line\">scm&gt; (twice (print 2)) ;Equivalent to: (begin (print 2) (print 2))</span><br><span class=\"line\"><span class=\"number\">2</span></span><br><span class=\"line\"><span class=\"number\">2</span></span><br></pre></td></tr></table></figure>\n<p><code>begin</code> is a special form takes in any number of expressions, evaluates them in order, and evaluates to the value of the final expression.</p>\n<p><strong>· The evaluation procedure of Macros</strong>:<br>\nStep.1: Evaluate the operator sub-expression, which evaluates to a macro procedure.<br>\nStep.2: Apply the macro procedure to the operand expressions <em>without evaluating them first</em>.<br>\nStep.3: Evaluate the expression returned by the macro procedure in the frame the macro was called in.(must return an unevaluated expression. e.g. a linked list)</p>\n<p>Scheme doesn’t have for loops, but thanks to macros, we can add them.</p>\n<figure class=\"highlight scheme\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"name\">define-macro</span> (<span class=\"name\">for</span> sym in vals do expr)</span><br><span class=\"line\">  (<span class=\"name\"><span class=\"builtin-name\">list</span></span> <span class=\"symbol\">&#x27;map</span> (<span class=\"name\"><span class=\"builtin-name\">list</span></span> <span class=\"symbol\">&#x27;lambda</span> (<span class=\"name\"><span class=\"builtin-name\">list</span></span> sym) expr) vals))</span><br><span class=\"line\"></span><br><span class=\"line\">scm&gt; (for x in &#x27;(1 2 3 4) do (* x x))</span><br><span class=\"line\">(<span class=\"name\">1</span> <span class=\"number\">4</span> <span class=\"number\">9</span> <span class=\"number\">16</span>)</span><br><span class=\"line\">scm&gt; (map (lambda (x) (* x x)) &#x27;(1 2 3 4))</span><br><span class=\"line\">(<span class=\"name\">1</span> <span class=\"number\">4</span> <span class=\"number\">9</span> <span class=\"number\">16</span>)</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight scheme\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"name\">define-macro</span> (<span class=\"name\">for</span> sym vals expr)</span><br><span class=\"line\">  `(map (lambda (,sym) ,expr) ,vals))</span><br></pre></td></tr></table></figure>\n<p>Quasiquotation allows you to have some parts of a list be read literally and some parts be evaluated.</p>\n<p>**<code>** Short for(quasiquote …), </code>,`Short for (unquote …)</p>\n<h3 id=\"part.6-streams\">Part.6 Streams<a title=\"#part.6-streams\" href=\"#part.6-streams\"></a></h3>\n<p>Scheme uses streams just like the iterators in Python whose <code>rest</code> is lazily evaluated.</p>\n<figure class=\"highlight scheme\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">define</span></span> (<span class=\"name\">ints</span> first)</span><br><span class=\"line\">    (<span class=\"name\">cons-stream</span> first</span><br><span class=\"line\">                 (<span class=\"name\">ints</span> (<span class=\"name\"><span class=\"builtin-name\">+</span></span> first <span class=\"number\">1</span>)))</span><br><span class=\"line\">scm&gt; (<span class=\"name\">ints</span> <span class=\"number\">1</span>)</span><br><span class=\"line\">(<span class=\"name\">1</span> . #[<span class=\"name\">promise</span> (<span class=\"name\"><span class=\"builtin-name\">not</span></span> forced)]) <span class=\"comment\">;repesent these expressions are only valuated when we ask.</span></span><br><span class=\"line\">  </span><br><span class=\"line\">scm&gt; (<span class=\"name\"><span class=\"builtin-name\">define</span></span> s (<span class=\"name\">cons-stream</span> <span class=\"number\">1</span> (<span class=\"name\">cons-stream</span> <span class=\"number\">2</span> nil)))</span><br><span class=\"line\">s</span><br><span class=\"line\">scm&gt; s</span><br><span class=\"line\">(<span class=\"name\">1</span> . #[<span class=\"name\">promise</span> (<span class=\"name\"><span class=\"builtin-name\">not</span></span> forced)])</span><br><span class=\"line\">scm&gt; (<span class=\"name\">cdr-stream</span> s)           <span class=\"comment\">; cdr-stream forces Scheme to compute the rest.</span></span><br><span class=\"line\">(<span class=\"name\">2</span> . #[<span class=\"name\">promise</span> (<span class=\"name\"><span class=\"builtin-name\">not</span></span> forced)])</span><br><span class=\"line\">scm&gt; (<span class=\"name\">cdr-stream</span> (<span class=\"name\">cdr-stream</span> s))</span><br><span class=\"line\">()</span><br></pre></td></tr></table></figure>\n<p><code>promise</code>:  an object that delays evaluation of an expression.<br>\nThe <code>delay</code> special form creates promises.<br>\nThe <code>force</code> procedure evaluates the expression inside the promise</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">scm&gt; (define x (delay (print 5)))</span><br><span class=\"line\">x</span><br><span class=\"line\">scm&gt; x</span><br><span class=\"line\">#[promise (not forced)]</span><br><span class=\"line\">scm&gt; (force x)</span><br><span class=\"line\"><span class=\"number\">5</span></span><br><span class=\"line\">scm&gt; x</span><br><span class=\"line\">#[promise (forced)]</span><br></pre></td></tr></table></figure>\n<p><strong>· Constant Stream</strong></p>\n<p>A constant stream is an infinitely long stream with a number repeated.</p>\n<figure class=\"highlight scheme\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">define</span></span> (<span class=\"name\">constant-stream</span> i)</span><br><span class=\"line\">        (<span class=\"name\">cons-stream</span> i (<span class=\"name\">constant-stream</span> i)))</span><br><span class=\"line\">scm&gt; (define ones (constant-stream 1))</span><br><span class=\"line\">scm&gt; (car ones)</span><br><span class=\"line\"><span class=\"number\">1</span></span><br><span class=\"line\">scm&gt; (car (cdr-stream ones))</span><br><span class=\"line\"><span class=\"number\">1</span></span><br></pre></td></tr></table></figure>\n<p><strong>· Add-Stream and Ints-Stream</strong></p>\n<figure class=\"highlight scheme\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">define</span></span> (<span class=\"name\">add-stream</span> s1 s2)</span><br><span class=\"line\">\t(<span class=\"name\">cons-stream</span> (<span class=\"name\"><span class=\"builtin-name\">+</span></span> (<span class=\"name\"><span class=\"builtin-name\">car</span></span> s1) (<span class=\"name\"><span class=\"builtin-name\">car</span></span> s2))</span><br><span class=\"line\">\t\t\t\t  (<span class=\"name\">add-stream</span> (<span class=\"name\">cdr-stream</span> s1) (<span class=\"name\">cdr-stream</span> s2)))</span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">define</span></span> ones (<span class=\"name\">cons-stream</span> <span class=\"number\">1</span> ones))</span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">define</span></span> ints (<span class=\"name\">cons-stream</span> <span class=\"number\">1</span> (<span class=\"name\">add-stream</span> ones ints))</span><br></pre></td></tr></table></figure>\n<h3 id=\"part.7-evaluating-process\">Part.7 Evaluating Process<a title=\"#part.7-evaluating-process\" href=\"#part.7-evaluating-process\"></a></h3>\n<p><strong>Ⅰ. Evaluating primitive expressions</strong></p>\n<p><strong>Self-evaluating expressions</strong>:<br>\nThese expressions evaluate to themselves.</p>\n<p><strong>Symbols</strong>:<br>\nLook in the current frame for the symbol. If it is found, return the value bound to it.<br>\nIf it is not found in the current frame, look in the parent frame. If it is not found in the parent frame, look in its parent frame, and so on. If the global frame is reached and the name is not found, raise a <code>SchemeError</code>.</p>\n<p><strong>Ⅱ. Evaluating Combinations</strong></p>\n<p>1.Special form</p>\n<p>If the operator is a symbol and is found in the dictionary of special forms, the combination is a special form. Each special form has special rules for evaluation.</p>\n<p>2.Call expression</p>\n<p>Step 1. Evaluate the operator to get a procedure.<br>\nStep 2. Evaluate all of the operands from left to right.<br>\nStep 3. Apply the procedure to the values of the operands.</p>\n<p>A <strong>built-in procedure</strong> is a procedure that is predefined in our Scheme interpreter, e.g. <code>+, list, modulo</code>, etc.</p>\n<p>A <strong>user-defined procedure</strong> is a procedure defined by the user, either with a lambda expression or a define expression.<br>\n<strong>· Applying user-defined procedures:</strong><br>\nStep 1. Open a new frame whose parent is the parent frame of the procedure being applied.<br>\nStep 2. Bind the formal parameters of the procedure to the arguments in the new frame.<br>\nStep 3. Evaluate the body of the procedure in the new frame.</p>\n<img src=\"https://i.loli.net/2020/09/15/ti4eSyWaPGkjupI.png\" alt=\"11\" style=\"zoom: 67%;\">\n<p>​                                                            （from CS61A Summer 2019 at UCB）</p>\n","prev":{"title":"SQL Basics","link":"2020/20200916-SQL-Basics"},"next":{"title":"Programs Basics 01","link":"2020/20200910-Programs-Basics-01"},"plink":"https://oreodu.github.io/2020/20200915-Scheme-Basics/","toc":[{"id":"scheme-basics","title":"Scheme Basics","index":"1"}],"reward":true,"copyright":{"author":"Oreo Du","link":"<a href=\"https://oreodu.github.io/2020/20200915-Scheme-Basics/\" title=\"Scheme Basics\">https://oreodu.github.io/2020/20200915-Scheme-Basics/</a>","license":"Attribution-NonCommercial-NoDerivatives 4.0 International (<a href=\"https://creativecommons.org/licenses/by-nc-sa/4.0/\" rel=\"external nofollow noopener\" target=\"_blank\">CC BY-NC-ND 4.0</a>)"}}