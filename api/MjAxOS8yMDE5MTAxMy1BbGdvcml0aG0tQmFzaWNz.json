{"title":"Algorithm Basics","date":"2019-10-13T04:43:00.000Z","date_formatted":{"ll":"Oct 13, 2019","L":"10/13/2019","MM-DD":"10-13"},"link":"2019/20191013-Algorithm-Basics","comments":true,"tags":["Algorithms"],"categories":["Algorithms"],"updated":"2020-11-23T12:13:33.308Z","content":"<h2 id=\"algorithm-basics\">Algorithm Basics<a title=\"#algorithm-basics\" href=\"#algorithm-basics\"></a></h2>\n<h3 id=\"overview\">Overview<a title=\"#overview\" href=\"#overview\"></a></h3>\n<p>(概略图)</p>\n<p><strong>· materials:</strong><br>\n· <i>Algorithms</i>  by Dasgupta, C. H. Papadimitriou, U. V. Vazirani<br>\n· <i>Efficient Algorithms and Intractable Problems</i>  (CS170 2018 Fall at UCB)<br>\n· <i>Algorithm Design</i> by John Kleinberg, Eva Tardos<br>\n· <a href=\"https://www.coursera.org/learn/algorithms-part1\" target=\"_blank\"><u>Algorithms, Part I,Ⅱ by Princeton University</u></a><br>\n· Wikipedia</p>\n<h3 id=\"part.1-what-is-algorithm?\">Part.1 What is Algorithm?<a title=\"#part.1-what-is-algorithm?\" href=\"#part.1-what-is-algorithm?\"></a></h3>\n<p>The program is designed to solve certain problems and it mainly contains algorithms and data structures.</p>\n<blockquote>\n<p>An algorithm is a sequence of instructions. (from <i>Algorithm</i> Wikipedia)</p>\n</blockquote>\n<p>As usual, the algorithm use control structures (sequential, conditional, recurrent) and operators to make the instructions. A effective algorithms must have several characteristics as follows:<br>\n<strong>1.Correctness</strong>: For each legal input, the algorithms must produce the expected output after a few precise and feasible instructions. (End within finite time.)<br>\n<strong>2.Robustness</strong>: The algorithms must can apply in all possible circumstances that could arise and have the ability of tolerating perturbations and unexcepted exceptions.<br>\n<strong>3.High efficiency and low storage requirement</strong></p>\n<h3 id=\"part.2-how-to-design-a-proper-algorithm?\">Part.2 How to design a proper algorithm?<a title=\"#part.2-how-to-design-a-proper-algorithm?\" href=\"#part.2-how-to-design-a-proper-algorithm?\"></a></h3>\n<p>Typical steps in the development of algorithms:<br>\n1.Problem definition<br>\n2.Development of a model<br>\n3.Specification of the algorithm<br>\n<strong>4</strong>.Designing an algorithm<br>\n<strong>5</strong>.Checking the correctness of the algorithm<br>\n<strong>6</strong>.Analysis of algorithm<br>\n<strong>7</strong>.Implementation of algorithm<br>\n8.Program testing<br>\n9.Documentation preparation<br>\n(from <i>Algorithm</i> Wikipedia)</p>\n<p>When we finished design the algorithm, we should keep asking ourselves three questions as follows in order to make it more efficient.</p>\n<blockquote>\n<p><a href=\"http://1.Is\">1.Is</a> it correct (produce the expected output) ?  (<strong>Check</strong>)<br>\n2.How much time and storage does it take?  (<strong>Analyze</strong>)<br>\n3.Can we do better (higher efficiency and lower storage) ?  (<strong>optimize</strong>)<br>\n(from <i>Algorithms</i>  by Dasgupta, C. H. Papadimitriou, U. V. Vazirani)</p>\n</blockquote>\n<h3 id=\"part.3-classification\">Part.3 Classification<a title=\"#part.3-classification\" href=\"#part.3-classification\"></a></h3>\n<p>There are various ways to classify algorithms.</p>\n<p><strong>By design paradigm</strong>:<br>\n· Brute-force or exhaustive search (try every possible solution)<br>\n· Search and enumeration<br>\n· Back tracking<br>\n· Divide and conquer (repeatedly reduces an instance of a problem to one or more smaller instances  until the instances are small enough to solve easily)<br>\n· Randomized algorithm (make some choices randomly (or pseudo-randomly))<br>\n· Reduction of complexity (transform the difficult problem into a better-known problem that we have asymptotically optimal algorithms.)</p>\n<p><strong>By implementation</strong>:<br>\n· Recursion ( invokes itself repeatedly)<br>\n· Logical (logic + control)<br>\n· Serial (execute one algorithm at a time), parallel or distributed (several processors work on a problem at the same time)<br>\n· Deterministic (exact decision at every step of the algorithm) or non-deterministic (guess through the use of heuristics)<br>\n· Exact (reach an exact solution) or approximate (closer to the true solution)<br>\n· Quantum algorithm</p>\n<p><strong>Optimization problems</strong><br>\n· Linear programming (the constraints of the problem can be used directly in producing the optimal solutions.)<br>\n· Dynamic programming (the optimal solution to a problem can be constructed from optimal solutions to subproblems and overlapping subproblems)<br>\n· The greedy method (start with some given or modified solutions)<br>\n· The heuristic method (find a solution close to the optimal solution)</p>\n<h3 id=\"part.4-how-to-analyze-an-algorithm?\">Part.4 How to analyze an algorithm?<a title=\"#part.4-how-to-analyze-an-algorithm?\" href=\"#part.4-how-to-analyze-an-algorithm?\"></a></h3>\n<p>It is frequently important to know how much of a particular resource (such as <strong>time or storage</strong>) is theoretically required for a given algorithm.  (from <i>Algorithm</i> Wikipedia). By analyzing the time complexity and space complexity we are able to improve the algorithm in a clearer direction.</p>\n<h4 id=\"ⅰ.-time-complexity\">Ⅰ. Time complexity<a title=\"#ⅰ.-time-complexity\" href=\"#ⅰ.-time-complexity\"></a></h4>\n<p>In theory, we quantify the time through counting the number of elementary operations performed by the algorithm and multiply it by the time spent on each operation, where an elementary operation takes a fixed amount of time. Thus the amount of time taken by the same algorithm differ by a constant factor which is depended on the performance of different computers.</p>\n<p>In most cases, in order to analyze the algorithms in a more efficient way we should simplify the way we estimate the time complexity. Because only the number of the operations depends on algorithms and input data, so we can ignore the constant time spent on each elementary operation and express the running time by counting the number of the operations, as a function of the size of the input. Further, as the input size goes to infinity, we can use the basic operation as a proxy for the running time and ignore the lower order terms.</p>\n<p>So it is commonly expressed using the <strong>asymptotic notation</strong>, which lets us only focus on the big pictures. Asymptotic notation characterizes functions according to their growth rates: different functions with the same growth rate may be represented using the same notation.</p>\n<p>Since an algorithm’s performance time may vary with different inputs of  the same size, we commonly use the <strong>worst-case time complexity</strong>, denoted as $T(n)$, which is defined as the maximum amount of time taken on any input of size n.</p>\n<p><strong>Asymptotic notation</strong>:</p>\n<p>Let <i>f(n)</i> and <i>g(n)</i> be functions from positive integers to positive reals and think of them as the running time of two algorithms on inputs of size n.</p>\n<p>1.$ f = O(g) $, if there is a constant $ c&gt;0 $ and $ n_0 $, such that $ |f(n)| \\leq c · g(n) $ for all $n&gt;n_0$<br>\nBig O notation provides an upper bound on the growth rate of the function.  <i>f</i> grows no faster than <i>g</i>.</p>\n<p>2.$ g = Ω(f) $ ( <i>f</i> grows no faster than <i>g</i> ) if there is a constant $c &gt; 0$, such that $g(n) \\geq c · f(n)$</p>\n<p>3.$f = Θ(g)$( <i>g</i> grows the same as <i>f</i> ) if there is a constant $c &gt; 0$, such that $g(n) = c · f(n)$</p>\n<p>If the function <i>f</i> can be written as a finite sum of other functions, then the fastest growing one determines the order of $f(n)$. Here are some rules that can simplify <i>f</i> to <i>O(g)</i> by omitting coefficients and lower order terms.</p>\n<p>· Multiplicative constants can be omitted.<br>\n· log a dominates log b, $n^a$ dominates $n^b$ and $a^n$ dominates $b^n$ if $a&gt;b$<br>\n· Any exponential dominates any polynomial<br>\n· Any polynomial dominates any logarithm</p>\n<p>· $f_1= O(g_1)$ and $f_2 = O(g_2)$, $f_1· f_2 = O(g_1· g_2))$<br>\n· $f_1 = O(g_1)$ and $f_2 = O(g_2)$, $f_1 + f_2 = O(max(g_1, g_2))$</p>\n<p>· Orders of common functions:<br>\n$O(1)$, $O(\\log(\\log(n)))$, $O(\\log(n))$, $O((\\log(n))^c)  (c&gt;1)$,<br>\n$O(n^c)  (0&lt;c&lt;1)$, $O(n)$, $O(n\\log (n)) = O(\\log(n!))$,<br>\n$O(n^2)$, $O(n^c)$, $O(c^n)  (c&gt;1)$, $O(n!)$</p>\n<img src=\"https://i.loli.net/2020/09/29/IUthjneKSuP4wWX.png\" alt=\"123\" style=\"zoom:50%;\">\n<p>Upper bound: a specific algorithms.<br>\nLower bound: proof that no algorithm can do better.</p>\n<p>Optimal algorithm: Lower bound equals upper bound to within a constant factor.</p>\n<p>When we design an algorithm,we usually focus on lower the upper bound(discover a new algorithm) and raise the lower bound.</p>\n<h4 id=\"ⅱ.-space-complexity\">Ⅱ. Space complexity<a title=\"#ⅱ.-space-complexity\" href=\"#ⅱ.-space-complexity\"></a></h4>\n<p>The space complexity of an algorithm is the amount of the memory required by an algorithm to execute a program and produce output as a function of the size of the input. Similar to time complexity, Space complexity is often expressed asymptotically. such as $O(1)$,$O(n)$, $O(n\\log(n))$, $O(n^\\alpha)$, $O(2^n)$, etc., where n is the input size in units of bits needed to represent the input.</p>\n<h3 id=\"part.5-computational-theory\">Part.5 Computational Theory<a title=\"#part.5-computational-theory\" href=\"#part.5-computational-theory\"></a></h3>\n","prev":{"title":"Sorting","link":"2020/20200102-Sorting"},"next":{"title":"Python Basics 01","link":"2019/20191010-Python-Basics-01"},"plink":"https://oreodu.github.io/2019/20191013-Algorithm-Basics/","toc":[{"id":"algorithm-basics","title":"Algorithm Basics","index":"1"}],"reward":true,"copyright":{"author":"Oreo Du","link":"<a href=\"https://oreodu.github.io/2019/20191013-Algorithm-Basics/\" title=\"Algorithm Basics\">https://oreodu.github.io/2019/20191013-Algorithm-Basics/</a>","license":"Attribution-NonCommercial-NoDerivatives 4.0 International (<a href=\"https://creativecommons.org/licenses/by-nc-sa/4.0/\" rel=\"external nofollow noopener\" target=\"_blank\">CC BY-NC-ND 4.0</a>)"}}