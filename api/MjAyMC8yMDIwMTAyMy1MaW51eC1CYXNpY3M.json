{"title":"Linux Basics","date":"2020-10-23T04:43:00.000Z","date_formatted":{"ll":"Oct 23, 2020","L":"10/23/2020","MM-DD":"10-23"},"link":"2020/20201023-Linux-Basics","comments":true,"tags":["Operating System"],"categories":["Linux","Operating System"],"updated":"2020-10-24T02:17:46.464Z","content":"<h1 id=\"linux-basics\">Linux Basics<a title=\"#linux-basics\" href=\"#linux-basics\"></a></h1>\n<h2 id=\"part.1-history\">Part.1 History<a title=\"#part.1-history\" href=\"#part.1-history\"></a></h2>\n<img src=\"https://tva1.sinaimg.cn/large/0081Kckwly1gjyai1ptkcj30q60j0tc5.jpg\" alt=\"截屏2020-10-22 下午5.10.17\" style=\"zoom: 67%;\">\n<p>​            (From Advanced Operating Systems in The University of Tokyo)</p>\n<p>Unix:</p>\n<p>Unix is very popular and ported to multiple architectures due to its simple design and ease of use.</p>\n<p>Simplicity:<br>\n➢ Small number of system calls with clearly defined design.<br>\n➢ Everything is a file.<br>\n➢ Written in C for portability.<br>\n➢ Easy and fast process creation (fork()).<br>\n➢ Simple and efficient Inter-Process Communication mechanisms (IPC).</p>\n<h2 id=\"part.2-linux-open-source-model\">Part.2 Linux open source model<a title=\"#part.2-linux-open-source-model\" href=\"#part.2-linux-open-source-model\"></a></h2>\n<p>Benefits of open source vs closed development:</p>\n<p>➢ Security, stability: Given enough eyeballs, all bugs are shallow.<br>\n➢ Code quality.<br>\n➢ Freely modifiable by anyone having an interest to do so.<br>\n➢ Education, research:  We can PEEK at the code to understand how it works and we can POKE it to experiment and build new systems.</p>\n<h2 id=\"part.3-linux-kernel\">Part.3 Linux Kernel<a title=\"#part.3-linux-kernel\" href=\"#part.3-linux-kernel\"></a></h2>\n<p>Sources are freely <a href=\"https://www.kernel.org/\" target=\"_blank\">available</a>.</p>\n<p>Manages the hardware and provides <strong>interfaces</strong> or user space processes to access the hardware and perform privileged operations.</p>\n<p>Monolithic Model: Opposed to the <em>microkernel</em> model, Linux is monolithic. All the OS services run in kernel, privileged mode. System calls are the one and only way an application can enter the kernel to request OS services and privileged operations such as accessing the hardware.</p>\n<p>Kernel vs user level programming:<br>\n➢ No C library mostly because of speed and size. However, the kernel implements lots of usefull functions from the C library.<br>\n➢ 2% assembly, the rest in GNU C (GCC extensions).<br>\n➢ No memory protection.<br>\n➢ Highly concurrent: Preemption, interrupts, running on SMP (Symmetric Multiprocessor System). Race conditions without proper synchronization.</p>\n<img src=\"https://tva1.sinaimg.cn/large/0081Kckwly1gjybtotr4sj30vu0mqaib.jpg\" alt=\"截屏2020-10-22 下午7.17.10\" style=\"zoom: 50%;\">\n<p>​      \t\t\t\t\t\t\t\t      (From Advanced Operating Systems in The University of Tokyo)</p>\n<img src=\"https://tva1.sinaimg.cn/large/0081Kckwly1gjyfieodezj30ys0hsk0q.jpg\" alt=\"Screen Shot 2020-10-22 at 21.24.39\" style=\"zoom: 55%;\">\n<p>​        \t\t\t\t\t\t\t       (From Advanced Operating Systems in The University of Tokyo)</p>\n<h3 id=\"system-calls\">System calls<a title=\"#system-calls\" href=\"#system-calls\"></a></h3>\n<p>Syscalls can be classified into groups:<br>\n➢ <strong>Process management/scheduling:</strong> fork, exit, execve, nice,{<em>get|set</em>}priority,{get|set}pid, etc.<br>\n➢ <strong>Memory management:</strong> brk, mmap, swap{on|of}, etc.<br>\n➢ <strong>File system</strong>: open, read, write, lseek, stat, etc.<br>\n➢ <strong>Inter-Process Communication</strong>: pipe, shmget, semget, etc.<br>\n➢ <strong>Time management</strong>: {get|set}timeofday, time, timer create, etc.<br>\n➢ Others: *{<em>get|set</em>}*uid, syslog, connect, etc.</p>\n<p>System calls table syscall identifier(unique integer).</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">0 common read sys_read</span><br><span class=\"line\">1 common write sys_write</span><br><span class=\"line\">2 common open sys_open</span><br><span class=\"line\">3 common close sys_close</span><br><span class=\"line\"># ...</span><br></pre></td></tr></table></figure>\n<h3 id=\"syscall-invocation(user-space-side)\">Syscall invocation(user space side)<a title=\"#syscall-invocation(user-space-side)\" href=\"#syscall-invocation(user-space-side)\"></a></h3>\n<img src=\"https://tva1.sinaimg.cn/large/0081Kckwgy1gjz28nljggj30xi06uabg.jpg\" alt=\"Screen Shot 2020-10-23 at 10.30.07\" style=\"zoom:50%;\">\n<p>​\t\t\t\t\t\t\t\t\t\t   (From Advanced Operating Systems in The University of Tokyo)</p>\n<p>Syscalls are rarely invoked directly. Most of them are wrapped by the C library. The programmer uses the C library Application Programming Interface (API).</p>\n<p><img src=\"https://tva1.sinaimg.cn/large/0081Kckwgy1gjz2kopy4lj30zo04oabx.jpg\" alt=\"Screen Shot 2020-10-23 at 10.42.38\" class=\"φcx\"></p>\n<p>​\t\t\t\t\t\t\t\t \t\t (From Advanced Operating Systems in The University of Tokyo)</p>\n<p>System calls behavior is documented in man pages.</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">man &lt;syscall name&gt;</span><br></pre></td></tr></table></figure>\n<p>Some syscalls does not have a wrapper in the C library. A syscall can be called directly through syscall man syscall.(invocation without the wrapper)</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">bytes_written = syscall(SYS_write, <span class=\"number\">1</span>, message, <span class=\"number\">14</span>);</span><br></pre></td></tr></table></figure>\n<p>On x86 64, syscalls can be used directly through thesyscall assembly instruction.(invocation without the C library)</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># syscall_asm.s</span><br><span class=\"line\">\t\t\t.global _start</span><br><span class=\"line\">      .text </span><br><span class=\"line\">_start:</span><br><span class=\"line\">\t\t\t\t<span class=\"meta\"># write(1, message, 14) </span></span><br><span class=\"line\">\t\t\t\tmov $<span class=\"number\">1</span>, %rax</span><br><span class=\"line\">\t\t\t\tmov $<span class=\"number\">1</span>, %rdi</span><br><span class=\"line\">\t\t\t\tmov $message, %rsi </span><br><span class=\"line\">        mov $<span class=\"number\">14</span>, %rdx </span><br><span class=\"line\">        syscall</span><br><span class=\"line\">\t\t\t\t</span><br><span class=\"line\">        <span class=\"meta\"># exit(0)</span></span><br><span class=\"line\">\t\t\t\tmov $<span class=\"number\">60</span>, %rax x</span><br><span class=\"line\">        <span class=\"keyword\">or</span> %rdi, %rdi </span><br><span class=\"line\">        syscall</span><br><span class=\"line\">message:</span><br><span class=\"line\">\t\t\t\t.ascii <span class=\"string\">&quot;Hello, world!¥n&quot;</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"syscall-execution(kernel-space-side)\">Syscall execution(kernel space side)<a title=\"#syscall-execution(kernel-space-side)\" href=\"#syscall-execution(kernel-space-side)\"></a></h3>\n<p>When an interrupt is received by the CPU, it stops whatever it is doing and <strong>the kernel executes the interrupt handler</strong>.</p>\n<p>Interrupts:<br>\nAsynchronous: <strong>hardware interrupts</strong>, issued from devices.<br>\nSynchronous: <strong>exceptions</strong>, triggered involuntarily by the program Itself.<br>\nSynchronous, programmed exceptions: <strong>software interrupts</strong>, issued voluntarily by the code of the program itself.</p>\n<p>How is a syscall invoked from user space:<br>\n➢ User space put the <strong>syscall identifier and parameters values into registers</strong> (x86)<br>\n➢ Then issues a <strong>software interrupt</strong><br>\n➢ The kernel executes the interrupt handler, <strong>system call handler</strong>.<br>\nPuts the registers values into a data structure placed on the stack<br>\nChecks the validity of the syscall (number of arguments)<br>\nThen execute the system call implementation.</p>\n<p>How to exchange data between user and memory areas with pointers:<br>\n➢When a kernel function gets a pointer to some memory in user space it needs to use: The kernel copies it into its memory area (<code>copy from user</code>) .<br>\n➢ When the kernel wants to write in a user space buffer: It uses <code>copy to user</code>.</p>\n<h3 id=\"implementing-a-new-system-call\">Implementing a new system call<a title=\"#implementing-a-new-system-call\" href=\"#implementing-a-new-system-call\"></a></h3>\n<ol>\n<li>Write your syscall function<br>\nIn an existing file if it makes sense. Is it related to time management ? <em>→</em> kernel/time/time.c<br>\nOr, if the implementation is large and self-contained: in a new file. You will have to edit the kernel <code>Makefiles</code> to integrate it in the compilation process.</li>\n<li>Add it to the syscall table and give it an identifier<br>\n<code>arch/x86/syscalls/syscall 64.tbl</code>for Linux 4.0</li>\n<li>Add the prototype in <code>include/linux/syscalls.h</code>.</li>\n</ol>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">asmlinkage <span class=\"keyword\">long</span> <span class=\"title\">sys_gettimeofday</span><span class=\"params\">(struct timeval_user *tv, </span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                                 struct timezone_user *tz)</span></span>;</span><br></pre></td></tr></table></figure>\n<ol start=\"4\">\n<li>Recompile, reboot and run. Touching the syscall table will trigger the entire kernel compilation</li>\n</ol>\n<p>➢ <strong>Pros:</strong> Easy to implement and use, fast<br>\n➢ <strong>Cons</strong>:<br>\nNeeds an official syscall number<br>\nInterface cannot change after implementation<br>\nMust be registered for each architecture<br>\nProbably too much work for small exchanges of information<br>\n➢ <strong>Alternative</strong>:<br>\nDevice or virtual file:User/kernel space communication through <code>read,write,ioctl</code>.</p>\n<h2 id=\"part.4-virtual-machine\">Part.4 Virtual machine<a title=\"#part.4-virtual-machine\" href=\"#part.4-virtual-machine\"></a></h2>\n<blockquote>\n<p>I would classify virtual machine technologies into three categories (not all products fit clearly into one category):</p>\n<ul>\n<li><a href=\"http://en.wikipedia.org/wiki/Full_virtualization\" target=\"_blank\">Full virtualization</a>, i.e., complete hardware emulation. Examples: <a href=\"http://en.wikipedia.org/wiki/QEMU\" target=\"_blank\">Qemu</a>, <a href=\"http://en.wikipedia.org/wiki/DOSBox\" target=\"_blank\">Dosbox</a>. Pro: you can potentially emulate any architecture on any hardware. Con: it’s the slowest way to do it.</li>\n<li>Hardware-assisted virtualization, where you can emulate machine X on machine X. This can be a lot faster than full virtualization, because most instructions are executed natively, but you lose the ability to run a foreign architecture. There are two sub-categories:</li>\n<li>Hypervisor-based VMs: you run several OSes alongside each other. The bottom layer, called the hypervisor, is a special-purpose OS that runs the VMs and nothing else. Examples: <a href=\"http://en.wikipedia.org/wiki/Xen\" target=\"_blank\">Xen</a>, <a href=\"http://en.wikipedia.org/wiki/VMware_ESX\" target=\"_blank\">VMware ESX</a>.</li>\n<li>Hosted VMs: there is a main OS, the VM is an application on this main OS. Examples: <a href=\"http://en.wikipedia.org/wiki/VirtualBox\" target=\"_blank\">VirtualBox</a>, <a href=\"http://en.wikipedia.org/wiki/Kernel-based_Virtual_Machine\" target=\"_blank\">KVM</a>.</li>\n<li><a href=\"http://en.wikipedia.org/wiki/Operating_system-level_virtualization\" target=\"_blank\">OS-level virtualization</a>: you run several instances of the same OS. This can be in turn a lot more lightweight than hardware virutalization, but you lose some isolation and of course the ability to run different OSes. Examples: <a href=\"http://en.wikipedia.org/wiki/OpenVZ\" target=\"_blank\">OpenVZ</a>, <a href=\"http://en.wikipedia.org/wiki/FreeBSD_jail\" target=\"_blank\">FreeBSD jails</a>.</li>\n</ul>\n<p>(From <a href=\"https://unix.stackexchange.com/questions/5741/what-are-the-differences-between-various-vm-software\" target=\"_blank\">here</a>.)</p>\n</blockquote>\n<img src=\"https://tva1.sinaimg.cn/large/0081Kckwgy1gjyzldca2dj30b40bsgmh.jpg\" alt=\"image1\" style=\"zoom:80%;\">\n<p>​                                      \t\t\t\t           (KVM + Qemu. From <a href=\"https://www.packetflow.co.uk/what-is-the-difference-between-qemu-and-kvm/\" target=\"_blank\">here</a>)</p>\n<p>GDB server: more details from <a href=\"https://www.gnu.org/software/gdb/\" target=\"_blank\">here</a>.</p>\n","prev":{"title":"Process Management","link":"2020/20201024-Process-Management"},"next":{"title":"Exercises in Lad","link":"2020/20201014-Exercises-in-Lad"},"plink":"https://oreodu.github.io/2020/20201023-Linux-Basics/","toc":[{"id":"linux-basics","title":"Linux Basics","index":"1","children":[{"id":"part.1-history","title":"Part.1 History","index":"1.1"},{"id":"part.2-linux-open-source-model","title":"Part.2 Linux open source model","index":"1.2"},{"id":"part.3-linux-kernel","title":"Part.3 Linux Kernel","index":"1.3"},{"id":"part.4-virtual-machine","title":"Part.4 Virtual machine","index":"1.4"}]}],"reward":true,"copyright":{"author":"Oreo Du","link":"<a href=\"https://oreodu.github.io/2020/20201023-Linux-Basics/\" title=\"Linux Basics\">https://oreodu.github.io/2020/20201023-Linux-Basics/</a>","license":"Attribution-NonCommercial-NoDerivatives 4.0 International (<a href=\"https://creativecommons.org/licenses/by-nc-sa/4.0/\" rel=\"external nofollow noopener\" target=\"_blank\">CC BY-NC-ND 4.0</a>)"}}