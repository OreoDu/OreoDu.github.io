{"title":"Scheme Basics","date":"2020-09-15T02:42:00.000Z","thumbnail":"https://i.loli.net/2020/09/09/peTDhdvbrl7P3Ho.jpg","slug":"20200915-Scheme-Basics","comments":true,"tags":["Scheme"],"categories":["Programming"],"updated":"2020-09-17T14:03:43.813Z","content":"<h1 id=\"Scheme-Basics\">Scheme Basics<a href=\"post/20200915-Scheme-Basics#Scheme-Basics\"></a></h1><h3 id=\"Overview\">Overview<a href=\"post/20200915-Scheme-Basics#Overview\"></a></h3><p>(概略图)</p>\n<p><strong>· materials:</strong><br> · <a href=\"https://inst.eecs.berkeley.edu/~cs61a/su19/\" target=\"_blank\" rel=\"noopener\"><u>CS61A Summer 2019 at UCB</u></a></p>\n<h3 id=\"Part-1-Scheme-values\">Part.1 Scheme values<a href=\"post/20200915-Scheme-Basics#Part-1-Scheme-values\"></a></h3><p><strong>Ⅰ. Atoms:</strong> primitive values that cannot be broken up into smaller parts</p>\n<ul>\n<li>numbers: <code>10, -6, 5.7, 4021</code></li>\n<li>booleans: <code>#t, #f</code></li>\n<li>symbols: <code>hello, world</code></li>\n</ul>\n<p><strong>Ⅱ. Pairs and Lists:</strong>  a sequence of zero or more values<br><code>(1 2 3 4 5 6)</code><br>The pair is the basic compound value in Scheme. Lists in Scheme are created using pairs. They’re linked lists.</p>\n<p>1.Pair<br>Pairs are created using the <code>cons</code> expression in Scheme<br><code>car</code> selects the first element in a pair<br><code>cdr</code> selects the second element in a pair<br>The second element of a pair must be another pair, or <code>nil</code></p>\n<pre class=\" language-scheme\"><code class=\"language-scheme\">scm> <span class=\"token punctuation\">(</span><span class=\"token keyword\">define</span> x <span class=\"token punctuation\">(</span><span class=\"token builtin\">cons</span> <span class=\"token number\">1</span> <span class=\"token punctuation\">(</span><span class=\"token builtin\">cons</span> <span class=\"token number\">3</span> nil<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\nx\nscm> x\n<span class=\"token punctuation\">(</span><span class=\"token function\">1</span> <span class=\"token number\">3</span><span class=\"token punctuation\">)</span>\nscm> <span class=\"token punctuation\">(</span><span class=\"token builtin\">car</span> x<span class=\"token punctuation\">)</span>\n<span class=\"token number\">1</span>\nscm> <span class=\"token punctuation\">(</span><span class=\"token builtin\">cdr</span> x<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">(</span>3<span class=\"token punctuation\">)</span></code></pre>\n<p>2.List<br>The list constructor takes in any number of elements and puts each element as a single element in a list.</p>\n<pre class=\" language-scheme\"><code class=\"language-scheme\">scm> <span class=\"token punctuation\">(</span><span class=\"token builtin\">list</span> <span class=\"token number\">1</span> <span class=\"token number\">2</span> <span class=\"token number\">3</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">(</span><span class=\"token function\">1</span> <span class=\"token number\">2</span> <span class=\"token number\">3</span><span class=\"token punctuation\">)</span>\nscm> <span class=\"token punctuation\">(</span><span class=\"token builtin\">list</span> <span class=\"token number\">0</span> <span class=\"token punctuation\">(</span><span class=\"token builtin\">list</span> <span class=\"token number\">1</span> <span class=\"token number\">2</span> <span class=\"token number\">3</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">(</span><span class=\"token function\">0</span> <span class=\"token punctuation\">(</span><span class=\"token function\">1</span> <span class=\"token number\">2</span> <span class=\"token number\">3</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span></code></pre>\n<p>The quote special form takes in a single argument and returns an unevaluated version of the argument. Quoting a symbol gives a symbol back. Quoting the representation of a list gives a list.</p>\n<pre class=\" language-scheme\"><code class=\"language-scheme\">scm> ‘<span class=\"token punctuation\">(</span><span class=\"token function\">0</span> <span class=\"token punctuation\">(</span><span class=\"token function\">1</span> <span class=\"token number\">2</span> <span class=\"token number\">3</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">(</span><span class=\"token function\">0</span> <span class=\"token punctuation\">(</span><span class=\"token function\">1</span> <span class=\"token number\">2</span> <span class=\"token number\">3</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span></code></pre>\n<p><strong>cons</strong>: When you want to add an element on to the start of a list.<br>Ex: add an element to the start of the list returned by a recursive call<br><strong>list:</strong>  When you have multiple elements you want to put into a list all at once.<br>Ex: want to create a two element list containing x and y<br><strong>quote:</strong>  When you know the exact structure of the list and the values it contains.<br>Ex: create a list to pass in as an argument in an interactive session</p>\n<p><strong>Ⅲ. Procedures:</strong>  function objects, either built-in or user-defined<br><code>(lambda (x) (* x x))</code></p>\n<h3 id=\"Part-2-Scheme-expressions\">Part.2 Scheme expressions<a href=\"post/20200915-Scheme-Basics#Part-2-Scheme-expressions\"></a></h3><p>Scheme programs consist only of expressions, all of which can be categorized into either atomic expressions or combinations.<br><strong>Ⅰ. Atomic expressions</strong><br><em>Self-evaluating:</em> numbers, booleans<br><code>3, 5.5, -10, #t, #f</code><br><em>Symbols:</em> names bound to values<br><code>+, modulo, list, x, foo, hello-world</code></p>\n<p><strong>Ⅱ. Combinations</strong> </p>\n<p><code>(&lt;operator&gt; &lt;operand1&gt; &lt;operand2&gt; …)</code><br>A combination is either a <strong>call expression</strong> or a <strong>special form expression</strong>.<br><code>(+ 2 3)</code>, <code>(abs (/ 20 5))</code>, <code>(&lt; 4 8.5)</code><br><code>(define x 5)</code>, <code>(if #t 10 20)</code>, <code>(lambda (x) (* x x))</code></p>\n<p><strong>· Call expressions</strong><br>A call expression applies a procedure to some arguments.</p>\n<p>Evaluate call expressions:<br>Step 1.  Evaluate the operator to get a procedure.<br>Step 2.  Evaluate all operands left to right to get the arguments.<br>Step 3. Apply the procedure to the arguments.</p>\n<p><strong>· Special form expressions</strong><br>1.Assigning values to names<br>The define special form assigns a value to a name:<br><code>(define &lt;name&gt; &lt;expr&gt;)</code><br>Evaluate:<br>Step 1. Evaluate the given expression.<br>Step 2. Bind the resulting value to the given name in the current frame.<br>Step 3. Return the name as a symbol.</p>\n<p>2.Defining functions with names<br>The second version of define is a shorthand for creating a function with a name:<br><code>(define (&lt;name&gt; &lt;param1&gt; &lt;param2&gt; …) &lt;body&gt;)</code><br>Evaluate:<br>Step 1. Create a lambda procedure with the given parameters and body.<br>Step 2. Bind it to the given name in the current frame.<br>Step 3. Return the function name as a symbol.<br>(If there is more than one expression in the body, the function returns the value of the last expression.)</p>\n<p>3.Creating functions<br>The lambda special form returns a lambda procedure.<br><code>(lambda (&lt;param1&gt; &lt;param2&gt; …) &lt;body&gt;)</code><br>Evaluate:<br>Step 1. Create a lambda procedure with the given parameters and body.<br>Step 2. Return the lambda procedure.</p>\n<p>4.Control flow<br>The if special form allows us to evaluate an expression based on a condition:<br><code>(if &lt;predicate&gt; &lt;if-true&gt; &lt;if-false&gt;)</code><br>Evaluate:<br>Step 1. Evaluate the <code>&lt;predicate&gt;</code>.<br>Step 2. If <code>&lt;predicate&gt;</code> evaluates to anything but #f, evaluate <code>&lt;if-true&gt;</code> and return the value. Otherwise, evaluate <code>&lt;if-false&gt;</code> if provided and return the value.</p>\n<p>The cond special form allows us to specify many conditions and consequences:<br><code>(cond (&lt;pred1&gt; &lt;expr1&gt;) (&lt;pred2&gt; &lt;expr2&gt;) … (else &lt;else-expr&gt;))</code><br>Evaluate:<br>Step 1. Evaluate <code>&lt;pred1&gt;</code>, <code>&lt;pred2&gt;</code>, etc. until one evaluates to a truth-y value.<br>Step 2. Evaluate and return the expression corresponding to the first truth-y predicate. If no predicate evaluates to a truth-y value, evaluate and return <code>&lt;else-expr&gt;</code> if provided.</p>\n<p>5.Others<br><code>(equal? e1 e2)</code> checks if e1 and e2 evaluate to equivalent values.<br><code>(eq? e1 e2)</code> checks if e1 and e2 evaluate to identical values.</p>\n<h3 id=\"Part-3-Tail-Recursion\">Part.3 Tail Recursion<a href=\"post/20200915-Scheme-Basics#Part-3-Tail-Recursion\"></a></h3><p>We know that a function call will form a “call record” in memory, also known as a “call frame”, which saves information such as the call location and internal variables. If function B is called inside function A, then a call frame of B will be formed above the call frame of A. Wait until the end of B runs and return the result to A, then the call frame of B will disappear. If function B also calls function C, then there is a call frame of C, and so on. All call frames form a “call stack” (call stack).</p>\n<p><strong>· Tail Call</strong><br>In computer science, a tail call is a subroutine call performed as the final action of a procedure.  If all recursive calls are in tail contexts, we say that function is  tail recursive. If a language supports tail call optimization, a tail recursive function will only ever open a constant number of frames.</p>\n<p>Tail calls can be implemented without adding a new stack frame to the call stack. Most of the frame of the current procedure is no longer needed, and can be replaced by the frame of the tail call, modified as appropriate (similar to overlay for processes, but for function calls). The program can then jump to the called subroutine.</p>\n<pre class=\" language-scheme\"><code class=\"language-scheme\"><span class=\"token comment\" spellcheck=\"true\">; original recursive call</span>\n<span class=\"token punctuation\">(</span><span class=\"token keyword\">define</span> <span class=\"token punctuation\">(</span><span class=\"token function\">fact</span> n<span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">(</span><span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">=</span> n <span class=\"token number\">0</span><span class=\"token punctuation\">)</span>\n   <span class=\"token number\">1</span>\n   <span class=\"token punctuation\">(</span><span class=\"token operator\">*</span> n <span class=\"token punctuation\">(</span><span class=\"token function\">fact</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">-</span> n <span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>  \n<span class=\"token comment\" spellcheck=\"true\">;We need to keep these frames open because the last step in the function is to multiply n with the result of the recursive call.</span>\n\n<span class=\"token comment\" spellcheck=\"true\">; tail call</span>\n<span class=\"token punctuation\">(</span><span class=\"token keyword\">define</span> <span class=\"token punctuation\">(</span><span class=\"token function\">fact</span> n<span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">(</span><span class=\"token keyword\">define</span> <span class=\"token punctuation\">(</span><span class=\"token function\">fact-tail</span> n result<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">(</span><span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">&lt;=</span> n <span class=\"token number\">1</span><span class=\"token punctuation\">)</span>\n        result\n        <span class=\"token punctuation\">(</span><span class=\"token function\">fact-tail</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">-</span> n <span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">*</span> n result<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">(</span><span class=\"token function\">fact-tail</span> n <span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span></code></pre>\n<h3 id=\"Part-5-Macros\">Part.5 Macros<a href=\"post/20200915-Scheme-Basics#Part-5-Macros\"></a></h3><p>In Scheme,  expressions are lists (or primitive values) and quoting prevents evaluation of an expression. Calling <code>eval</code> on an unevaluated expression will evaluate that value. So it means that they’re also a form of data. And we can assign expressions to variables, pass expressions into functions, and create and return new expressions within functions.</p>\n<p><code>&#39;</code> : takes in a single argument and returns an unevaluated version of the argument.<br><code>list</code>: takes in any number of elements and puts each element as a single element in a list.</p>\n<pre class=\" language-scheme\"><code class=\"language-scheme\">scm> <span class=\"token punctuation\">(</span><span class=\"token builtin\">list</span> <span class=\"token string\">'quotient</span> <span class=\"token number\">10</span> <span class=\"token number\">2</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">(</span><span class=\"token function\">quotient</span> <span class=\"token number\">10</span> <span class=\"token number\">2</span><span class=\"token punctuation\">)</span>\nscm> <span class=\"token punctuation\">(</span><span class=\"token builtin\">eval</span> <span class=\"token punctuation\">(</span><span class=\"token builtin\">list</span> <span class=\"token string\">'quotient</span> <span class=\"token number\">10</span> <span class=\"token number\">2</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n<span class=\"token number\">5</span></code></pre>\n<pre class=\" language-scheme\"><code class=\"language-scheme\"><span class=\"token punctuation\">(</span><span class=\"token keyword\">define</span> <span class=\"token punctuation\">(</span><span class=\"token function\">dounle</span> expr<span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">(</span><span class=\"token keyword\">begin</span> <span class=\"token punctuation\">(</span><span class=\"token builtin\">eval</span> expr<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">(</span><span class=\"token builtin\">eval</span> expr<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\nscm> <span class=\"token punctuation\">(</span><span class=\"token function\">double</span> <span class=\"token string\">'</span><span class=\"token punctuation\">(</span><span class=\"token function\">print</span> <span class=\"token number\">2</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n<span class=\"token number\">2</span>\n<span class=\"token number\">2</span></code></pre>\n<pre class=\" language-scheme\"><code class=\"language-scheme\"><span class=\"token punctuation\">(</span><span class=\"token keyword\">define</span> <span class=\"token punctuation\">(</span><span class=\"token function\">dounle</span> expr<span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">(</span><span class=\"token builtin\">list</span> <span class=\"token string\">'begin</span> expr expr<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\nscm> <span class=\"token punctuation\">(</span><span class=\"token builtin\">eval</span>  <span class=\"token punctuation\">(</span><span class=\"token function\">double</span> <span class=\"token string\">'</span><span class=\"token punctuation\">(</span><span class=\"token function\">print</span> <span class=\"token number\">2</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n<span class=\"token number\">2</span>\n<span class=\"token number\">2</span></code></pre>\n<p><code>Macros</code> are a more convenient way to transform or create expressions. The <code>define-macro</code> special form will create a macro procedure. Macros take in and return expressions, which are then evaluated <strong>in place of</strong> the call to the macro.</p>\n<pre class=\" language-scheme\"><code class=\"language-scheme\"><span class=\"token punctuation\">(</span><span class=\"token keyword\">define</span>-macro <span class=\"token punctuation\">(</span><span class=\"token function\">twice</span> expr<span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">(</span><span class=\"token builtin\">list</span> <span class=\"token string\">'begin</span> expr expr<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\nscm> <span class=\"token punctuation\">(</span><span class=\"token function\">twice</span> <span class=\"token punctuation\">(</span><span class=\"token function\">print</span> <span class=\"token number\">2</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token comment\" spellcheck=\"true\">;Equivalent to: (begin (print 2) (print 2))</span>\n<span class=\"token number\">2</span>\n<span class=\"token number\">2</span></code></pre>\n<p><code>begin</code> is a special form takes in any number of expressions, evaluates them in order, and evaluates to the value of the final expression.</p>\n<p><strong>· The evaluation procedure of Macros</strong>:<br>Step.1: Evaluate the operator sub-expression, which evaluates to a macro procedure.<br>Step.2: Apply the macro procedure to the operand expressions <em>without evaluating them first</em>.<br>Step.3: Evaluate the expression returned by the macro procedure in the frame the macro was called in.(must return an unevaluated expression. e.g. a linked list)</p>\n<p>Scheme doesn’t have for loops, but thanks to macros, we can add them.</p>\n<pre class=\" language-scheme\"><code class=\"language-scheme\"><span class=\"token punctuation\">(</span><span class=\"token keyword\">define</span>-macro <span class=\"token punctuation\">(</span><span class=\"token function\">for</span> sym in vals do expr<span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">(</span><span class=\"token builtin\">list</span> <span class=\"token string\">'map</span> <span class=\"token punctuation\">(</span><span class=\"token builtin\">list</span> <span class=\"token string\">'lambda</span> <span class=\"token punctuation\">(</span><span class=\"token builtin\">list</span> sym<span class=\"token punctuation\">)</span> expr<span class=\"token punctuation\">)</span> vals<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n\nscm> <span class=\"token punctuation\">(</span><span class=\"token function\">for</span> x in <span class=\"token string\">'</span><span class=\"token punctuation\">(</span><span class=\"token function\">1</span> <span class=\"token number\">2</span> <span class=\"token number\">3</span> <span class=\"token number\">4</span><span class=\"token punctuation\">)</span> do <span class=\"token punctuation\">(</span><span class=\"token operator\">*</span> x x<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">(</span><span class=\"token function\">1</span> <span class=\"token number\">4</span> <span class=\"token number\">9</span> <span class=\"token number\">16</span><span class=\"token punctuation\">)</span>\nscm> <span class=\"token punctuation\">(</span><span class=\"token function\">map</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">lambda</span> <span class=\"token punctuation\">(</span>x<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">*</span> x x<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token string\">'</span><span class=\"token punctuation\">(</span><span class=\"token function\">1</span> <span class=\"token number\">2</span> <span class=\"token number\">3</span> <span class=\"token number\">4</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">(</span><span class=\"token function\">1</span> <span class=\"token number\">4</span> <span class=\"token number\">9</span> <span class=\"token number\">16</span><span class=\"token punctuation\">)</span></code></pre>\n<pre class=\" language-scheme\"><code class=\"language-scheme\"><span class=\"token punctuation\">(</span><span class=\"token keyword\">define</span>-macro <span class=\"token punctuation\">(</span><span class=\"token function\">for</span> sym vals expr<span class=\"token punctuation\">)</span>\n  `<span class=\"token punctuation\">(</span><span class=\"token function\">map</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">lambda</span> <span class=\"token punctuation\">(</span>,sym<span class=\"token punctuation\">)</span> ,expr<span class=\"token punctuation\">)</span> ,vals<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span></code></pre>\n<p>Quasiquotation allows you to have some parts of a list be read literally and some parts be evaluated.</p>\n<p><strong>`</strong> Short for(quasiquote …), <code>,</code>Short for (unquote …)</p>\n<h3 id=\"Part-6-Streams\">Part.6 Streams<a href=\"post/20200915-Scheme-Basics#Part-6-Streams\"></a></h3><p>Scheme uses streams just like the iterators in Python whose <code>rest</code> is lazily evaluated.</p>\n<pre class=\" language-scheme\"><code class=\"language-scheme\"><span class=\"token punctuation\">(</span><span class=\"token keyword\">define</span> <span class=\"token punctuation\">(</span><span class=\"token function\">ints</span> first<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">(</span><span class=\"token builtin\">cons</span>-stream first\n                 <span class=\"token punctuation\">(</span><span class=\"token function\">ints</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">+</span> first <span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\nscm> <span class=\"token punctuation\">(</span><span class=\"token function\">ints</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">(</span><span class=\"token function\">1</span> . #[promise <span class=\"token punctuation\">(</span><span class=\"token function\">not</span> forced<span class=\"token punctuation\">)</span>]<span class=\"token punctuation\">)</span> <span class=\"token comment\" spellcheck=\"true\">;repesent these expressions are only valuated when we ask.</span>\n\nscm> <span class=\"token punctuation\">(</span><span class=\"token keyword\">define</span> s <span class=\"token punctuation\">(</span><span class=\"token builtin\">cons</span>-stream <span class=\"token number\">1</span> <span class=\"token punctuation\">(</span><span class=\"token builtin\">cons</span>-stream <span class=\"token number\">2</span> nil<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\ns\nscm> s\n<span class=\"token punctuation\">(</span><span class=\"token function\">1</span> . #[promise <span class=\"token punctuation\">(</span><span class=\"token function\">not</span> forced<span class=\"token punctuation\">)</span>]<span class=\"token punctuation\">)</span>\nscm> <span class=\"token punctuation\">(</span><span class=\"token builtin\">cdr</span>-stream s<span class=\"token punctuation\">)</span>           <span class=\"token comment\" spellcheck=\"true\">; cdr-stream forces Scheme to compute the rest.</span>\n<span class=\"token punctuation\">(</span><span class=\"token function\">2</span> . #[promise <span class=\"token punctuation\">(</span><span class=\"token function\">not</span> forced<span class=\"token punctuation\">)</span>]<span class=\"token punctuation\">)</span>\nscm> <span class=\"token punctuation\">(</span><span class=\"token builtin\">cdr</span>-stream <span class=\"token punctuation\">(</span><span class=\"token builtin\">cdr</span>-stream s<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span></code></pre>\n<p><code>promise</code>:  an object that delays evaluation of an expression.<br>The <code>delay</code> special form creates promises.<br>The <code>force</code> procedure evaluates the expression inside the promise</p>\n<pre class=\" language-scheme\"><code class=\"language-scheme\">scm> <span class=\"token punctuation\">(</span><span class=\"token keyword\">define</span> x <span class=\"token punctuation\">(</span><span class=\"token keyword\">delay</span> <span class=\"token punctuation\">(</span><span class=\"token function\">print</span> <span class=\"token number\">5</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\nx\nscm> x\n#[promise <span class=\"token punctuation\">(</span><span class=\"token function\">not</span> forced<span class=\"token punctuation\">)</span>]\nscm> <span class=\"token punctuation\">(</span><span class=\"token function\">force</span> x<span class=\"token punctuation\">)</span>\n<span class=\"token number\">5</span>\nscm> x\n#[promise <span class=\"token punctuation\">(</span>forced<span class=\"token punctuation\">)</span>]</code></pre>\n<p><strong>· Constant Stream</strong></p>\n<p>A constant stream is an infinitely long stream with a number repeated.</p>\n<pre class=\" language-scheme\"><code class=\"language-scheme\"><span class=\"token punctuation\">(</span><span class=\"token keyword\">define</span> <span class=\"token punctuation\">(</span><span class=\"token function\">constant-stream</span> i<span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">(</span><span class=\"token builtin\">cons</span>-stream i <span class=\"token punctuation\">(</span><span class=\"token function\">constant-stream</span> i<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\nscm> <span class=\"token punctuation\">(</span><span class=\"token keyword\">define</span> ones <span class=\"token punctuation\">(</span><span class=\"token function\">constant-stream</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\nscm> <span class=\"token punctuation\">(</span><span class=\"token builtin\">car</span> ones<span class=\"token punctuation\">)</span>\n<span class=\"token number\">1</span>\nscm> <span class=\"token punctuation\">(</span><span class=\"token builtin\">car</span> <span class=\"token punctuation\">(</span><span class=\"token builtin\">cdr</span>-stream ones<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n<span class=\"token number\">1</span></code></pre>\n<p><strong>· Add-Stream and Ints-Stream</strong></p>\n<pre class=\" language-scheme\"><code class=\"language-scheme\"><span class=\"token punctuation\">(</span><span class=\"token keyword\">define</span> <span class=\"token punctuation\">(</span><span class=\"token function\">add-stream</span> s1 s2<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">(</span><span class=\"token builtin\">cons</span>-stream <span class=\"token punctuation\">(</span><span class=\"token operator\">+</span> <span class=\"token punctuation\">(</span><span class=\"token builtin\">car</span> s1<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">(</span><span class=\"token builtin\">car</span> s2<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n                  <span class=\"token punctuation\">(</span><span class=\"token function\">add-stream</span> <span class=\"token punctuation\">(</span><span class=\"token builtin\">cdr</span>-stream s1<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">(</span><span class=\"token builtin\">cdr</span>-stream s2<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">)</span>\n\n<span class=\"token punctuation\">(</span><span class=\"token keyword\">define</span> ones <span class=\"token punctuation\">(</span><span class=\"token builtin\">cons</span>-stream <span class=\"token number\">1</span> ones<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">(</span><span class=\"token keyword\">define</span> ints <span class=\"token punctuation\">(</span><span class=\"token builtin\">cons</span>-stream <span class=\"token number\">1</span> <span class=\"token punctuation\">(</span><span class=\"token function\">add-stream</span> ones ints<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span></code></pre>\n<h3 id=\"Part-7-Evaluating-Process\">Part.7 Evaluating Process<a href=\"post/20200915-Scheme-Basics#Part-7-Evaluating-Process\"></a></h3><p><strong>Ⅰ. Evaluating primitive expressions</strong></p>\n<p><strong>Self-evaluating expressions</strong>:<br>These expressions evaluate to themselves.</p>\n<p><strong>Symbols</strong>:<br>Look in the current frame for the symbol. If it is found, return the value bound to it.<br>If it is not found in the current frame, look in the parent frame. If it is not found in the parent frame, look in its parent frame, and so on. If the global frame is reached and the name is not found, raise a <code>SchemeError</code>.</p>\n<p><strong>Ⅱ. Evaluating Combinations</strong></p>\n<p>1.Special form</p>\n<p>If the operator is a symbol and is found in the dictionary of special forms, the combination is a special form. Each special form has special rules for evaluation.</p>\n<p>2.Call expression</p>\n<p>Step 1. Evaluate the operator to get a procedure.<br>Step 2. Evaluate all of the operands from left to right.<br>Step 3. Apply the procedure to the values of the operands.</p>\n<p>A <strong>built-in procedure</strong> is a procedure that is predefined in our Scheme interpreter, e.g. <code>+, list, modulo</code>, etc.</p>\n<p>A <strong>user-defined procedure</strong> is a procedure defined by the user, either with a lambda expression or a define expression.<br><strong>· Applying user-defined procedures:</strong><br>Step 1. Open a new frame whose parent is the parent frame of the procedure being applied.<br>Step 2. Bind the formal parameters of the procedure to the arguments in the new frame.<br>Step 3. Evaluate the body of the procedure in the new frame.</p>\n<img src=\"https://i.loli.net/2020/09/15/ti4eSyWaPGkjupI.png\" alt=\"11\" style=\"zoom: 67%;\">\n\n<p>​                                                            （from CS61A Summer 2019 at UCB）</p>\n","prev":{"title":"SQL Basics","slug":"20200916-SQL-Basics"},"next":{"title":"Programs Basics 01","slug":"20200910-Programs-Basics-01"},"link":"https://oreodu.github.io/post/20200915-Scheme-Basics/","toc":[{"title":"Scheme Basics","id":"Scheme-Basics","index":"1"}],"reward":true,"copyright":{"author":null,"link":"<a href=\"https://oreodu.github.io/post/20200915-Scheme-Basics/\" title=\"Scheme Basics\">https://oreodu.github.io/post/20200915-Scheme-Basics/</a>","license":"Attribution-NonCommercial-NoDerivatives 4.0 International (<a href=\"https://creativecommons.org/licenses/by-nc-sa/4.0/\" rel=\"external nofollow noopener\" target=\"_blank\">CC BY-NC-ND 4.0</a>)"}}