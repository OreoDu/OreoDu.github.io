{"title":"Union Find","date":"2020-10-05T00:55:00.000Z","slug":"20201005-Union-Find","comments":true,"categories":["Data Structure"],"updated":"2020-10-05T00:57:23.896Z","content":"<h1 id=\"Union-Find\">Union-Find<a href=\"post/20201005-Union-Find#Union-Find\"></a></h1><h3 id=\"Overview\">Overview<a href=\"post/20201005-Union-Find#Overview\"></a></h3><p>(概略图)</p>\n<p><strong>· materials:</strong><br>  · Wikipedia</p>\n<h4 id><a href=\"post/20201005-Union-Find#\"></a></h4><p>A  disjoint-set data structure is a data structure that keeps track of a set of elements partitioned into a number of disjoint (non-overlapping) subsets. </p>\n<p>A  union-find algorithm is an algorithm that performs two useful operations on such a data structure:<br>· Find: Determine which subset a particular element is in. Used to check if two elements are in the same subset.<br>· Union: Join two subsets into a single subset.</p>\n<h2 id=\"Part-1-Quik-Find-eager-approach\">Part.1 Quik-Find (eager approach)<a href=\"post/20201005-Union-Find#Part-1-Quik-Find-eager-approach\"></a></h2><p>Data structure: Integer array id[] of length N<br>Interpretation: <em>p</em> and <em>q</em> are connected iff they have the same id.<img src=\"https://i.loli.net/2020/09/25/4fotqNvk6Klr8R9.png\" alt=\"1\" style=\"zoom:50%;\">     <img src=\"https://i.loli.net/2020/09/25/HDLj7Pg83npwJVG.png\" alt=\"2\" style=\"zoom: 33%;\"></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">QuickFind</span> </span>&#123;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">int</span>[] id;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">QuickFind</span><span class=\"params\">(<span class=\"keyword\">int</span> N)</span> </span>&#123;</span><br><span class=\"line\">    id  = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[N];</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; N; i++) &#123;</span><br><span class=\"line\">      id[i] = i;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">connected</span><span class=\"params\">(<span class=\"keyword\">int</span> p, <span class=\"keyword\">int</span> q)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> id[p] == id[q];</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"comment\">//change all entries whose id equals id[p] to id[q].</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">union</span><span class=\"params\">(<span class=\"keyword\">int</span> p,<span class=\"keyword\">int</span> q)</span> </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">int</span> pid = id[p];</span><br><span class=\"line\">      <span class=\"keyword\">int</span> qid = id[q];</span><br><span class=\"line\">      <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i&lt;id.length; i++)</span><br><span class=\"line\">          <span class=\"keyword\">if</span> (id[i] == pid) id[i] = qid;</span><br><span class=\"line\">  &#125; </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Part-2-Quik-Union-lazy-approach\">Part.2  Quik-Union (lazy approach)<a href=\"post/20201005-Union-Find#Part-2-Quik-Union-lazy-approach\"></a></h2><p>Data structure: Integer array id[] of length N<br>Interpretation: id[i] is the parent of i.</p>\n<div class=\"article-img\"><p><img src=\"https://i.loli.net/2020/09/25/CxwA365cELkj9pN.png\" alt=\"3\" style=\"zoom:50%;\" data-zoomable>        <img src=\"https://i.loli.net/2020/09/25/zYEd4WNAnvfsIyc.png\" alt=\"4\" style=\"zoom:33%;\" data-zoomable></p></div>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">QuickUnion</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span>[] id;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">QuickUnion</span><span class=\"params\">(<span class=\"keyword\">int</span> N)</span> </span>&#123;</span><br><span class=\"line\">        id  = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[N];</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i&lt;N; i++) id[i] = i;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">int</span> <span class=\"title\">root</span><span class=\"params\">(<span class=\"keyword\">int</span> p)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(p!=id[p]) p = id[p];</span><br><span class=\"line\">        <span class=\"keyword\">return</span> p;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">connected</span><span class=\"params\">(<span class=\"keyword\">int</span> p, <span class=\"keyword\">int</span> q)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> root(p) == root(q);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// set the id of p's root to the id of q's root.</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">union</span><span class=\"params\">(<span class=\"keyword\">int</span> p, <span class=\"keyword\">int</span> q)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> pr = root(p);</span><br><span class=\"line\">        <span class=\"keyword\">int</span> qr = root(q);</span><br><span class=\"line\">        id[pr] = qr;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Part-3-Improvement-Weighed-quick-union\">Part.3 Improvement: Weighed quick union<a href=\"post/20201005-Union-Find#Part-3-Improvement-Weighed-quick-union\"></a></h2><p>In order to avoid tall trees, we can keep track of the <em>size</em> of each tree and balance by linking root of smaller tree to root of larger tree.</p>\n<p>Data structure: Integer array id[] of length N and extra helper array size[].</p>\n<div class=\"article-img\"><p><img src=\"https://i.loli.net/2020/09/25/n2XLPSoFVrMQwq7.png\" alt=\"6\" style=\"zoom:50%;\" data-zoomable>          <img src=\"https://i.loli.net/2020/09/25/t8GTg5mU2w6oIYA.png\" alt=\"5\" style=\"zoom: 25%;\" data-zoomable></p></div>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Only need to change the union method</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">union</span><span class=\"params\">(<span class=\"keyword\">int</span> p, <span class=\"keyword\">int</span> q)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> pr = root(p);</span><br><span class=\"line\">        <span class=\"keyword\">int</span> qr = root(q);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (pr == qr) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (size[pr]&lt;size[qr]) &#123;</span><br><span class=\"line\">            id[pr] = qr;</span><br><span class=\"line\">            size[qr] += size[pr];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            id[qr] = pr;</span><br><span class=\"line\">            size[pr] += size[qr];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n<p>We can also link the root based on the rank(or height). But tracking the size is better.</p>\n<img src=\"https://i.loli.net/2020/09/25/DgFo2cv6utdXqMO.jpg\" alt=\"12\" style=\"zoom: 25%;\">\n\n<h2 id=\"Part-4-Improvement-path-compression\">Part.4 Improvement: path compression<a href=\"post/20201005-Union-Find#Part-4-Improvement-path-compression\"></a></h2><p>In order to reduce the height of the trees, we can update the parent of the node to the root we found.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Only need to change the root method.</span></span><br><span class=\"line\"><span class=\"comment\">//add second loop to root() to set the id[] of each examined node to the root.</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">int</span> <span class=\"title\">root</span><span class=\"params\">(<span class=\"keyword\">int</span> p)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> r = p;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(r!=id[r]) r = id[r];</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(p!= id[p])&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> tmp = id[p];</span><br><span class=\"line\">        id[p] = r;</span><br><span class=\"line\">        p = tmp;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> r;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Make every other node in path point to its grandparent</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">int</span> <span class=\"title\">root</span><span class=\"params\">(<span class=\"keyword\">int</span> p)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(p!=id[p])&#123;</span><br><span class=\"line\">        id[p] = id[id[p]];</span><br><span class=\"line\">        p = id[p];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> p;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"Analysis-of-running-time\">Analysis of running time:<a href=\"post/20201005-Union-Find#Analysis-of-running-time\"></a></h4><p>(lg* : times you take logN to get one)</p>\n<img src=\"https://i.loli.net/2020/09/25/L6xFqZDORv8lkrP.png\" alt=\"122\" style=\"zoom:50%;\">\n\n<h4 id=\"Union-Find-Application\">Union Find Application<a href=\"post/20201005-Union-Find#Union-Find-Application\"></a></h4><p>· Percolation.<br>· Games (Go, Hex).<br>· Dynamic connectivity.<br>· Least common ancestor.<br>· Equivalence of finite state automata.<br>· Hinley-Milner polymorphic type inference.<br>· Kruskal’s minimum spanning tree algorithm.<br>· Compiling equivalence statements in Fortran.<br>· Morphological attribute openings and closings.<br>· Matlab’s bwlabel() function in image processing.</p>\n","next":{"title":"Tree","slug":"20201005-Tree"},"link":"https://oreodu.github.io/post/20201005-Union-Find/","toc":[{"title":"Union-Find","id":"Union-Find","index":"1","children":[{"title":"Part.1 Quik-Find (eager approach)","id":"Part-1-Quik-Find-eager-approach","index":"1.1"},{"title":"Part.2  Quik-Union (lazy approach)","id":"Part-2-Quik-Union-lazy-approach","index":"1.2"},{"title":"Part.3 Improvement: Weighed quick union","id":"Part-3-Improvement-Weighed-quick-union","index":"1.3"},{"title":"Part.4 Improvement: path compression","id":"Part-4-Improvement-path-compression","index":"1.4"}]}],"reward":true,"copyright":{"author":"Oreo Du","link":"<a href=\"https://oreodu.github.io/post/20201005-Union-Find/\" title=\"Union Find\">https://oreodu.github.io/post/20201005-Union-Find/</a>","license":"Attribution-NonCommercial-NoDerivatives 4.0 International (<a href=\"https://creativecommons.org/licenses/by-nc-sa/4.0/\" rel=\"external nofollow noopener\" target=\"_blank\">CC BY-NC-ND 4.0</a>)"}}