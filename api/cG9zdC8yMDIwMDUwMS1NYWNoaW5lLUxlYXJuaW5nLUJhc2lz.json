{"title":"Basis & Regression & Classification","date":"2020-05-01T07:45:00.000Z","thumbnail":"https://i.loli.net/2020/09/09/HXeSE32DNiUcPfl.jpg","slug":"20200501-Machine-Learning-Basis","tags":["Machine Lesarning Basis"],"categories":["Machine Lerning"],"updated":"2020-09-09T09:11:15.294Z","content":"<h1 id=\"Basis-amp-Regression-amp-Classification\">Basis &amp; Regression &amp; Classification<a href=\"post/20200501-Machine-Learning-Basis#Basis-amp-Regression-amp-Classification\"></a></h1><h3 id=\"Overview\">Overview<a href=\"post/20200501-Machine-Learning-Basis#Overview\"></a></h3><p>(概略图)</p>\n<p><strong>· materials:</strong></p>\n<p>  · Wikipedia</p>\n<p>  · Machine Learning </p>\n<h2 id=\"1-Intro\">1. Intro<a href=\"post/20200501-Machine-Learning-Basis#1-Intro\"></a></h2><p>Tom Mitchell provides a more modern definition: “A computer program is said to learn from experience E with respect to some class of tasks T and performance measure P, if its performance at tasks in T, as measured by P, improves with experience E.”</p>\n<h4 id=\"·-Supervised-Learning\">· Supervised Learning<a href=\"post/20200501-Machine-Learning-Basis#·-Supervised-Learning\"></a></h4><p>In supervised learning, we are given a data set and already know what our correct output should look like, having the idea that there is a relationship between the input and the output.</p>\n<p>Supervised learning problems are categorized into <strong>“regression”</strong> and **”classification” ** problems. In a regression problem, we are trying to predict results within a continuous output, meaning that we are trying to map input variables to some continuous function. In a classification problem, we are instead trying to predict results in a discrete output. In other words, we are trying to map input variables into discrete categories.</p>\n<h4 id=\"·-Unsupervised-Learning\">· Unsupervised Learning<a href=\"post/20200501-Machine-Learning-Basis#·-Unsupervised-Learning\"></a></h4><p>Unsupervised learning allows us to approach problems with little or no idea what our results should look like. We can derive structure from data where we don’t necessarily know the effect of the variables.</p>\n<p>We can derive this structure by <strong>clustering</strong> the data based on relationships among the variables in the data.</p>\n<p>With unsupervised learning there is no feedback based on the prediction results.</p>\n<h4 id=\"·-Model\">· Model<a href=\"post/20200501-Machine-Learning-Basis#·-Model\"></a></h4><p>To describe the supervised learning problem slightly more formally, our goal is, given a training set, to learn the hypothesis function h : X → Y so that h(x) is a “good” predictor for the corresponding value of y. </p>\n<p>Inout : X</p>\n<p>Output: Y</p>\n<p>Hypothesis function: h</p>\n<p>Cost function : J</p>\n<p>Objective function: minimize (J)</p>\n<h2 id=\"2-Regression\">2. Regression<a href=\"post/20200501-Machine-Learning-Basis#2-Regression\"></a></h2><h3 id=\"Linear-Regression\">Linear Regression<a href=\"post/20200501-Machine-Learning-Basis#Linear-Regression\"></a></h3><p>$ h_\\theta (x) =  \\theta_1 x + \\theta_0 $</p>\n<h4 id=\"Cost-Function\">Cost Function<a href=\"post/20200501-Machine-Learning-Basis#Cost-Function\"></a></h4><p>We can measure the accuracy of our hypothesis function by using a <strong>cost function</strong>. </p>\n<p><strong>Mean Squared Error</strong></p>\n<p>$  J(\\theta_0, \\theta_1) =  \\frac{1}{2m} \\sum^{m}_ {i=1} {( h_ \\theta(x^{(i)}) - y^{(i)} )^2} $</p>\n<p>$ J(\\theta_0, \\theta_1) $ can be ploted by a contour figure.</p>\n<h4 id=\"Gradient-descent-minizining-the-cost-function-J\">Gradient descent (minizining the cost function J)<a href=\"post/20200501-Machine-Learning-Basis#Gradient-descent-minizining-the-cost-function-J\"></a></h4><p>$ \\theta_j := \\theta_j - \\alpha \\frac{1}{m} \\sum\\limits_{i=1}^{m} (h_\\theta(x^{(i)}) - y^{(i)}) \\cdot x_j^{(i)} $</p>\n<p>(Update $\\theta_j$ simultaneously)</p>\n<p>learning rate: <strong>α</strong></p>\n<p>we should adjust our parameter <em>α</em> to ensure that the gradient descent algorithm converges in a reasonable time. Failure to converge or too much time to obtain the minimum value imply that our step size is wrong.</p>\n<p>The method looks at every example in the entire training set on every step, and is called <strong>batch gradient descent</strong></p>\n<p><u><a href=\"https://medium.com/@rohitpandey576/why-does-gradient-descent-work-128713588136\" target=\"_blank\" rel=\"noopener\">Why does gradient descent work?</a></u></p>\n<h3 id=\"Multivariate-Linear-Regression\">Multivariate Linear Regression<a href=\"post/20200501-Machine-Learning-Basis#Multivariate-Linear-Regression\"></a></h3><p>Linear regression with multiple variables.</p>\n<p>$ h_\\theta (x) = \\theta_0 + \\theta_1 x_1 + \\theta_2 x_2 + \\theta_3 x_3 + \\cdots + \\theta_n x_n $ </p>\n<p>$ h_\\theta(x) =\\begin{bmatrix}\\theta_0 \\hspace{2em} \\theta_1 \\hspace{2em} … \\hspace{2em} \\theta_n\\end{bmatrix}\\begin{bmatrix}x_0 \\newline x_1 \\newline \\vdots \\newline x_n\\end{bmatrix}= \\theta^T X $</p>\n<p>$ x_{0}^{(i)} =1 \\text{ for } (i\\in { 1,\\dots, m } ) $</p>\n<p>$  J(\\theta) =  \\frac{1}{2m} \\sum^{m}_ {i=1} {( h_ \\theta(x^{(i)}) - y^{(i)} )^2} $</p>\n<h4 id=\"Feature-Scaling\">Feature Scaling<a href=\"post/20200501-Machine-Learning-Basis#Feature-Scaling\"></a></h4><p>We can speed up gradient descent by having each of our input values in roughly the same range. This is because θ will descend quickly on small ranges and slowly on large ranges, and so will oscillate inefficiently down to the optimum when the variables are very uneven.</p>\n<p>Two techniques to help with this are <strong>feature scaling</strong> and <strong>mean normalization</strong>.</p>\n<p>feature scaling : $ x_i = \\frac{x_i}{s_i} $</p>\n<p>mean normalization : $ x_i = \\frac{x_i - \\mu_i}{s_i} $ </p>\n<p>($ s_i $:  standard deviation , $ \\mu_i $: average)</p>\n<h4 id=\"Gradient-descent\">Gradient descent<a href=\"post/20200501-Machine-Learning-Basis#Gradient-descent\"></a></h4><p>$ \\theta_j := \\theta_j - \\alpha \\frac{1}{m} \\sum\\limits_{i=1}^{m} (h_\\theta(x^{(i)}) - y^{(i)}) \\cdot x_j^{(i)} $</p>\n<p><strong>Debugging gradient descent.</strong> </p>\n<p>Make a plot with <em>number of iterations</em> and cost function J(θ).  It has been proven that if learning rate α is sufficiently small, then J(θ) will decrease on every iteration. </p>\n<p>If <em>α</em> is too small: slow convergence.</p>\n<p>If <em>α</em> is too large: may not decrease on every iteration and thus may not converge.</p>\n<p>(Try like this: … 0.001 … 0.01 … 0.1 … 1)</p>\n<h4 id=\"Normal-Equation\">Normal Equation<a href=\"post/20200501-Machine-Learning-Basis#Normal-Equation\"></a></h4><p>Normal Equation is a second way of minimizing J.</p>\n<p> In the “Normal Equation” method, we will minimize J by explicitly taking its derivatives with respect to the θj ’s, and setting them to zero. This allows us to find the optimum theta without iteration. </p>\n<p>$ \\theta =( X_T  X)^{-1}X_TY  $</p>\n<div class=\"article-bounded\"><div class=\"article-table\"><table>\n<thead>\n<tr>\n<th>Gradient Descent</th>\n<th><strong>Normal Equation</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Need to choose alpha</td>\n<td>No need to choose alpha</td>\n</tr>\n<tr>\n<td>Needs many iterations</td>\n<td>No need to iterate</td>\n</tr>\n<tr>\n<td>$ O(kn^2)$</td>\n<td>$ O(n^3)$, need to calculate inverse of $ X^TX $</td>\n</tr>\n<tr>\n<td>Works well when n is large</td>\n<td>Slow if n is very large</td>\n</tr>\n</tbody></table></div></div>\n<p>If $ X^TX $ is <strong>noninvertible,</strong> the common causes might be having :</p>\n<p><strong>·</strong> Redundant features, where two features are very closely related (i.e. they are linearly dependent)<br><strong>·</strong> Too many features (e.g. m ≤ n). In this case, delete some features or use “regularization”.</p>\n<h3 id=\"Polynomial-Regression\">Polynomial Regression<a href=\"post/20200501-Machine-Learning-Basis#Polynomial-Regression\"></a></h3><p>We can <strong>change the behavior or curve</strong> of our hypothesis function by making it a quadratic, cubic or square root function (or any other form).</p>\n<p>e.g.  $ h_\\theta (x) = \\theta_0 + \\theta_1 x + \\theta_2 x^2 + \\theta_3 x^3 $</p>\n<p>( if you choose your features this way then feature scaling becomes very important. $ 10^3 = 1000 $)</p>\n<p>Feature choosing: We can <strong>combine</strong> multiple features into one. </p>\n<h2 id=\"3-Classification-Logistic-regression\">3. Classification(Logistic regression)<a href=\"post/20200501-Machine-Learning-Basis#3-Classification-Logistic-regression\"></a></h2><h3 id=\"Binary-classification\">Binary classification<a href=\"post/20200501-Machine-Learning-Basis#Binary-classification\"></a></h3><h4 id=\"Activiation-Fuction\">Activiation Fuction<a href=\"post/20200501-Machine-Learning-Basis#Activiation-Fuction\"></a></h4><p>The activation Function of the output layer depend on the specific problems. </p>\n<p>For example: Binary classification — sigmoid function, Multiple Classification — softmax function, Regression — identity function</p>\n<p><strong>· Sigmoid Function</strong> (maps any real number to the (0, 1) interval)</p>\n<p>$ h_\\theta (x) = g(\\theta^T x) = \\dfrac{1}{1 + e^{- \\theta^T x}} $</p>\n<p>$ h_\\theta(x) = P(y=1 | x ; \\theta) = 1 - P(y=0 | x ; \\theta) $</p>\n<p><strong>Decision Boundary</strong> (The property of the Hypothesis function)</p>\n<p>$ h_\\theta(x) = g(\\theta^T x) \\geq 0.5     when \\theta^T x \\geq 0 $</p>\n<p>Non-linear decision boundary : $ \\theta^T x = \\theta_0 + \\theta_1 x + \\theta_2 x^2 + \\theta_3 x^3 $ </p>\n<h4 id=\"Cost-function\">Cost function<a href=\"post/20200501-Machine-Learning-Basis#Cost-function\"></a></h4><p>We cannot use the same cost function that we use for linear regression because the Logistic Function will not be a convex function, causing many local optima.</p>\n<p><strong>Cross Entropy Error</strong></p>\n<p>$ J(\\theta) = \\dfrac{1}{m} \\sum_ {i=1}^m \\mathrm{Cost}(h_\\theta(x^{(i)}),y^{(i)}) $</p>\n<p>$ Cost (h_ \\theta(x^{(i)}),y^{(i)}) = -y^{(i)} \\log(h_ \\theta(x^{(i)}))  - (1- y^{(i)}) \\log(1-h_ \\theta(x^{(i)}))  $</p>\n<p>$ \\mathrm{Cost}(h_\\theta(x),y) = 0 \\text{ ,if } h_\\theta(x) = y $</p>\n<p>$ \\mathrm{Cost}(h_ \\theta(x),y) \\rightarrow \\infty \\text{ ,if } y=0 \\mathrm{and}  h_\\theta(x) \\rightarrow 1 $</p>\n<p>$ \\mathrm{Cost}(h_ \\theta(x),y) \\rightarrow \\infty \\text{ ,if } y=1  \\mathrm{and}  h_\\theta(x) \\rightarrow 0 $</p>\n<p>When $ h_ \\theta(x^{(i)}) $ become so small, the value of log will become negative infinity. So in order to avoid such situation, we can add a small value to the $ h_ \\theta(x^{(i)}) $, usually it can be 1e-7.</p>\n<h4 id=\"Gradient-descent-1\">Gradient descent<a href=\"post/20200501-Machine-Learning-Basis#Gradient-descent-1\"></a></h4><p>$ \\theta_j := \\theta_j - \\frac{\\alpha}{m} \\sum_{i=1}^m (h_\\theta(x^{(i)}) - y^{(i)}) x_j^{(i)} $</p>\n<p>  <strong>Advanced Optimization</strong> </p>\n<p> “Conjugate gradient”, “BFGS”, and “L-BFGS” are more sophisticated, faster ways to optimize θ and also no need to manually pick $ \\alpha $ which can be used instead of gradient descent. </p>\n<h3 id=\"Multiple-Classification\">Multiple Classification<a href=\"post/20200501-Machine-Learning-Basis#Multiple-Classification\"></a></h3><p><strong>One-vs-all</strong></p>\n<p>$ h_\\theta^{(i)}(x) = P(y = i | x ; \\theta)   y \\in \\lbrace0, 1 … n\\rbrace$</p>\n<p>$ \\mathrm{prediction} = \\max_i( h_\\theta ^{(i)}(x) ) $</p>\n","prev":{"title":"Neural Networks","slug":"20200516-Neural-Networks"},"next":{"title":"Data Structure","slug":"20200425-Data-Structure"},"link":"https://oreodu.github.io/post/20200501-Machine-Learning-Basis/","toc":[{"title":"Basis &amp; Regression &amp; Classification","id":"Basis-amp-Regression-amp-Classification","index":"1","children":[{"title":"1. Intro","id":"1-Intro","index":"1.1"},{"title":"2. Regression","id":"2-Regression","index":"1.2","children":[{"title":"Linear Regression","id":"Linear-Regression","index":"1.2.1"},{"title":"Multivariate Linear Regression","id":"Multivariate-Linear-Regression","index":"1.2.2"},{"title":"Polynomial Regression","id":"Polynomial-Regression","index":"1.2.3"}]},{"title":"3. Classification(Logistic regression)","id":"3-Classification-Logistic-regression","index":"1.3","children":[{"title":"Binary classification","id":"Binary-classification","index":"1.3.1"},{"title":"Multiple Classification","id":"Multiple-Classification","index":"1.3.2"}]}]}]}