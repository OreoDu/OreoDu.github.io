[{"title":"Trie","date":"2020-12-19T15:53:25.000Z","date_formatted":{"ll":"Dec 19, 2020","L":"12/19/2020","MM-DD":"12-19"},"updated":"2020-12-20T09:58:59.513Z","content":"Trie\n","plink":"https://oreodu.github.io/2020/20201219-Trie/"},{"title":"Synchronization","date":"2020-12-17T13:06:00.000Z","date_formatted":{"ll":"Dec 17, 2020","L":"12/17/2020","MM-DD":"12-17"},"updated":"2020-12-18T00:53:45.274Z","content":"Synchronization\nThe kernel is programmed using the shared memory model  and shared data must be protected against concurrent access.\nPart.1 Atomic Operations\nPart.2 Spin Locks\nPart.3 Semaphores and Mutexes\nPart.4 Other Synchronization Mechanisms\nPart.5 Ordering and Memory Barriers\n","plink":"https://oreodu.github.io/2020/20201217-Synchronization/"},{"title":"Heap","date":"2020-12-09T06:13:00.000Z","date_formatted":{"ll":"Dec 9, 2020","L":"12/09/2020","MM-DD":"12-09"},"updated":"2020-12-09T11:52:35.846Z","content":"Heap\n\n\nOperation\nfind-min\ndelete-min\ninsert\ndecrease-key\nmeld\n\n\n\n\nBinary\nΘ(1)\nΘ(log n)\nO(log n)\nO(log n)\nΘ(n)\n\n\nLeftist\nΘ(1)\nΘ(log n)\nΘ(log n)\nO(log n)\nΘ(log n)\n\n\nBinomial\nΘ(1)\nΘ(log n)\nΘ(1)[c]\nΘ(log n)\nO(log n)\n\n\nFibonacci\nΘ(1)\nO(log n)\nΘ(1)\nΘ(1)\nΘ(1)\n\n\nPairing\nΘ(1)\nO(log n)\nΘ(1)\no(log n)\nΘ(1)\n\n\nBrodal\nΘ(1)\nO(log n)\nΘ(1)\nΘ(1)\nΘ(1)\n\n\nRank-pairing\nΘ(1)\nO(log n)\nΘ(1)\nΘ(1)\nΘ(1)\n\n\nStrict Fibonacci]\nΘ(1)\nO(log n)\nΘ(1)\nΘ(1)\nΘ(1)\n\n\n2–3 heap\nO(log n)\nO(log n)\nO(log n)\nΘ(1)\n?\n\n\nPrat.1 Basis\n","plink":"https://oreodu.github.io/2020/2020-12-09-Heap/"},{"title":"Associative array","date":"2020-12-02T15:29:25.000Z","date_formatted":{"ll":"Dec 2, 2020","L":"12/02/2020","MM-DD":"12-02"},"updated":"2020-12-23T10:26:26.049Z","content":"Associative array\nOverview\n(概略图)\n· materials:\n· Algorithms  by Dasgupta, C. H. Papadimitriou, U. V. Vazirani\n· Efficient Algorithms and Intractable Problems  (CS170 2018 Fall at UCB)\n· Algorithm Design by John Kleinberg, Eva Tardos\n· CS61B Spring 2019 at UCB\n· Algorithms, Part I,Ⅱ by Princeton University\n· Wikipedia\nIn many applications, we have to associative a value with a key.\n\nThe associative array (map, symbol table, or dictionary) is an abstract data type composed of a collection of (key, value) pairs, such that each possible key appears at most once in the collection. The client can insert key-value pairs into the symbol table and search for the value associated with a given key later.\nPart.1 API\n123456789public class SymbolTable&lt;Key, Value&gt;  SymbolTable()                // create a symbol table  void put(Key key, Value val) // put key-value pair into the table  void delete(Key key)         // remove key(and its value) from table  void get(Key key)            // get the value paired with the key (null if key is absent)  boolean contains(Key key)    // whether it contains a value paired with the key  boolean isEmpty()            // whether table is empty  int size()                   // number of key-value pairs in the table  Iterable&lt;key&gt; keys()         // all the keys in the table\nAs for ordered symbol tables where keys are Comparable:\n12345678910111213141516171819public class SymbolTable&lt;Key&lt;extends COmparable&lt;Key&gt;&gt;, Value&gt;  SymbolTable()                // create a symbol table  void put(Key key, Value val) // put key-value pair into the table  void delete(Key key)         // remove key(and its value) from table  void get(Key key)            // get the value paired with the key (null if key is absent)  boolean contains(Key key)    // whether it contains a value paired with the key  boolean isEmpty()            // whether table is empty  int size()                   // number of key-value pairs in the table  Key min()                    // smallest key  Key max()                    // largest key  Key floor(Key key)           // the largest key which is smaller than the key  Key ceiling(Key key)         // the smallest key which is gretaer than the key  int rank(Key key)            // number of keys that is strictly less than the key  Key select(int k)            // key of rank k  void deleteMin()             // delete the smallest key  void deleteMax()             // delete the largest key  int size(Key lo, Key hi)     // number of keys in[lo...hi]  Iterable&lt;Key&gt; keys(Key lo, Key hi)  // keys in [lo...hi] with sorted order  Iterable&lt;Key&gt; keys()         // all keys in the table with sorted order\n123456789101112131415161718192021222324252627282930313233343536// Client examplepublic class FrequencyCounter &#123;      private FrequencyCounter() &#123; &#125;    public static void main(String[] args) &#123;        int distinct = 0, words = 0;        int minlen = Integer.parseInt(args[0]);        ST&lt;String, Integer&gt; st = new ST&lt;String, Integer&gt;();        // compute frequency counts        while (!StdIn.isEmpty()) &#123;            String key = StdIn.readString();            if (key.length() &lt; minlen) continue;            words++;            if (st.contains(key)) &#123;                st.put(key, st.get(key) + 1);            &#125;            else &#123;                st.put(key, 1);                distinct++;            &#125;        &#125;        // find a key with the highest frequency count        String max = &quot;&quot;;        st.put(max, 0);        for (String word : st.keys()) &#123;            if (st.get(word) &gt; st.get(max))                max = word;        &#125;        StdOut.println(max + &quot; &quot; + st.get(max));        StdOut.println(&quot;distinct = &quot; + distinct);        StdOut.println(&quot;words    = &quot; + words);    &#125;&#125;\nPart.2 Implementations\nSequential search in an unordered linked list.\n1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192public class SequentialSearchST&lt;Key, Value&gt; &#123;    private int n;    private Node first;    private class Node &#123;        private Key key;        private Value val;        private Node next;        public Node(Key key, Value val, Node next) &#123;            this.key = key;            this.val = val;            this.next = next;        &#125;    &#125;    public SequentialSearchST() &#123;    &#125;    public int size() &#123;        return n;    &#125;    public boolean isEmpty() &#123;        return size() == 0;    &#125;    public boolean contains(Key key) &#123;        if (key == null) throw new IllegalArgumentException(&quot;arguement to contains() is null&quot;);        return get(key) != null;    &#125;    public Value get(Key key) &#123;        if (key == null) throw new IllegalArgumentException(&quot;argument to get() is null&quot;);        for (Node x = first; x != null; x = x.next) &#123;            if (key.equals(x.key)) return x.val;        &#125;        return null;    &#125;    public void put(Key key, Value val) &#123;        if (key == null) throw new IllegalArgumentException(&quot;first argument to put() is null&quot;);        if (val == null) &#123;            delete(key);            return;        &#125;        for (Node x = first; x != null; x = x.next) &#123;            if (key.equals(x.key)) &#123;                x.val = val;                return;            &#125;        &#125;        first = new Node(key, val, first);        n++;    &#125;    public void delete(Key key) &#123;        if (key == null) throw new IllegalArgumentException(&quot;Arguement to delete() is null&quot;);        if (first == null) return;        if (key.equals(first.key)) first = first.next;        for (Node x = first; x.next != null; x = x.next) &#123;            if (key.equals(x.next.key)) &#123;                x.next = x.next.next;                n--;                return;            &#125;        &#125;    &#125;    public Iterable&lt;Key&gt; keys() &#123;        Queue&lt;Key&gt; queue = new ArrayDeque&lt;&gt;();        for (Node x = first; x != null; x = x.next)            queue.add(x.key);        return queue;    &#125;    public static void main(String[] args) &#123;        SequentialSearchST&lt;String, Integer&gt; st = new SequentialSearchST&lt;String, Integer&gt;();        st.put(&quot;w&quot;, 1);        st.put(&quot;a&quot;, 2);        st.put(&quot;e&quot;, 3);        st.delete(&quot;a&quot;);        System.out.println(st.size());        for (String s : st.keys()) &#123;            System.out.println(s + &quot; &quot; + st.get(s));        &#125;    &#125;&#125;\nUnsuccessful search and insert in an (unordered) linked-list symbol table both use N compares, and successful search uses N compares in the worst case.\nIn particular, inserting N keys into an initially empty linked-list symbol table uses ~N^2/2 compares.\nBinary search in an ordered array\nThe underlying data structure is two parallel array, with the keys kept in order.\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217public class BinarySearchST&lt;Key extends Comparable&lt;Key&gt;, Value&gt; &#123;    private static final int INIT_CAPACITY = 2;    private Key[] keys;    private Value[] vals;    private int n = 0;    public BinarySearchST() &#123;        this(INIT_CAPACITY);    &#125;    public BinarySearchST(int capacity) &#123;        keys = (Key[]) new Comparable[capacity];        vals = (Value[]) new Object[capacity];    &#125;    private void resize(int capacity) &#123;        assert capacity &gt;= n;        Key[] tempk = (Key[]) new Comparable[capacity];        Value[] tempv = (Value[]) new Object[capacity];        for (int i = 0; i &lt; n; i++) &#123;            tempk[i] = keys[i];            tempv[i] = vals[i];        &#125;        vals = tempv;        keys = tempk;    &#125;    public int size() &#123;        return n;    &#125;    public boolean isEmpty() &#123;        return size() == 0;    &#125;    public boolean contains(Key key) &#123;        if (key == null) throw new IllegalArgumentException(&quot;argument to contains() is null&quot;);        return get(key) != null;    &#125;    public Value get(Key key) &#123;        if (key == null) throw new IllegalArgumentException(&quot;argument to get() is null&quot;);        if (isEmpty()) return null;        int i = rank(key);        if (i &lt; n &amp;&amp; keys[i].compareTo(key) == 0) return vals[i];        return null;    &#125;    public int rank(Key key) &#123;        if (key == null) throw new IllegalArgumentException(&quot;argument to rank() is null&quot;);        int lo = 0, hi = n - 1;        while (lo &lt;= hi) &#123;            int mid  = (lo + hi) / 2;            int cmp = key.compareTo(keys[mid]);            if (cmp &lt; 0) hi = mid - 1;            else if (cmp &gt; 0) lo = mid + 1;            else return mid;        &#125;        return lo;    &#125;    public void put(Key key, Value val) &#123;        if (key == null) throw new IllegalArgumentException(&quot;first argument to put() is null&quot;);        if (val == null) &#123;            delete(key);            return;        &#125;        int i = rank(key);        if (i &lt; n &amp;&amp; keys[i].compareTo(key) == 0) &#123;            vals[i] = val;            return;        &#125;        if (n == keys.length) resize(2 * keys.length);        for (int j = n; j &gt; i; j--) &#123;            keys[j] = keys[j - 1];            vals[j] = vals[j - 1];        &#125;        keys[i] = key;        vals[i] = val;        n++;        assert check();    &#125;    public void delete(Key key) &#123;        if (key == null) throw new IllegalArgumentException(&quot;argument to delete is null&quot;);        if (isEmpty()) return;        int i = rank(key);        if (i == n || keys[i].compareTo(key) != 0) return;        for (int j = i; j &lt; n - 1; j++) &#123;            keys[j] = keys[j + 1];            vals[j] = vals[j + 1];        &#125;        n--;        keys[n] = null;        keys[n] = null;        if (n &gt; 0 &amp;&amp; n == keys.length / 4) resize(keys.length / 2);        assert check();    &#125;    public void deleteMin() &#123;        if (isEmpty()) throw new NoSuchElementException(&quot;Symbol table underflow error&quot;);        delete(min());    &#125;    public void deleteMax() &#123;        if (isEmpty()) throw new NoSuchElementException(&quot;Symbol table underflow error&quot;);        delete(max());    &#125;    /***************************************************************************     *  Ordered symbol table methods.     ***************************************************************************/    public Key max() &#123;        if (isEmpty()) throw new NoSuchElementException(&quot;called max() with empty symbol table&quot;);        return keys[n - 1];    &#125;    public Key min() &#123;        if (isEmpty()) throw new NoSuchElementException(&quot;called min() with empty symbol table&quot;);        return keys[0];    &#125;    public Key select(int k) &#123;        if (k &lt; 0 || k &gt;= size()) throw new IllegalArgumentException(&quot;called select() with invalid argument: &quot; + k);        return keys[k];    &#125;    public Key floor(Key key) &#123;        if (key == null) throw new IllegalArgumentException(&quot;argument to floor() is null&quot;);        int i = rank(key);        if (i &lt; n &amp;&amp; key.compareTo(keys[i]) == 0) return keys[i];        if (i == 0) return null;        else return keys[i - 1];    &#125;    public Key ceiling(Key key) &#123;        if (key == null) throw new IllegalArgumentException(&quot;argument to ceiling() is null&quot;);        int i = rank(key);        if (i == n) return null;        else return keys[i];    &#125;    public int size(Key lo, Key hi) &#123;        if (lo == null) throw new IllegalArgumentException(&quot;first argument to size() is null&quot;);        if (hi == null) throw new IllegalArgumentException(&quot;decond argument to size() is null&quot;);        if (lo.compareTo(hi) &gt; 0) return 0;        if (contains(hi)) return rank(hi) - rank(lo) + 1;        else return rank(hi) - rank(lo);    &#125;    public Iterable&lt;Key&gt; keys() &#123;        return keys(min(), max());    &#125;    public Iterable&lt;Key&gt; keys(Key lo, Key hi) &#123;        if (lo == null) throw new IllegalArgumentException(&quot;first argument to keys() is null&quot;);        if (hi == null) throw new IllegalArgumentException(&quot;second argument to keys() is null&quot;);        Queue&lt;Key&gt; queue = new ArrayDeque&lt;&gt;();        if (lo.compareTo(hi) &gt; 0) return queue;        for (int i = rank(lo); i &lt; rank(hi); i++) queue.add(keys[i]);        if (contains(hi)) queue.add(keys[rank(hi)]);        return queue;    &#125;    /***************************************************************************     *  Check internal invariants.     ***************************************************************************/    private boolean check() &#123;        return isSorted() &amp;&amp; rankCheck();    &#125;    private boolean isSorted() &#123;        for (int i = 1; i &lt; size(); i++)            if (keys[i].compareTo(keys[i-1]) &lt; 0) return false;        return true;    &#125;    public boolean rankCheck() &#123;        for (int i = 0; i &lt; size(); i++)            if (i != rank(select(i))) return false;        for (int i = 0; i &lt; size(); i++)            if (keys[i].compareTo(select(rank(keys[i]))) != 0) return false;        return true;    &#125;    public static void main(String[] args) &#123;        BinarySearchST&lt;String, Integer&gt; st = new BinarySearchST&lt;&gt;();        st.put(&quot;w&quot;, 2);        st.put(&quot;e&quot;, 3);        st.put(&quot;y&quot;, 4);        st.put(&quot;q&quot;, 9);        st.put(&quot;o&quot;, 1);        st.put(&quot;k&quot;, 8);        st.put(&quot;p&quot;, 10);        System.out.println(&quot;rank: &quot; + st.rank(&quot;h&quot;));        System.out.println(&quot;select: &quot; + st.select(2));        System.out.println(&quot;floor: &quot; + st.floor(&quot;m&quot;));        System.out.println(&quot;Ceiling: &quot; + st.ceiling(&quot;k&quot;));        st.delete(&quot;p&quot;);        st.deleteMin();        st.deleteMax();        for (String s: st.keys(&quot;i&quot;,&quot;z&quot;)) &#123;            System.out.println(s + &quot; &quot; + st.get(s));        &#125;    &#125;&#125;\nInserting a new key into an ordered array uses ~ 2N array accesses in the worst case, so inserting N keys into an initially empty table uses ~ N^2 array accesses in the worst case.\n\nBinary search trees\nSee more details about binary search tree here.\nWe implement the symbol-table in  a way that combines the flexibility of insertion in linked lists with the efficiency of search in an ordered array.\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338package DataStructure;import java.util.ArrayList;import java.util.LinkedList;import java.util.NoSuchElementException;import java.util.Queue;public class BST&lt;Key extends Comparable, Value&gt; &#123;    private Node root;    private class Node &#123;        private Key key;        private Value val;        private Node left, right;        private int size;  // number of nodes in subtree        public Node(Key key, Value val, int size) &#123;            this.key = key;            this.val = val;            this.size = size;        &#125;    &#125;    public BST() &#123;&#125;    public boolean isEmpty() &#123;        return size() == 0;    &#125;    public int size() &#123;        return size(root);    &#125;    private int size(Node x) &#123;        if (x == null) return 0;        else return x.size;    &#125;    public boolean contains(Key key) &#123;        if (key == null) throw new IllegalArgumentException(&quot;argument to contains() is null&quot;);        return get(key) != null;    &#125;    public Value get(Key key) &#123;        return get(root, key);    &#125;    private Value get(Node x, Key key) &#123;        if (key == null) throw new IllegalArgumentException(&quot;calls get() with a null key&quot;);        if (x == null) return null;        int cmp = key.compareTo(x.key);        if (cmp &lt; 0) return get(x.left, key);        else if (cmp &gt; 0) return get(x.right, key);        else return x.val;    &#125;    public void put(Key key, Value val) &#123;        if(key == null) throw new IllegalArgumentException(&quot;calls to put() with a null key&quot;);        if (val == null) &#123;            delete(key);            return;        &#125;        root = put(root, key, val);        assert check();    &#125;    private Node put(Node x, Key key, Value val) &#123;        if (x == null) return new Node(key, val, 1);        int cmp = key.compareTo(x.key);        if (cmp &lt; 0) x.left = put(x.left, key, val);        else if (cmp &gt; 0) x.right = put(x.right, key, val);        else  x.val = val;        x.size = 1 + size(x.left) + size(x.right);        return x;    &#125;    public void deleteMin() &#123;        if (isEmpty()) throw new NoSuchElementException(&quot;BST unberflow&quot;);        root = deleteMin(root);        assert check();    &#125;    private Node deleteMin(Node x) &#123;        if (x.left == null) return x.right;        x.left = deleteMin(x.left);        x.size = 1 + size(x.left) + size(x.right);        return x;    &#125;    public void deleteMax() &#123;        if (isEmpty()) throw new NoSuchElementException(&quot;BST underflow&quot;);        root = deleteMax(root);        assert check();    &#125;    private Node deleteMax(Node x) &#123;        if (x.right == null) return x.left;        x.right = deleteMax(x.right);        x.size = 1 + size(x.left) + size(x.right);        return x;    &#125;    public void delete(Key key) &#123;        if (key == null) throw new IllegalArgumentException(&quot;calls delete() with a null key&quot;);        root = delete(root, key);    &#125;    private Node delete(Node x, Key key) &#123;        if (x == null) return null;        int cmp = key.compareTo(x.key);        if (cmp &gt; 0) x.right = delete(x.right, key);        else if (cmp &lt; 0) x.left = delete(x.left, key);        else &#123;            if (x.left == null) return x.right;            if (x.right == null) return x.left;            Node t = x;            x = min(t.right);            x.right = deleteMin(t.right);            x.left = t.left;        &#125;        x.size = 1 + size(x.right) + size(x.left);        return x;    &#125;    public Key min() &#123;        if (isEmpty()) throw new NoSuchElementException(&quot;calls min() with empty BST&quot;);        return min(root).key;    &#125;    private Node min(Node x) &#123;        if (x.left == null) return x;        else return min(x.left);    &#125;    public Key max() &#123;        if (isEmpty()) throw new NoSuchElementException(&quot;calls max() with empty BTS&quot;);        return max(root).key;    &#125;    private Node max(Node x) &#123;        if (x.right == null) return x;        else return max(x.right);    &#125;    public Key floor(Key key) &#123;        if (key == null) throw new IllegalArgumentException(&quot;argument to floor is null&quot;);        if (isEmpty()) throw new NoSuchElementException(&quot;calls to floor with empty BST&quot;);        Node x = floor(root, key);        if (x == null) throw new NoSuchElementException(&quot;argument to floor() is too small&quot;);        else return x.key;    &#125;    private Node floor(Node x,Key key) &#123;        if (x == null) return null;        int cmp = key.compareTo(x.key);        if (cmp == 0) return x;        else if (cmp &lt; 0) return floor(x.left, key);        else &#123;            Node t = floor(x.right, key);            if (t != null) return t;            else return x;        &#125;    &#125;    public Key floor2(Key key) &#123;        Key x = floor2(root, key, null);        if (x == null) throw new NoSuchElementException(&quot;argument to floor() is too small&quot;);        else return x;    &#125;    public Key floor2(Node x, Key key, Key best) &#123;        if (x == null) return best;        int cmp = key.compareTo(x.key);        if (cmp &lt; 0) return floor2(x.left, key, best);        else if (cmp &gt; 0) return floor2(x.right, key, x.key);        else return x.key;    &#125;    public Key ceiling(Key key) &#123;        if (key == null) throw new IllegalArgumentException(&quot;argument to ceiling() is null&quot;);        if (isEmpty()) throw new NoSuchElementException(&quot;calls to ceiling() with empty BTS&quot;);        Node x = ceiling(root, key);        if (x == null) throw new NoSuchElementException(&quot;argument to floor() is too large&quot;);        else return x.key;    &#125;    private Node ceiling(Node x, Key key) &#123;        if (x == null) return null;        int cmp = key.compareTo(x.key);        if (cmp == 0) return x;        else if (cmp &gt; 0) return ceiling(x.right, key);        else &#123;            Node t = ceiling(x.left, key);            if (t != null) return t;            else return x;        &#125;    &#125;    public Key select(int rank) &#123;        if (rank &lt; 0 || rank &gt;= size()) &#123;            throw new IllegalArgumentException(&quot;argument to select() is invaild: &quot; + rank);        &#125;        return select(root, rank);    &#125;    private Key select(Node x, int rank) &#123;        if (x == null) return null;        int leftsize = size(x.left);        if (leftsize &gt; rank) return select(x.left, rank);        else if (leftsize &lt; rank) return select(x.right, rank - leftsize - 1);        else return x.key;    &#125;    public int rank(Key key) &#123;        if (key == null) throw new IllegalArgumentException(&quot;argument to rank() is null&quot;);        return rank(key, root);    &#125;    private int rank(Key key, Node x) &#123;        if (x == null) return 0;        int cmp = key.compareTo(x.key);        if (cmp &lt; 0) return rank(key, x.left);        else if (cmp &gt; 0) return 1 + size(x.left) + rank(key, x.right);        else return size(x.left);    &#125;    public Iterable&lt;Key&gt; keys() &#123;        if (isEmpty()) return new ArrayList&lt;Key&gt;();        return keys(min(), max());    &#125;    public Iterable&lt;Key&gt; keys(Key lo, Key hi) &#123;        if (lo == null) throw new IllegalArgumentException(&quot;first argument to keys() is null&quot;);        if (hi == null) throw new IllegalArgumentException(&quot;second argument to keys() is null&quot;);        Queue&lt;Key&gt; queue = new LinkedList&lt;&gt;();        keys(root, queue, lo, hi);        return queue;    &#125;    private void keys(Node x, Queue&lt;Key&gt; queue, Key lo, Key hi) &#123;        if (x == null) return;        int cmplo = lo.compareTo(x.key);        int cmphi = hi.compareTo(x.key);        if (cmplo &lt; 0) keys(x.left, queue, lo, hi);        if (cmplo &lt;= 0 &amp;&amp; cmphi &gt;= 0) queue.add(x.key);        if (cmphi &gt; 0) keys(x.right, queue, lo, hi);    &#125;    public int size(Key lo, Key hi) &#123;        if (lo == null) throw new IllegalArgumentException(&quot;first argument to size() is null&quot;);        if (hi == null) throw new IllegalArgumentException(&quot;second argument to size() is null&quot;);        if (lo.compareTo(hi) &gt; 0) return 0;        if (contains(hi)) return rank(hi) - rank(lo) + 1;        else return rank(hi) - rank(lo);    &#125;    public int height() &#123;        return height(root);    &#125;    private int height(Node x) &#123;        if (x == null) return -1;        return 1 + Math.max(height(x.left), height(x.right));    &#125;    public Iterable&lt;Key&gt; levelorder() &#123;        Queue&lt;Key&gt; keys = new LinkedList&lt;Key&gt;();        Queue&lt;Node&gt; queue = new LinkedList&lt;Node&gt;();        queue.offer(root);        while(!queue.isEmpty()) &#123;            Node x = queue.poll();            if (x == null) continue;            keys.offer(x.key);            queue.offer(x.left);            queue.offer(x.right);        &#125;        return keys;    &#125;    public boolean check() &#123;        if (!isBST()) System.out.println(&quot;Not in symmetric order!&quot;);        if (!isSizeConsistent()) System.out.println(&quot;Subtree counts not consistent!&quot;);        if (!isRankConsistent()) System.out.println(&quot;Ranks not consistent&quot;);        return isBST() &amp;&amp; isSizeConsistent() &amp;&amp; isRankConsistent();    &#125;    private boolean isBST() &#123;return isBST(root, null, null);&#125;    private boolean isBST(Node x, Key min, Key max) &#123;        if (x == null) return true;        if (min != null &amp;&amp; x.key.compareTo(min) &lt;= 0) return false;        if (max != null &amp;&amp; x.key.compareTo(max) &gt;= 0) return false;        return isBST(x.left, min, x.key) &amp;&amp; isBST(x.right, x.key, max);    &#125;    private boolean isSizeConsistent() &#123;return isSizeConsistent(root);&#125;    private boolean isSizeConsistent(Node x) &#123;        if (x == null) return true;        if (x.size != size(x.left) + size(x.right) + 1) return false;        return isSizeConsistent(x.left) &amp;&amp; isSizeConsistent(x.right);    &#125;    private boolean isRankConsistent() &#123;        for (int i = 0; i &lt; size(); i++)            if (i != rank(select(i))) return false;        for (Key key : keys())            if (key.compareTo(select(rank(key))) != 0) return false;        return true;    &#125;    public static void main(String[] args) &#123;        BST&lt;String, Integer&gt; st = new BST&lt;&gt;();        st.put(&quot;J&quot;, 8);        st.put(&quot;A&quot;, 9);        st.put(&quot;S&quot;, 1);        st.put(&quot;B&quot;, 2);        st.put(&quot;K&quot;, 4);        st.put(&quot;L&quot;, 3);        st.put(&quot;Q&quot;, 6);        st.put(&quot;M&quot;, 7);        System.out.println(&quot;The height of the tree is :&quot; + st.height());        System.out.println(&quot;The Ceiling of the key C is :&quot; + st.ceiling(&quot;C&quot;));        System.out.println(&quot;The floor of the key N is :&quot; + st.floor(&quot;N&quot;));        System.out.println(&quot;The rank of the key J is :&quot; + st.rank(&quot;J&quot;));        System.out.println(&quot;Select :&quot; + st.select(4));        st.deleteMax();        st.deleteMin();        for (String s: st.keys()) &#123;            System.out.println(&quot;Key:&quot; + s + &quot;, Value&quot; + st.get(s));        &#125;        System.out.println(&quot;-----&quot;);        for (String s: st.levelorder()) &#123;            System.out.println(&quot;Key:&quot; + s + &quot;, Value&quot; + st.get(s));        &#125;    &#125;&#125;\nPart.3 Applications\n","plink":"https://oreodu.github.io/2020/20201202-Associative-arrays/"},{"title":"Priority Queue","date":"2020-12-02T15:29:25.000Z","date_formatted":{"ll":"Dec 2, 2020","L":"12/02/2020","MM-DD":"12-02"},"updated":"2020-12-11T07:14:59.976Z","content":"Priority Queue\nOverview\n(概略图)\n· materials:\n· Algorithms  by Dasgupta, C. H. Papadimitriou, U. V. Vazirani\n· Efficient Algorithms and Intractable Problems  (CS170 2018 Fall at UCB)\n· Algorithm Design by John Kleinberg, Eva Tardos\n· CS61B Spring 2019 at UCB\n· Algorithms, Part I,Ⅱ by Princeton University\n· Wikipedia\nOften, we collect a set of items, then process the one with the largest key, then perhaps collect more items, then process the one with the current largest key, and so forth. We don’t need to have all keys in full sorted order. Two important operations during the process are insert and remove the maximum.\nAs for many abstract data structure they have limited operations so that they can maintain some features of the data that stored in it and provide some required results more efficiently. So does priority queue. Different from the stack(remove the item most recently added) or queue(remove the item least recently added), priority queue can remove the element based on the priority (Max: the largest item, Min: the smallest item) and also insert items in a very efficient way.\n\nPart.1 API for priority queue\n12345678910111213// the key in the priority queue must be Comparable and immutablepublic class MaxPQ&lt;key extends Comparable&lt;Key&gt;&gt;  MaxPQ()                   // create an empty priority queue  MaxPQ(Comparator&lt;Key&gt; comparator)   MaxPQ(int capacity)       // create a priority of initial capacity  MaxPQ(int capacity, Comparator&lt;Key&gt; comparator)  MaxPQ(Key[] a)            // create a priority with given keys  void insert(key v)        // insert a key into the priority queue  Key delete(int i)         // delete the arbitary value in the pq with index i   Key delMax()              // return and remove the largest key  Key max()                 // return the largest key  boolean isEmpty()         // is the priority quque empty  int size()                // number of entries in the priority queue\n1234567891011// Clientpublic static void main(String[] args) &#123;  MinPQ&lt;Transaction&gt; pq = new MinPQ&lt;Transaction&gt;();  while (StdIn.hasNextLine()) &#123;    String line = StdIn.readLine();    Transaction item = new Transaction(line);    pq.insert(item);    if (pq.size() &gt; M)      pq.delMin();  &#125;&#125;\nPart.2 Implementations\nAttention: The key in the priority queue should be immutable!\n\n1. Unordered or ordered array implementation\n\n12345678910111213141516171819202122232425public class UnorderedMaxPQ&lt;Key extends Comparable&lt;Key&gt;&gt; &#123;  private Key[] pq;  private int N;     // number of the pq    public UnorderedMaxPQ(int capacity) &#123;    pq = (Key[] new Comparable[capacity];)  &#125;    public boolean isEmpty() &#123;    return N == 0;  &#125;    public void insert(Key x) &#123;    pq[N++] = x;  &#125;    public Key delMax() &#123;    int max = 0;    for (int i = 1; i &lt; N; i++) &#123;      if (less(max,i)) max = i;    &#125;    exch(max, N - 1);    return pq[--N];  &#125;&#125;\nSee ordered max priority queue code here.\nExcept array, we can also use linked list(unordered and reverse-ordered) to store the data.\nAll of the elementary implementations just discussed have the property that either the insert or the remove the maximum operation takes linear time in the worst case.\n2. Binary heap\n\nWe can see the implementations of binary heap and more details here.\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179package DataStructure;import java.util.Comparator;import java.util.Iterator;import java.util.NoSuchElementException;public class MaxPQ&lt;Key extends Comparable&lt;Key&gt;&gt; implements Iterable&lt;Key&gt;&#123;    private Key[] pq;    public int N = 0;    private static final int REFACTOR = 2;    private Comparator&lt;Key&gt; comparator;  // optional comparator    public MaxPQ() &#123;        this(1);    &#125;    public MaxPQ(Comparator&lt;Key&gt; comparator) &#123;        this(1, comparator);    &#125;    public MaxPQ(int capacity) &#123;        pq = (Key[]) new Comparable[capacity + 1];    &#125;    public MaxPQ(int capacity, Comparator&lt;Key&gt; comparator) &#123;        this.comparator = comparator;        pq = (Key[]) new Object[capacity + 1];    &#125;    public MaxPQ(Key[] a) &#123;        N = a.length;        pq = (Key[]) new Comparable[N + 1];        System.arraycopy(a,0, pq, 1, N);        for (int k = N/2; k &gt;= 1; k--) &#123;            sink(k);        &#125;        assert isMaxPQ();    &#125;    public boolean isEmpty() &#123;        return size() == 0;    &#125;    public int size() &#123;        return N;    &#125;    public Key max() &#123;        if (isEmpty()) throw new NoSuchElementException(&quot;The heap is underflow!&quot;);        return pq[1];    &#125;    public void insert(Key x) &#123;        /* pq maintains the smallest N items        if (N == pq.length) &#123;            if (x.compareTo(max()) &lt; 0) delete(1);            else return;        &#125;         */        if (x == null) throw new IllegalArgumentException(&quot;The key can&#x27;t be null!&quot;);        if (N == pq.length - 1) resize(REFACTOR * pq.length);        pq[++N] = x;        swim(N);        assert isMaxPQ();    &#125;    public Key delMax() &#123;        return delete(1);    &#125;    public Key delete(int i) &#123;        if (isEmpty()) throw new NoSuchElementException(&quot;Priority queue underflow&quot;);        Key max = pq[i];        exch(i, N--);        sink(i);        pq[N + 1] = null;  // prevent loitering        assert isMaxPQ();        return max;    &#125;    private void resize(int capacity) &#123;        assert capacity &gt; N;        Key[] newArray = (Key[]) new Comparable[capacity];        System.arraycopy(pq,0, newArray, 0, N + 1);        pq = newArray;    &#125;    /***************************************************************************     * Helper functions to restore the heap invariant.     ***************************************************************************/    private void swim(int k) &#123;        while (k &gt; 1 &amp;&amp; less(k/2, k)) &#123;            exch(k, k/2);            k = k / 2;        &#125;    &#125;    private void sink(int k) &#123;        while(2*k &lt;= N) &#123;            int j = 2 * k;            if (j &lt; N &amp;&amp; less(j, j+1)) j++;            if (!less(k, j)) break;            exch(k, j);            k = j;        &#125;    &#125;    /***************************************************************************     * Helper functions for compares and swaps.     ***************************************************************************/    private boolean less(int i, int j) &#123;        if (comparator == null) &#123;            return ((Comparable&lt;Key&gt;) pq[i]).compareTo(pq[j]) &lt; 0;        &#125;        else &#123;            return comparator.compare(pq[i], pq[j]) &lt; 0;        &#125;    &#125;    private void exch(int i, int j) &#123;        Key tmp = pq[i];        pq[i] = pq[j];        pq[j] = tmp;    &#125;    // is heap[1..n] a max heap?    private boolean isMaxPQ() &#123;        for (int i = 1; i &lt;= N; i++) &#123;            if (pq[i] == null) return false;        &#125;        for (int i = N+1; i &lt; pq.length; i++) &#123;            if (pq[i] != null) return false;        &#125;        if (pq[0] != null) return false;        return isMaxPQOrdered(1);    &#125;    // is subtree of heap[1..n] rooted at k a max heap?    private boolean isMaxPQOrdered(int k) &#123;        if (k &gt; N) return true;        int left = 2*k;        int right = 2*k + 1;        if (left  &lt;= N &amp;&amp; less(k, left))  return false;        if (right &lt;= N &amp;&amp; less(k, right)) return false;        return isMaxPQOrdered(left) &amp;&amp; isMaxPQOrdered(right);    &#125;    /***************************************************************************     * Iterator.     ***************************************************************************/    public Iterator&lt;Key&gt; iterator() &#123;        return new HeapIterator();    &#125;    public class HeapIterator implements Iterator&lt;Key&gt; &#123;        private BinaryMaxHeap&lt;Key&gt; copy;        public HeapIterator() &#123;            if (comparator == null) copy = new BinaryMaxHeap&lt;&gt;(size());            else copy = new BinaryMaxHeap&lt;&gt;(size(), comparator);            for (int i = 1; i &lt;= N; i++)                copy.insert(pq[i]);        &#125;        public boolean hasNext() &#123; return !copy.isEmpty(); &#125;        public void remove() &#123; throw new UnsupportedOperationException(); &#125;        public Key next() &#123;            if (!hasNext()) throw new NoSuchElementException();            return copy.delMax();        &#125;    &#125;    public static void main(String[] args) &#123;        Integer[] a = &#123;4,5,9,2,0&#125;;        BinaryMaxHeap&lt;Integer&gt; bh = new BinaryMaxHeap&lt;&gt;(a);        System.out.println(bh.max());    &#125;&#125;\nSee the implementation of MinPQ here.\nSee more different priority queue: IndexMaxPQ, IndexMinPQ, Multiway.\nPart.3 Applications\n· Event-driven simulation (customers in a line, colliding particles)\n· Numerical computation (reducing roundoff error)\n· Data compression (Huffman codes)\n· Graph searching (Dijkstra’s algorithm, Prim’s algorithm)\n· Number theory (sum of powers)\n· Artificial intelligence (A* search)\n· Statistics (maintain largest M values in a sequence)\n· Operating systems (loading balancing, interrupt handling)\n· Discrete optimization (bin packing, scheduling)\n· Spam filtering (Bayesian spam filter)\nExample : Molecular dynamics simulation of hard discs (Event-driven simulation)\nGoal: Simulate the motion of N moving particles that behave according to the laws of elastic collision.\nHard disc model\n・Moving particles interact via elastic collisions with each other and walls.\n・Each particle is a disc with known position, velocity, mass, and radius.\n・No other forces.\nEvent-driven simulation (Change state only when something happens.)\n・Between collisions, particles move in straight-line trajectories.\n・Focus only on times when collisions occur.\n・Collision prediction.\n・Maintain PQ of collision events, prioritized by time.\n・Collision resolution.\n・Remove the min = get next collision.\nSee more details here.\n","plink":"https://oreodu.github.io/2020/20201202-Priority-Queues/"},{"title":"File Systems","date":"2020-11-17T17:42:00.000Z","date_formatted":{"ll":"Nov 18, 2020","L":"11/18/2020","MM-DD":"11-18"},"updated":"2020-12-17T13:08:31.856Z","content":"File Systems\nAbstracting Files – Virtual File Systems (VFS)\nPart.1 General Presentation\nThe virtual File System(VFS)\nAbstract all the filesystems models supported by Linux and allow them to coexitst and cooperate.\n\nCommon filesystem interface\nVFS allows user-space to access files independently of the concrete filesystem they are stored on, with a common interface. Interface can work transparently between filesystems.\nFilesystem abstraction layer\nVFS redirect user-space requests to the corresponding concrete filesystem. Developing a new filesystem for Linux means conforming with the bottom interface.\n\nUnix filesystems\nFilesystem can refer to a filesystem type or a partition. Hierarchical tree of files organized into directories.\n\nFile: ordered string bytes from file address @0 to address @file_size-1. The associated metadata (name, assess permissions, modification date, etc) is separated from the file data into specific objects(inodes, dentries).\nDirectory: Folder containing files or other directories(sub-directories). Sub-directories can be nested to create path.\nPart.2 VFS data structures\nGeneralities\n\ndentry: it is associated with a file or a directory and store the file/directory name and its location in the directory tree. It performs directory specific operations and constructed on the fly as files and directories are accessed: generally no on-disk representation.\nDentry states\nA dentry can be used , unused or negative.\nUsed: corresponds to a valid inode(pointed by d_inode) with one or more users(d_count)\nUnused: valid inode, but no current users.(kept in RAM for caching, can be discarded)\nNegative: does not point to a valid inode.(kept around for caching and can be discarded)\nThe dentry cache\nDentries are constructed on demand and kept in RAM for quick future pathname lookups.\nThere are three parts:\n\nLinked list of used dentries linked by the i_dentry field of their inode. (One inode can have multiple links, thus multiple dentries)\nLinked list of LRU sorted unused and negative dentries.(LRU: quick reclamation from the tail of the list.)\nHash table + hash function to quickly resolve a path into the corresponding dentry present in the dcache.\nHash table:  dentry_hashtable array, each element is a pointer to a list of dentries hashing to the same value.\nHashing function: d_hash(), filesystem can provide its own hshing function.\nDentry lookup in the dcache: d_lookup(), returns dentry on success, NULL on failure.\nInodes are similarly cached in RAM, in the inode cache, dentries in the dcache are pining inodes in the node cache.\n\n12345678910/* defined in `include/linux/dcache.h` */struct dentry &#123;  atmoic_t d_conut; /* usage count */  unsigned int d_flags; /* dentry flags */  spinlock_t d_lock; /* per-dentry lock */  int d_mounted; /* indicated if it is a mount point */  struct inode *d_inode; /* assoociated inode */  struct hlist_node d_dash; /* list of hash table entries */  /* ... */&#125;;\n123456789101112131415161718192021222324/* defined in `inculde/linux/dcache.h` */struct dentry_operations &#123;  /* determine if an entry to use from the dcache is valid, generally set to NULL */  int (*d_revalidate)(struct dentry*, unsigned int);  int (*d_weak_revalidate)(struct dentry *, unsighned int);  /* Create a hash value for entry to insert in the dcache */  int (*d_hash)(const struct dentry *, struct qstr *);  /* compare two filenames, requires `dcache_lock` */  int (*d_compare)(const struct dentry *,               , unsigned int, const char *, const struct qstr *);  /* called by VFS when `d_count` reaches zero, requires `dcache_lock` and `d_lock` */  int (*d_delete)(const struct dentry);  int (*d_init)(struct dentry *);  /* called when the dentry is going to be freed */  void (*d_release)(struct dentry *);  void (*d_prune)(struct dentry *);  /* called when the dentry looses its inode and calls `input()` */\tvoid (*d_iput)(struct dentry *, struct inode *);\tchar *(*d_dname)(struct dentry *, char *, int);\tstruct vfsmount *(*d_automount)(struct path *);\tint (*d_manage)(const struct path *, bool);\tstruct dentry *(*d_real)(struct dentry *                           , const struct inode *, unsigned int);&#125;__cacheline_aligned;\ninode: it is related to file or directory and contains metadata(file size, owner id/group, etc) plus information about how to manipulate the file/directory. It must be produced by the filesystem on-demand when a file/directory is accessed.\n123456789101112/* defined in `inculde/linux/fs.h` */struct inode &#123;  struct hlist_node i_hash; /* hash list */  struct list_head i_list; /* list of nodes */  struct list_head i_sb_list; /* list of superblock */  struct list_head i_dentry; /* list of dentries */  unsighned long i_ino; /* inode number */  atomic_t i_count; /* reference counter */  unsigned int i_nlink; /* number of hard links */  uid_t i_uid; /* uer id of owner */  /* ... */&#125;;\n12345678910111213141516/* defined in `include/linux/fs.h` *//* invoke on an innode object */struct inode_operations &#123;  /* create a new node with access mode `mode` */  /* call from `creat()` and `open()` syscalls */  int (*creat) (struct inode *, struct dentry *, umode_t, bool);  /* create a hard link with name `dentry` in the directory `dir`, pointing to old_dentry */  int (*link) (struct dentry *, struct inode *, struct dentry *);  /* remove an inode from the directory `dir` */  int (*unlink) (struct inode *, struct dentry);  /* creates a symbolic link named `symname`, to the file `dentry` in directory `dir` */  int (*symlink) (struct inode *, struct dentry *, const char*);  /* create a directory inside `dir` with name `dentry` */  int (*mkdir) (struct inode *, struct dentry *, umode_t);  /* ... */&#125;;\nsuperblock: it contains global information about the filesystem(partition) and created by filesystem and given to VFS at mount time. Disk-based filesystem store it in a special location and other filesystems have a way to generate it at mount time.\n12345678910111213/* defined in `include/linux/fs.h` */struct super_block &#123;  struct list_head s_list;    /* list of all superblocks */  dev_t s_dev;                /* identifier */  unsigned long s_blocksize; /* block size (bytes) */  unsigned long s_blocksize_bits /* block size (bits) */  loff_t s_maxbytes; /* max file size */  struct file_system_type *s_type; /* filesystem type */  struct super_operations *s_op; /* superblock operations */  struct dquot_operations *dq_op; /* quota methods */  struct dquot_operations *s_qcop; /* quota control methods */  /* ... */&#125;;\n1234567891011121314151617181920/* defined in `include/linux/fs.h` *//* each field is a function pointer operating on a struct super_block */struct super_operations &#123;  /* creats and initialize a new inode */  struct inode *(*alloc_inode) (struct super_block *sb);  /* deallocate an inode */  void (*destory_inode) (struct inode *);  /* marks an inode as dirty(ext filesystems) */  void (*dirty_inode) (struct inode *, int flags);  /* writes the inode to disk, wait specifies if the wirte should be synchronoous */  int (*write_inode) (struct inode *, struct writeback_control *wbc);  /* called by VFS when the last reference to the inode is dropped */  int (*drop_inode) (struct inode *);  void (*evict_inode) (struct inode*);  /* called by VFS on unmoount(holding s lock) */  void (*put_super) (struct super_block *);  /* synchronize filesystem metadata with on-disk filesystem, wait specifies if the operation should be synchronous */  int (*sync_fs) (struct super_block *sb, int wait);  /* ... */&#125;;\nfile: it contains information about a file opened by a process and is created on open() and destroyed on close().\nTwo processes opening the same file: Two file objects, pointing to the same unique dentry, that points itself on a unique inode.\nNo corresponding on-disk data structure.\n123456789101112131415161718/* defined in inculde/linux/fs.h */struct file &#123;  struct path f_path; /* contains the dentry */  spinlock_t f_lock; /* lock */  atomic_t f_count; /* usage count */  unsigned int f_flags; /* open flags */  mode_t f_mode; /* file access mode */  logg_t f_pos; /* file offset */  struct fown_struct f_owner; /* owner data for signals */  const struct cred *f_cred; /* file credentials */  struct file_ra_state f_ra; /* read-ahead state */  u64 f_version; /* version number */  void *private_data; /* private data */  struct list_head f_ep_link; /* list of epoll links */  spinlock_t f_ep_lock; /* epoll lock */  struct address_space *f_mapping; /* page cache mapping */  /* ... */&#125;;\n12345678910111213141516struct file_operations &#123;\tstruct module *owner;  /* update file offset */\tloff_t (*llseek) (struct file *, loff_t, int);  /* read operation */\tssize_t (*read) (struct file *, char user *, size_t, loff_t *);   /* write operation */  ssize_t (*write) (struct file *, const char user *, size_t, loff_t *);  ssize_t (*read_iter) (struct kiocb *, struct iov_iter *);  ssize_t (*write_iter) (struct kiocb *, struct iov_iter *);  int (*iterate) (struct file *, struct dir_context *);  int (*iterate_shared) (struct file *, struct dir_context *);  /* sleeps waiting for activity on a given file */  unsigned int (*poll) (struct file *, struct poll_table_struct *);  /* ... */&#125;;\nVFS implemented in a manner very close to object-oriented programming.\nPart.3 Filesystem and process data structures\nFilesystem data structures\nstruct file_system_type: information about a specific concrete filesystem type.\nOne per filesystem supported (chosen at compile time) independently of the mounted filesystem.\n1234567891011121314151617181920212223/* defined in `incule/linux/fs.h` */struct file_system_type &#123;\tconst char *name; /* name */\tint fs_flags; /* flags */\t/* mount a partition */\tstruct dentry *(*mount) (struct file_system_type *                           , int, const char *, void *);\t/* terminate access to the superblock */\tvoid (*kill_sb) (struct super_block *); struct module *owner;\tstruct file_system_type * next;\tstruct hlist_head fs_supers;\t/* runtime lock validation */\tstruct lock_class_key s_lock_key;\t/* module owning the fs */\t/* linked list of fs types */\t/* linked list of superblocks */\tstruct lock_class_key s_umount_key;\tstruct lock_class_key s_vfs_rename_key;\tstruct lock_class_key s_writers_key[SB_FREEZE_LEVELS];\tstruct lock_class_key i_lock_key;   struct lock_class_key i_mutex_key;\tstruct lock_class_key i_mutex_dir_key; &#125;;\nWhen a filesystem is mounted, a vfsmount structure is created which represents a specific instance of the filesystem: a mount point.\n123456/* defined in `include/linux/mount.h` */struct vfsmount &#123;\tstruct dentry *mnt_root; /* root of the mounted tree */\tstruct super_block *mnt_sb; /* pointer to superblock */\tint mnt_flags; &#125;;\nProcess data structure\nstruct_files_struct: contains per-process information about opened files and file descriptors. ( defined in include/linux/fdtable.h)\nstruct_fs_struct: filesystem information related to a process.(defined in include/linux/fs struct.h)\nstruct_mnt_namespace: provide processes with unique views of a mounted filesystem.(defined in fs/mount.h)\n","plink":"https://oreodu.github.io/2020/20201118-File-Systems/"},{"title":"Interrupts","date":"2020-11-09T12:05:00.000Z","date_formatted":{"ll":"Nov 9, 2020","L":"11/09/2020","MM-DD":"11-09"},"updated":"2020-11-09T14:03:40.312Z","content":"Interrupts\nPart.1 General information\nBecause the device is slow compared to the CPU, we can have hardware devices signal the CPU that they are ready.\n\nExceptions are interrupt issued by the CPU executing some code which happen synchronously with respect to the CPU clock. (Software interrupts, as opposed to hardware devices.) They are also managed by the kernel the same way as hardware interrupts.\nProgram faults: divide-by-zero, page fault, general protection fault, etc.\nVoluntary exceptions: INT assembly instruction, for example for syscall invocation\nInterrupts are electrical signals multiplexed by the interrupt controller. They can be received in a completely non-deterministic way. The kernel/user space can be interrupted at (nearly) any time to process an interrupt.\nDevice identifier: interrupt line or Interrupt ReQuest (IRQ)\nFunction executed by the CPU: interrupt handler or Interrupt Service Routine (ISR)\nThe interrupt handlers (ISR) are kernel C fuctions associated to interrupt lines.\nSpecific prototype, run in interrupt context, opposite to process context (system call).\nAlso called atomic context as one cannot sleep in an ISR. It is not a schedulable entity.\nManaging an interrupt involves two high-level steps:\n· Acknowledging the reception (mandatory, fast)\n· Potentially performing additional work (possibly slow)\nProcessing an interrupt is broken down between:\n· Top-half: time-critical operations (ex: ack), run immediately upon reception.\n· Bottom-half: less critical/time-consuming work, run later with other interrupts enabled\n123456789101112131415161718192021222324252627/* (block 1) */static int omap_kp_probe(struct platform_device *pdev) &#123;  /*...*/  omap_kp-&gt;irq = platform_get_irq(pdev, 0);   if(omap_kp-&gt;irq &gt;= 0) &#123;    if(request_irq(omap_kp-&gt;irq, omap_kp_interrupt, 0,&quot;omap-keypad&quot;, omap_kp) &lt; 0)       goto err4;  &#125;&#125;/* (block 2) *//* Tophalf: interrupt handler (ISR) */ static irqreturn_t omap_kp_interrupt(int irq, void *dev_id) &#123;  /* disable keyboard interrupt */   omap_writew(1, /* . . . */);  tasklet_schedule(&amp;kp_tasklet);  return IRQ_HANDLED;&#125;/* (block 3) */static DECLARE_TASKLET_DISABLED(kp_tasklet, omap_kp_tasklet, 0);/* (block 4) */ /* Bottom half */static void omap_kp_tasklet(unsigned long data) &#123; /* performs lot of work */&#125;\nPart.2 Registering &amp; writing an interrupt handler\nInterrupt handler registration: request_irq()\nReturn 0 on success or standard error code and can sleep.\n123/* in the includes/linux/interrupt.h */static inline int must_checkrequest_irq(unsigned int irq, irq_handler_t handler, unsigned long flags,const char *name, void *dev)\nirp: interrupt number.\nhandler: function pointer to the actual handler.\nname: String describing the associated device.\ndev: unique value identifying a device among a set of devices sharing an interrupt line.\nflag:  IRQF_DISABLED, IRQF_SAMPLE_RANDOM, IRQF_TIMER, IRQF_SHARED\n123456// registrationstatic int omap_kp_probe(struct platform_device *pdev) &#123;  /*...*/  if(request_irq(omap_kp-&gt;irq, omap_kp_interrupt, 0, &quot;omap-keypad&quot;, omap_kp) &lt; 0)    goto err4;&#125;\n123456// handlerstatic irqreturn_t omap_kp_interrupt(int irq, void *dev_id) &#123;  omap_writew(1, OMAP1_MPUIO_BASE+ OMAP_MPUIO_KBD_MASKIT);  tasklet_schedule(&amp;kp_tasklet);  return IRQ_HANDLED;&#125;\n1234567// free an irq static int omap_kp_remove(struct platform_device *pdev) &#123;  /*...*/  free_irq(omap_kp-&gt;irq, omap_kp);  /*...*/  return 0;&#125;\nInside the interrupt\nprototype:\n1static irqreturn_t handler_name(int irq, void *dev);\ndev parameter:\nMust be unique between handlers sharing an interrupt line. Set when registering the handler and can be accessed by the handler.\nReturn value:\nIRQ_NONE: the expected device was not the source of the interrupt.\nIRQ_HANDLED: correct invocation\nShared handlers\nOn registration: IRQ_SHARED flag, dev must be unique (ex: a pointer to a data structure representing the device in question).\nHandler must be able to detect that the device actually generated the interrupt it is called from. When an interrupt occurs on a shared line, the kernel executes sequentially all the handlers sharing this line. Need hardware support at the device level and detection code in the handler.\nPart.3 Interrupt context\nThe kernel can execute in Interrupt vs process context.\n· In process context following a syscall/an exception\n· In interrupt context upon a hardware interrupt reception\nIn interrupt context, sleeping/blocking is not possible.\n· The handler is not a schedulable entity (user/kernel thread)\n· No kmalloc(x, GFP KERNEL). Use GFP ATOMIC\n· No use of blocking synchronization primitives (ex: mutex). Use spinlocks\nInterrupt context is time-critical. Other code is interrupted.\nInterrupt handler stack: 1 dedicated stack per core for handlers (1 page)\nPart.4 Interrupt handling internals in Linux\nInterrupt processing path\n\nSpecific entry point for each interrupt line.\n· Saves the interrupt number and the current registers.\n· call do_IRQ().\ndo IRQ():\n· Acknowledge interrupt reception and disable the line.\n· calls architecture specific functions.\nCall chain ends up by calling _handle_irq_event_percpu()\n· Re-enable interrupts on the line if IRQF DISABLED was not, specified during handler registration.\n· Call the handler if the line is not shared.\n· Otherwise iterate over all the handlers registered on that line.\n· Disable interrupts on the line again if they were previously enabled.\ndo_IRQ() returns to entry point that call ret_from_intr().\n· Checks if reschedule is needed (need resched).\n· Restore register values.\nPart.5 /proc/interrupts\n\nColumns:\n· Interrupt line (not showed if no handler installed).\n· Per-cpu occurrence count.\n· Related interrupt controller name.\n·  Edge/level (fasteoi): way the interrupt is triggered.\n· Associated device name.\nPart.6 Interrupt control\nKernel code sometimes needs to disable interrupts to ensure atomic execution of a section of code.\nThe kernel provides an API to disable/enable interrupts:\n· Disable interrupts for the current CPU.\n· Mask an interrupt line for the entire machine.\nNote that disabling interrupts does not protect against concurrent access from other cores. Need locking, often used in conjunction with interrupts disabling.\nDisabling interrupts on the local core\n123local_irq_disable();/*...*/local_irq_enable();\n12345/* Need to save the interrupts state in order not to disable them twice */unsigned long flags; local_irq_save(flags);     /* disable interrupts if needed */local_irq_restore(flags); /* restores interrupts to the previous state */ /* flags is passed as value but both functions are actually macros */\nDisabling / enabling a specific interrupt line\n1234void disable_irq(unsigned int irq);        /* Does not return until any currently running handler finishe */void disable_irq_nosync(unsigned int irq); /* Do not wait for handler termination */void enable_irq(unsigned int irq);      /* Enables interrupt line */void synchronize_irq(unsigned int irq); /* Wait for a specific line handler to terminate before returning */\nThese enable/disable calls can nest. Must enable as much times as the previous disabling call number.\nThese functions do not sleep. They can be called from interrupt context.\nQuerying the status of the interrupt system\nin_interrupt() returns nonzero if the calling code is in interrupt context. Handler or bottom-half.\nin_irq() returns nonzero only if in a handler.\nTo check if the code is in process context: !in_interrupt().\nInterrupts: http://www.mathcs.emory.edu/~jallen/Courses/355/Syllabus/6-io/0-External/interupt.html\nMore details on Linux interrupt management (v3.18): https://0xax.gitbooks.io/linux-insides/content/interrupts/\n","plink":"https://oreodu.github.io/2020/20201109-Interrupts/"},{"title":"Device Drivers","date":"2020-11-09T01:25:00.000Z","date_formatted":{"ll":"Nov 9, 2020","L":"11/09/2020","MM-DD":"11-09"},"updated":"2020-11-09T12:01:18.959Z","content":"Device Drivers\nAbstracting Devices – Modules and Interrupts\nPart.1 Kernel modules: presentation\nModules are pieces of kernel code that can be dynamically loaded and unloaded at runtime.\nModules benefits:\n· No reboot\nSaves a lot of time when developing/debugging\n· No need to compile the entire kernel\n· Saves memory and CPU time by running on-demand\n· No performance difference between module and built-in kernel code\n· Help identifying buggy code\nEx: identifying a buggy driver compiled as a module by selectively running them.\nPart.2 Writing a kernel module\nThe module is linked against the entire kernel, it is visible on all of the kernel global variables. To avoid  namespace pollution and involuntary reuse of variable names, we can use a well defined naming convention and use static as much as possible.\nKernel symbols list is generally present in /proc/kallsys .\n1234567891011121314151617181920212223/* Create a C file anywhere on the filesystem. (No need to be inside the kernel sources).  */#include &lt;linux/module.h&gt; /* Needed by all modules */#include &lt;linux/kernel.h&gt; /* KERN_INFO */#include &lt;linux/init.h&gt; /* init and exit macros */static int answer initdata = 42;static int init lkp_init(void) &#123;  printk(KERN_INFO&quot;Moduele loaded ...¥n&quot;);  printk(KERN_INFO&quot;The answer is %d...¥n&quot;, answer);  /* Return 0 on success, something else on error */  return 0;&#125;staticvoid exit lkp_exit(void) &#123;  printk(KERN_INFO&quot;Module exiting...¥n&quot;);&#125;/* `init. &amp; exit` functions launched at the load /unload time.  */module_init(lkp_init);module_exit(lkp_exit);/* `MODULE_* macros`:  General info about the module. */MODULE_LICENCE(&quot;GPL&quot;);MODULE_AUTHOR(&quot;PierreOlivier&lt;polivier@vt.edu&gt;&quot;);MODULE_DESCRIPTION(&quot;Sample kernel module&quot;);\nPart.3 Compiling a kernel module\nCreate a Makeflie in the same directory as the module source fie. After the compilation, the complied module is the file with .ko. extension.\n1234567891011121314# `KERNELRELEASE` is defined in the top-level makefile in the linux kernel source code.ifneq  ($(KERNELRELEASE),)obj-m := hello.o# multiple source files. # obj-m += file1.c# obj-m += file2.celseKDIR := /lib/modules/$(shell uname -r)/build  # path to kernel sources root directoryPWD:= $(shell pwd)all:    make -C $(KDIR) M=$(PWD) modulesclean:    make -C $(KDIR) M=$(PWD) cleanendif\nshell pwd: Get the path of current working directory.\nshell uname -r: Get the version of the current kernel.\nKDIR: The source code directory of the current kernel.\n(/lib/modules/$(shell uname -r)/build or /usr/src/linux-header-$(shell uname -r)/)\nmake -C $(LINUX_KERNEL_PATH) M=$(CURRENT_PATH) modules:\nFirst change the directory to the location specified by the -C option ( kernel source code directory), where the top-level makefile of the kernel is stored. Then, the M= option makes the makefile return to the module source code directory before constructing the modules target and the modules target points to the module set in the obj-m variable(hello.o).\nPart.4 Launching a kernel module\nWhen we launch a kernel module, we need administrator privileges(root).\ninsmod/rnmode\n1sudo insmod file.ko /* the module is loaded and init function is executed. */\n1sudo rmmod file.ko /* remove the module and exit function is called. */\nNote that a module is compiled against a specific kernel version and will not load on the another kernel.\nmodprobe\nmake modules_install from the kernel sources install the modules in a standard location on the filesystem.(Generally /lib/modules/&lt;kernel version&gt;) and those modules can be inserted through modprobe. Such installed modules can be loaded automatically at boot time by editing /etc/modules or the files in /ets/modprobe.d\n1sudo modprobe &lt;module name&gt;\nInsmod handles modules dependencies. (Dependency list generated in /lib/modules/&lt;kernel version/modules.dep&gt;)\nPart.5 Modules: miscellaneous information\nModules parameters can be entered from the command line at the launch time.\n12345678910111213#include &lt;linux/module.h&gt; /* ... */staticint int_param = 42;staticchar *string_param =&quot;defaultvalue&quot;;module_param(int_param, int, 0); MODULE_PARM_DESC(int_param,&quot;Asampleintegerkernelmoduleparameter&quot;);module_param(string_param, charp, S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH); MODULE_PARM_DESC(string_param,&quot;Anotherparameter,astring&quot;);staticint init lkp_init(void) &#123;  printk(KERN_INFO&quot;Intparam:%d¥n&quot;, int_param);  printk(KERN_INFO&quot;Stringparam:%s¥n&quot;, string_param); /* ... */&#125;/* ... */\n1sudo insmod lkp.ko int_param&#x3D;12 string_param&#x3D;&quot;hello&quot;\nmodinfo: info about a kernel module.\n12345678910modinfo my_module.kofilename:        /tmp/test/my_module.kodescription:     Sample kernel moduleauthor:  \t\t\t\t Pierre Olivier &lt;polivier@vt.edu GPLlicense: \t\t\t\t A5ADE92B1C81DCC4F774A37srcversion: depends: vermagic: \t\t\t4.8.0-34-generic SMP mod_unload modversionsparm:\t\t\t\t\t\tint_param:A sample integer kernel module parameter (int)parm:\t\t\t\t\t\t string_param:Another parameter, a string (charp)\nlsmod: list currently running modules. (Can also look in /proc/modules)\nPart.6 Memory allocation\nkmalloc\nAllocate memory that is virtually and physically contiguous. (Maximum allocated size : 4MB on x86 (architecture dependent)).\n123456#include &lt;linux/slab.h&gt;/* ... */char *my_string = (char *)kmalloc(128, GFP_KERNEL);my_struct my_struct_ptr = (my_struct *)kmalloc(sizeof(my_struct), GFP_KERNEL);/* ... */kfree(my_string); kfree(my_struct_ptr);\nvmalloc\nAllocate memory that is virtually contiguous, but not physically contiguous. No size limit other than the amount of free RAM (at least on 64 bit architectures.  Might sleep.\n123456#include &lt;linux/vmalloc.h&gt;/* ... */char *my_string = (char *)vmalloc(128);my_struct my_struct_ptr = (my_struct *)vmalloc(sizeof(my_struct)); /* ... */vfree(my_string); vfree(my_struct_ptr);\n","plink":"https://oreodu.github.io/2020/20201109-Device-Drivers/"},{"title":"Process Scheduling","date":"2020-10-26T01:25:00.000Z","date_formatted":{"ll":"Oct 26, 2020","L":"10/26/2020","MM-DD":"10-26"},"updated":"2020-10-30T12:06:50.816Z","content":"Process Scheduling\nPart.1 General information\nScheduling\nWhen in the system there are more ready-to-run processes than the number of cores. The scheduler is responsible for making the best use of the resource that is the CPU time and decides which process should run,  when, and for how long.\nNow: Completely Fair Scheduler (CFS) is used in Linux.\nMultitasking\nSingle core: gives the illusion that multiple processes are running concurrently.\nMulti-cores: enable true parallelism.\n2 types of multitasking OS:\n· Cooperative multitasking: a process does not stop running until it decides to do so (yield the CPU).\n· Preemptive multitasking: The OS can interrupt the execution of a process: preemption. Generally after the process expires its timeslice. It is based on tasks priorities.\nScheduling policy\nScheduling policy are the set of rules determining the choices made by a given model of scheduler.\n· I/O-bound processes\nSpend most of their time waiting for I/O: disk, network, but also keyboard, mouse, etc. Should run often and for a small time frame.\n· Compute-bound processes\nHeavy use of the CPU. Should not run often, but for a long time.\n\nPriority\n\nOrder process according to their ”importance” from the scheduler standpoint.\nLinux has 2 priority ranges:\n\n· Nice value : ranges from -20 to +19, default is 0 (High values of nice means lower priority)\nList process and their nice values with ps ax -o pid,ni,cmd\n· Real-time priority : range configurable (default 0 to 99) (Higher values mean higher priority）\nProcesses labeled real-time always execute before standard (nice) processes.\nList processes and their real-time priority using ps ax -o pid,rtprio,cmd\n\nTimeslice\n\nHow much time a process should execute before being preempted. The timeslice a process receives is function of the load of the systems and is also weighted by the process priority. It is a proportion of the CPU.\nPart.2 Linux Completely Fair Scheduler (CFS)\nScheduling classes\n· CPU classes : coexisting CPU algorithms. Each task belongs to a class.\nCFS: SCHED_OTHER, implemented in kernel/sched/fair.c.\n· Real-time classes : For predictable schedule. SCHED_RR, SCHED_FIFO, SCHED_DEADLINE\nsched_class data structure :\n1234567891011121314151617struct sched_class &#123;   /* Called when a task enters a runnable stat */  void (*enqueue_task) (/* . . . */);  /* Called when a task becomes unrunnable */\tvoid (*dequeue_task) (/* . . . */);  /* Yield the processor (dequeue then enqueue back immediatly) */\tvoid (*yield_task) (/* . . . */);  /* Checks if a task that entered the runnable state should preempt the currently running task */\tvoid (*check_preempt_curr) (/* . . . */);  /* Chooses the next task to run */\tstruct task_struct * (*pick_next_task) (/* . . . */);   /* Called when the currentluy running task changes its scheduling class or task group to the related scheduler */  void (*set_cur_task) (/* \t...*/);  /* Called regularly (default: 10 ms) from the system timer tick handler, might lead to context switch */\tvoid (*task_tick) (/* . . . */);\t/*...*/&#125;\nFair scheduling\n3 main (high-level) CFS concepts;\n· CFS runs a process for some times, then swaps it for the runnable process that has run the least.\n· No default timeslice, CFS calculates how long a process should run according to the number of runnable processes.\n· No default timeslice, CFS calculates how long a process should run according to the number of runnable processes.\nTargeted latency : period during which all runnable processes should be scheduled at least once.\nPart.3 CFS implementation\nTime accounting\nsched_entity structure in the task_struct (se field).\n12345678910111213struct sched_entity &#123;  struct load_weight load;   struct rb_node run_node;   struct list_head group_node;   unsigned int on_rq;    u64 exec_start;\tu64 sum_exec_runtime;\tu64 vruntime;\tu64 prev_sum_exec_runtime;    /* additional statistics not shown here */&#125;\nVirtual runtime: How much time a process has been executed (ns).\n1234567891011121314151617181920212223242526272829static void update_curr(struct cfs_rq * cfs_rq) &#123;  struct sched_entity *curr = cfs_rq -&gt; curr;  u64 now  = rq_clock_task(rq_of(cfs_rq));  u64 delta_exec;    if (unlikely(!curr)) return;    delta_exec = now - curr-&gt;exec_start;  if (unlikely(s64)delta_exec &lt;= 0) return;    curr-&gt;exec_start = now;    schedstat_set(curr-&gt;statistics.exec_max, max(delta_exec, curr-&gt;statistics.exec_max));  curr-&gt;sum_exec_runtime += delta_exec;  schedstat_add(cfs_rq-&gt;exec_clock, delta_exec);    curr-&gt;vruntome += calc_delta_fair(delta_exec,curr);  update_min_vruntme(cfs_rq);    if(entity_is_task(curr)) &#123;    struct task_struct *currtask = task_of(curr);        trace_sched_stat_runtime(curtask, delta_exec, curr-&gt;vruntime);    cpuacct_charge(curtask, delta_exec);    account_group_exec_runtime(curtask, delta_exec);        account_cfs_rq_runtime(cfs_rq, delta_exec);  &#125;  &#125;\nInvoked regularly by the system timer, and when a process becomes runnable/unrunnable.\nProcess selection\nWhen CFS needs to choose which runnable process to run next:\nThe process with the smallest runtime is selected. It is the leftmost node in the tree.\n12345struct sched_entity * pick_first_entity(struct cfs_rq *cfs_rq) &#123;  struct rb_node *left =cfs_rq-&gt;rb_leftmost;\tif (!left) return NULL;\treturn rb_entry(left, struct sched_entity, run_node);&#125;\n\nadding a process to the tree\n\n1234567891011121314151617181920212223242526272829/* Aprocess is added through enqueue entity. */static void enqueue_entity(struct cfs_rq *cfs_rq,                            struct sched_entity *se, int flags) &#123;  bool renorm = ! (flags &amp; ENQUEUE_WAKEUP) || (flags &amp; ENQUEUE_MIGRATED);   bool curr = cfs_rq-&gt;curr == se;  if (renorm &amp;&amp;curr) se-&gt;vruntime += cfs_rq-&gt;min_vruntime;\t  update_curr(cfs_rq);    if (renorm &amp;&amp;!curr) se-&gt;vruntime += cfs_rq-&gt;min_vruntime;  \tupdate_load_avg(se, UPDATE_TG);  enqueue_entity_load_avg(cfs_rq, se);  account_entity_enqueue(cfs_rq, se);  update_cfs_shares(cfs_rq);  \tif(flags &amp; ENQUEUE_WAKEUP) place_entity(cfs_rq, se, 0);    check_schedstat_required();   update_stats_enqueue(cfs_rq, se, flags);   check_spread(cfs_rq, se);  \tif(!curr) enqueue_entity(cfs_rq, se);  se-&gt;on_rq = 1;\tif (cfs_rq-&gt;nr_running == 1) &#123;    list_add_leaf_cfs_rq(cfs_rq);    check_enqueue_throttle(cfs_rq);  &#125;&#125;\n1234567891011121314151617181920212223242526272829303132static void enqueue_entity(struct cfs_rq, *cfs_rq,                            struct sched_entity *se) &#123;  struct rb_node **link = &amp;cfs_rq-&gt;tasks_timeline.rb_node;   struct rb_node *parent = NULL;   struct sched_entity *entry;\tint leftmost = 1;\t/*\t* Find the right place in the rbtree: \t*/\twhile (*link) &#123;    parent = *link;\t  entry = rb_entry(parent, struct sched_entity, run_node);\t/*\t* Wedont care about collisions. \t* Nodes with\tthe same key stay together. \t*/\tif (entity_before(se, entry)) &#123;    link = &amp;parent-&gt;rb_left;   &#125;else&#123;    link =&amp;parent-&gt;rb_right;    leftmost = 0;  &#125;&#125;/** Maintain a cache of leftmost tree * entries (it is frequently used): */if (leftmost) cfs_rq-&gt;rb_leftmost = &amp;se-&gt;run_node; rb_link_node(&amp;se-&gt;run_node, parent, link);rb_insert_color(&amp;se-&gt;run_node, &amp;cfs_rq-&gt;tasks_timeline);&#125;    \n\nremoving a process from the tree\n\n1234567891011121314151617181920struct void dequeue_entity(struct cfs_rq *cfs_rq,                            struct sched_entity *se, int flags) &#123;  update_curr(cfs_rq);   dequeue_entity_load_avg(cfs_rq, se);  update_stats_dequeue(cfs_rq, se, flags );    clear_buddies(cfs_rq, se);    if (se != cfs_rq-&gt;curr) dequeue_entity(cfs_rq, se);  se-&gt;on_rq = 0;  account_entity_dequeue(cfs_rq, se);    if (!(flags &amp; DEQUEUE_SLEEP)) se-&gt;vruntime -= cfs_rq-&gt;min_vruntime;     return_cfs_rq_runtime(cfs_rq);  update_cfs_shares(cfs_rq);  \tif ((flags &amp;(DEQUEUE_SAVE| DEQUEUE_MOVE)) == DEQUEUE_SAVE)    update_min_vruntime(cfs_rq);&#125;\n123456789static void dequeue_entity(struct cfs_rq *cfs_rq, s                           truct sched_entity *se) &#123;  if (cfs_rq-&gt;rb_leftmost == &amp;se-&gt;run_node) &#123;     struct rb_node *next_node;    next_node = rb_next(&amp;se-&gt;run_node);    cfs_rq-&gt;rb_leftmost = next_node;  &#125;\trb_erase(&amp;se-&gt;run_node, &amp;cfs_rq-&gt;tasks_timeline);&#125;\n\nEntry point: schedule()\n\nThe kernel calls schedule() anytime it wants to invoke the scheduler. Calls pick_next_task().\n1234567891011121314151617181920212223242526static inline struct task_struct * pick_next_task(struct rq *rq, structtask_struct *prev, struct pin_cookie cookie) &#123;  const struct sched_class *class = &amp; fair_sched_class;   struct task_struct *p;  \tif (likely(prev-&gt;sched_class ==class &amp;&amp;              rq-&gt;nr_running == rq-&gt;cfs.h_nr_running)) &#123;    p = fair_sched_class.pick_next_task(rq, prev, cookie);    \t\tif (unlikely(p == RETRY_TASK)) goto again;\t\tif (unlikely(!p)) p = idle_sched_class.pick_next_task(rq, prev, cookie);        return p;  &#125;  again:   for_each_class(class) &#123;    p =class-&gt;pick_next_task(rq, prev, cookie);    if(p)&#123;      if (unlikely(p == RETRY_TASK)) goto again;       return p;    &#125;  &#125; BUG();  /* the idle class will always have a runnable task */&#125;\nSleeping and waking up\nMultiple reasons for a task to sleep:\nSpecified amount of time, waiting for I/O, blocking on a mutex, etc.\nGoing to sleep - steps:\n· Task marks itself as sleeping\n· Task enters a waitqueue\n· Task leaves the rbtree of runnable processes\n· Task calls schedule()  to select a new process to run\nTwo states associated with sleeping:\nTASK INTERRUPTIBLE: Will be awaken on signal reception\nTASK UNINTERRUPTIBLE: Ignore signals\nWait queue: List of processes waiting for an event to occur.\n12345typedef struct wait_queue_head wait_queue_head_tstruct wait_queue_head &#123;  spinlock_t lock;  struct list_head task_list;&#125;\nSome simple interfaces used to go to sleep have races: It is possible to go to sleep after the event we are waiting for has occurred.\n1234567891011/* We assume the wait queue we want to wait on is accessible through a variable q */ DEFINE_WAIT(wait); /* initialize a wait queue entry */add_wait_queue(q, &amp;wait);while (!condition) &#123;   /* event weare waiting for */  prepare_to_wait(&amp;q, &amp;wait, TASK_INTERRUPTIBLE);  if(signal_pending(current))   /* handle signal */    schedule();&#125;finish_wait(&amp;q, &amp;wait);\nSteps for waiting on a waitqueue:\n· Create a wait queue entry (DEFINE_WAIT()).\n· Add the calling process to a wait queue (add_wait_queue()).\n· Call prepare_to_wait() to change the  process state.\n· If the state is TASK_INTERRUPTIBLE, a signal can wake the task up → need to check.\n· Executes another process with schedule().\n· When the task awakens, check the condition.\n· When the condition is true, get out of the wait queue and set the state accordingly using finish_wait().\nWaking up is taken care of by wake_up(). Awakes all the processes on a wait queue by default.\n12#define wake_up(x) wake_up(x, TASK_NORMAL, 1 , NULL) /* type of x i s wait_queue_head_t */\n1234567891011static void wake_up_common(wait_queue_head_t *q,                            unsigned int mode, int nr_exclusive,                            int wake_flags, void *key) &#123;  wait_queue_t *curr, *next;    list_for_each_entry_safe(curr, next, &amp;q-&gt;task_list, task_list) &#123;    unsigned flags = curr-&gt;flags;    if (curr-&gt;func(curr, mode, wake_flags, key) &amp;&amp; (flags &amp; WQ_FLAG_EXCLUSIVE) &amp;&amp; !--nr_exclusive)      break; /* wakes up only a subset of ’exclusive’ tasks */   &#125;&#125;\nExclusive tasks are added through prepare_to_wait_exclusive().\nA wait queue entry contains a pointer to a wake-up function : include/linux/wait.h.\ndefault_wake_function()  calls try_to_wake up() -&gt; which calls ttwu_queue() -&gt; which calls ttwu_do_activate()  (put the task back on runqueue)  -&gt; which calls ttwu_do_wakeup which sets the task state to TASK RUNNING.\n1234567891011typedefstruct wait_queue wait_queue_t;typedefint (*wait_queue_func_t)(wait_queue_t *wait, unsigned mode, int flags, void *key); int default_wake_function(*wait_queue_func_t)(wait_queue_t *wait, unsigned mode,int flags, void *key);/* ... */struct wait_queue &#123;   /* ... */  wait_queue_func_t func;  /* ... */&#125;\n· Per-CPU runqueues (rbtrees): To avoid costly accesses to shared data structures.\n· Runqueues must be kept balanced.\nEx: dual-core with one large runqueue of high-priority processes, and a small one with low-priority processes. High-priority processes get less CPU time than low-priority ones.\nA load balancing algorithm is run periodically. Balances the queues based on processes priorities and their actual CPU usage.\nPart.4 Preemptions and context switching\nContext switch\nA context switch is the action of swapping the process currently running on the CPU to another one which is performed by the context_switch() function. The function is called by schedule().\n1.Switch the address space through switch_mm().\n2.Switch the CPU state (registers) through switch_to().\nA task can voluntarily relinquish the CPU by calling schedule().\nThe kernel check if there is a need of preemption based on the need_resched flag.\nneed_resched is set by:\n1.scheduler_tick() when the currently running task needs to be preempted.\n2.try_to_wake_up() when a process with higher priority wakes up.\nneed_resched flag is checked:\nUpon returning to user space (from a syscall or an interrupt).\nUpon returning from an interrupt.\nIf the flag is set, schedule() is called.\nUser preemption happens:\nWhen return to user space from a syscall.\nWhen return to user space from an interrupt.\nWith Linux,  the kernel is also subject to preemption.\nKernel preemption\nIn linux, a task can be preempted in the kernel as long as execution is in a safe state (Not holding any lock (kernel is SMP safe)).\nIf need_resched &amp;&amp; !preempt_count → safe to preempt. preempt_count in the thread_info structure (Indicates the current lock depth).\nChecked when returning to the kernel from interrupt. need_resched is also checked when releasing a lock and preempt count is 0.\nKernel code can also call directly schedule().\nKernel preemption can occur :\n1.On return from interrupt to kernel space.\n2.When kernel code becomes preemptible again.\n3.If a task explicitly calls schedule() from the kernel.\n4.If a task in the kernel blocks (ex: mutex, result in a call to schedule())\nReal-time scheduling policies\nReal-time task of any scheduling class will always run before non-real time ones (CFS, SCHED_OTHER). schedule() → pick next task() → for_each_class().\nTwo classical RT scheduling policies (kernel/sched/rt.c):\n· SCHED_FIFO:\nTasks run until it blocks/yield, only a higher priority RT task can preempt it.\nRound-robin for tasks of same priority.\n· SCHED_RR:\nSame as SCHED_FIFO, but with a fixed timeslice.\nScheduling-related syscalls\nSee more details from here.\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111#define _GNU_SOURCE#include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;sys/types.h&gt; #include &lt;unistd.h&gt; #include &lt;sched.h&gt; #include &lt;assert.h&gt;void handle_err(int ret, char *func) &#123;   perror(func);\texit(EXIT_FAILURE);&#125;int main(void) &#123;  pid_t pid = -1;\tint ret = -1;\tstruct sched_param sp;  int max_rr_prio, min_rr_prio = -42;   size_t cpu_set_size = 0;  cpu_set_t cs;    /* GetthePIDofthecallingprocess */  pid = getpid();\tprintf(&quot;Mypidis:%d¥n&quot;, pid);     /* Gettheschedulingclass */\tret = sched_getscheduler(pid);   if(ret == -1) handle_err(ret,&quot;sched_getscheduler&quot;);   printf(&quot;sched_getschedulerreturns:&quot;&quot;%d¥n&quot;, ret);  assert(ret == SCHED_OTHER);  \t/* Getthepriority(nice/RT) */\tsp.sched_priority = -1;\tret = sched_getparam(pid, &amp;sp);  if(ret == -1) handle_err(ret,&quot;sched_getparam&quot;);   printf(&quot;Mypriorityis:%d¥n&quot;,\tsp.sched_priority);  /* Setthepriority(nicevalue) */\tret = nice(1);   if(ret == -1)\thandle_err(ret,&quot;nice&quot;);    /* Getthepriority */\tsp.sched_priority = -1;\tret = sched_getparam(pid, &amp;sp);   if(ret == -1) handle_err(ret,&quot;sched_getparam&quot;);  printf(&quot;Mypriorityis:%d¥n&quot;,\tsp.sched_priority);    /* SwtichscheduleingclasstoFIFOandthepriorityto99 */  sp.sched_priority = 99;\tret = sched_setscheduler(pid, SCHED_FIFO, &amp;sp);   if(ret == -1) handle_err(ret,&quot;sched_setscheduler&quot;);    /* Gettheschedulingclass */\tret = sched_getscheduler(pid);   if(ret == -1) handle_err(ret,&quot;sched_getscheduler&quot;);   printf(&quot;sched_getschedulerreturns:&quot;&quot;%d¥n&quot;, ret);  assert(ret == SCHED_FIFO);    /* Getthepriority */\tsp.sched_priority = -1;\tret = sched_getparam(pid, &amp;sp);   if(ret == -1) handle_err(ret,&quot;sched_getparam&quot;);  printf(&quot;Mypriorityis:%d¥n&quot;,         sp.sched_priority);  \t/* SettheRTpriority */\tsp.sched_priority = 42;\tret = sched_setparam(pid, &amp;sp);  if(ret == -1) handle_err(ret,&quot;sched_setparam&quot;);  printf(&quot;Prioritychangedto%d¥n&quot;,\tsp.sched_priority);\t  /* Getthepriority */\tsp.sched_priority = -1;\tret = sched_getparam(pid, &amp;sp);  if(ret == -1) handle_err(ret,&quot;sched_getparam&quot;);  printf(&quot;Mypriorityis:%d¥n&quot;,\tsp.sched_priority);    /* GetthemaxpriorityvalueforSCHED_RR */\tmax_rr_prio = sched_get_priority_max(SCHED_RR);   if(max_rr_prio == -1)    handle_err(max_rr_prio,&quot;sched_get_priority_max&quot;);   printf(&quot;MaxRRprio:%d¥n&quot;, max_rr_prio);  \t/* GettheminpriorityvalueforSCHED_RR */\tmin_rr_prio = sched_get_priority_min(SCHED_RR);   if(min_rr_prio == -1)    handle_err(min_rr_prio,&quot;sched_get_priority_min&quot;);  printf(&quot;MinRRprio:%d¥n&quot;, min_rr_prio);  cpu_set_size = sizeof(cpu_set_t);  CPU_ZERO(&amp;cs); /* clearthemask */  CPU_SET(0, &amp;cs);  CPU_SET(1, &amp;cs);  /* SettheaffinitytoCPUs0and1only */\tret = sched_setaffinity(pid, cpu_set_size, &amp;cs);  if(ret == -1) handle_err(ret,&quot;sched_setaffinity&quot;);  /* GettheCPUaffinity */\tCPU_ZERO(&amp;cs);\tret = sched_getaffinity(pid,cpu_set_size, &amp;cs);  if(ret == -1) handle_err(ret, &quot;sched_getaffinity&quot;);  assert(CPU_ISSET(0, &amp;cs));  assert(CPU_ISSET(1, &amp;cs));  printf(&quot;AffinitytestsOK¥n&quot;);  /* YieldtheCPU */  ret = sched_yield();   if(ret == -1) handle_err(ret, &quot;sched_yield&quot;);\treturn EXIT_SUCCESS;&#125;\n","plink":"https://oreodu.github.io/2020/20201026-Process-Scheduling/"},{"title":"Memory Management","date":"2020-10-25T00:07:00.000Z","date_formatted":{"ll":"Oct 25, 2020","L":"10/25/2020","MM-DD":"10-25"},"updated":"2020-10-30T12:51:25.322Z","content":"Memory Management\nPart.1 Address space and memory descripter\nAddress space\nThe memory that a process can access is called its address space.  It is defined by the process page table and set up by the kernel.\n\nEach process is given a flat(as opposed to segmented) 32/64-bits address space and a memory address is an index within the address space.\n\nInterval of addresses that the process has the right to access: virtual memory areas (VMAs).\nVMAs can be dynamically added or removed to the process address space and have associated permissions: read, write, execute. When a process try to access an address outside of valid VMAs, or access a VMA with wrong permissions: segmentation fault.\nVMAs cancontain:\nMapping of the executable file code (text section)\nMapping of the executable file initialized variables (data section)\nMapping of the zero page for uninitialized variables (bss section)\nMapping of the zero page for the user-space stack\nText, data, bss for each shared library used\nMemory-mapped files, shared memory segment, anonymous mappings (used by malloc)\n\nMemory descriptor\n\n\nThe kernel represent a process address space through a struct mm_struct object, the memory descriptor which is defined in include/linux/mm_types.h.\nAll mm_struct are linked together in a doubly linked list. Through the mmlist  field if the mm_struct.\nSee more from here.\n\n\nMemory descriptor allocation\nA task memory descriptor is located in the mm_field of the corresponding task_struct. Current task memory descriptor: current-&gt;m. During fork(),copy_mm() is making a copy of the parent memory descriptor for the child. copy_mm()calls dup_mm() which calls allocate_mm() which allocates a mm_struct object from a slab cache.\nTwo threads sharing the same address space have the mm_field of their task_struct pointing to the same mm_struc object. Threads are created using the CLONE_VM flag passed to clone() → allocate_mm() is not called.\n\n\nMemory descriptor destruction\nWhen a process exits, do_exit() is called. It calls exit_mm(). Performs some housekeeping/statistics updates.\nCall mm_put(). mm_put() decrements the users field and calls _mmput() if it reaches 0. _mmput() calls mmdrop(), that decrements the count field and calls mm_drop() if it reaches 0. _mmdrop() calls free_mm() which return the memory for the mm_struct() to the slab cache (i.e. free).\n\n\nMemory descriptor and kernel threads\nKernel threads do not have a user-space address space. mm field of a kernel thread task_struct is NULL. When a kernel thread is scheduled, the kernel notice its mm is NULL so it keeps the previous address space loaded (page tables) and makes  the active_mm field of the kernel thread to point on the borrowed mm_struct.\n\n\nPart.2 Virtual Memory Area\nvm_area_struct\nEach VMA is represented by an object of type vm_area_struct and defined in include/linux/mm_types.h. See more details from here. Each VMA is unique to the associated mm_struct. Two processes mapping the same file will have two different mm_struct objects, and two different vm area struct objects. Two threads sharing a mm_struct object also share the vm_area_struct objects.\nFlags\nFlags specify properties and information for all the pages contained in the VMA.\nVM READ: pages can be read from\nVM WRITE: pages can be written to\nVM EXEC: code inside pages can be executed\nVM SHARED: pages are shared between multiple processes (if unset the mapping is private)\nVM MAYREAD: the VM READ flag can be set\nVM MAYWRITE: the VM WRITE flag can be set\nVM MAYEXEC: the VM EXEC flag can be set\nVM MAYSHARE: the VM SHARED flag can be set\nVM GROWSDOWN: area can grow downwards\nVM GROWSUP: area can grow upwards\nVM SHM: area can be used for shared memory\nVM DENYWRITE: area maps an unwritable file\nVM EXECUTABLE: area maps an executable file\n… …\nVMA operations\nvm ops  in vm_area_struct points to a vm_operations_struct object which contains function pointers to operate on a specific VMAs and is defined in include/linux/mm.h. See more details from here.\nFunction pointers in vm operations struct:\nopen(): called when the area is added to an address space.\nclose(): called when the area is removed from an address space.\nfault(): invoked by the page fault handler when a page that is not present in physical memory is accessed.\npage_mkwrite():invoked by the page fault handler when a previously read-only page is made writable.\nVMAs in real life\nFrom userspace, one can observe the VMAs map for a given process: cat /proc/&lt;pid&gt;/maps.\n· /proc/&lt;pid&gt;/maps  columnsdescription:\nAddress range Permissions\nStart offset of file mapping\nDevice containing the mapped file\nMapped file inode number\nMapped file pathname\nCan also use the command pmap &lt;pid&gt;.\nPart.3 VMA manipulation\nFinding a VMA\nfind_vma(): used to find a VMA in which a specific memory address resides, its prototype in include/linux/mm.h and  it is defined in mm/mmap.c. See more details from here.\nfind_vma_prev(): returns in addition the last VMA before a given address.\nfind_vma_intersection(): returns the first VMA overlapping a given address range.\nCreating an address interval\ndo_mmap() is used to create a new linear address interval which can result in the creation of a new VMAs\nor a merge of the create area with an adjacent one when they have the same permissions.\nOn error do_mmap() returns a negative value.\nOn success:\nThe kernel tries to merge the new interval with an adjacent one having same permissions.\nOtherwise, create a new VMA.\nReturns a pointer to the start of the mapped memory area.\ndo_mmap() is exported to user-space through mmap2().\n1externunsignedlong do_mmap(struct file *file, unsignedlong addr, unsignedlong len, unsignedlong prot, unsignedlong flags,vm_flags_t vm_flags, unsignedlong pgoff, unsignedlong *populate);\nCaller must hold mm-&gt;mmap_sem (RW semaphore). Maps the file file in the address space at address addr for length len. Mapping starts at offset pgoff in the file. prot specifies access permissions for the memory pages: PROT READ, PROT WRITE, PROT EXEC, PROT NONE.\nflags specifies the rest of the VMAoptions:\nMAP SHARED: mapping can be shared\nMAP PRIVATE: mapping cannot be shared\nMAP FIXED: created interval must start at addr\nMAP ANONYMOUS: mapping is not file-backed\nMAP GROWSDOWN: corresponds to VM GROWSDOWN\n… …\nRemoving an address interval\nRemoving an address interval is done through do_munmap() and 0 returned on success.\nExported to user-space through munmap().\nPart.4 Page Tables\nAll memory accesses made by the CPU are virtual and translated to physical addresses through the page tables. Linux kernel set the page tables and the translation is made automatically by the hardware (MMU) according to the page tables content. Page size is machine dependent. Typical values for x86 are 4K, 2M, and 1G. Most of the pages are used for (1) kernel/userspace memory (anonymous mapping) or (2) file mapping.\nThe address space is defined by VMAs and is sparsely populated(One address space per process → one page table per process). A hierarchical tree structure is used to define the page table.\n\n\nEach physical page is represented by a struct page. Assuming 8GB of RAM and 4K-sized pages: 128MB reserved for struct page objects(∼1.5%).\n1234567891011/* The kernel uses struct page to keep track of the owner of the page */struct page &#123;  unsigned long flags;            /* page status (permission,etc.) */  unsigned counters;              /* usage count */  atomic_t _mapcount;  unsigned long private;          /* private mapping */  struct address_space *mapping;  /* file mapping */  pgoff_t index;                  /* offset within mapping */  struct list_head lru;  void *virtual;                  /* virtualaddres */&#125;\nZones\nBecause of hardware limitations, only certain physical pages can be used in certain contexts. Physical memory is divided into zones. Zones layout is completely architecture dependent.\n\nZONE DMA: pages with which DMA(Direct Memory Access) can be used.\nZONE DMA32: memory for other DMA limited devices.\nZONE NORMAL: page always mapped in the address space.\nZONE HIGHMEM: pages only mapped temporary.\nEach zone is represented by a struct zone object and is defined in include/linux/mmzone.h.\n123456789struct zone &#123;  /* minimum,lowandhighwatermarksusedforper-area memory allocation. */  unsigned long      watermark[NR_WMARK];  const char         *name;  spinlook           lock;     /* protects against concurrent access */  /* list of free pages to serve memory allocation requests */  struct free_area   free_area[MAX_ORDER];  /*...*/&#125;\nPart.5 Low-level memory allocator\nLow-level mechanisms allocating memory with page-sized granularity. Interface is in include/linux/gfp.h. For more details from here.\n\n· Allocates 2^order contiguous pages (1 &lt; &lt; order )\n· Returns the address of the first allocated struct page.\n1struct page * alloc_pages(gfp_t gfp_mask, unsigned int order);\nTo actually use the allocated memory, need to convert to virtual address.\n1void * page_address(struct page *page);\nOr we can allocate and get the virtual address directly.\n1unsigned long get_free_pages(gfp_t gfp_mask, unsigned int order);\nTo get a page filled with zeros.\nA page containing user space data (process A) that is freed can be later given to another process (process B) and we don’t want process B to read information from process A.\n1unsigned long get_zeroed_page(gfp_t gfp_mask);\nFree pages, only free the pages you allocate!\n1234void free_pages(struct page *page, unsigned int order); void free_pages(unsigned long addr, unsigned int order); void free_page(struct page *page);void free_page(unsigned long addr);\nBuddy system :\n\n123456789101112131415161718192021222324252627282930313233343536373839/* Low-level memory allocator, Usage example */#include &lt;linux/module.h&gt; #include &lt;linux/kernel.h&gt; #include &lt;linux/init.h&gt; #include &lt;linux/gfp.h&gt;#define PRINT_PREE &quot;[LOWLEVEL]:&quot;#define PAEG_ORDER_REQUESTED 3#define INTS_IN_PAGE (PAGE_SIZE/sizeof(int))unsigned long virt_addr;struct int _int my_mod_init(void) &#123;  int *int_array;  int i;  printk(PRINT_PREE &quot;Entering module.¥n&quot;);    virt_addr =get_free_pages(GFP_KERNEL,                            PAGES_ORDER_REQUESTED);   if(!virt_addr) &#123;    printk(PRINT_PREF &quot;Error in allocation¥n &quot;);    return -1;  &#125;    int_array = (int *)virt_addr;\tfor(i=0; i&lt;INTS_IN_PAGE; i++) int_array[i] = i;\tfor(i=0; i&lt;INTS_IN_PAGE; i++) printk(PRINT_PREF &quot;array[%d] = %d¥n&quot;,                                        i, int_array[i]);  return 0;&#125;static void _exit my_mod_exit(void) &#123;  free_pages(virt_addr,            PAGES_ORDER_REQUESTED);  printk(PRINT_PREE &quot;Exiting module ¥n&quot;);&#125;module_init(my_mod_init);module_exit(my_mod_exit);\nPart.6 kmalloc() and vmalloc()\nkmalloc() (declared in includes/linux/slab.h)  allocates byte-sized chunks of memory which is physically contiguous and return a pointer to the first allocated byte on success.\n1void * kmalloc(size_t size, gfp_t flags);\nkmalloc flags\ngfp_t is an unsigned int defined in include/linux/types.h and other types and modifier are declared and documented in include/linux/gfp.h.\nSpecify options for the allocated memory:\n·  Action modifiers ( How should the memory be allocated? )\n\n· Zone modifiers ( From which zone should the allocated memory come )\n\nKernel allocates from ZONE_NORMAL or ZONE_DMA with a strong preference for ZONE NORMAL when there is no flag specified.\n· Type flags ( Combination of action and zone modifiers )\nGFP_ATOMIC, GEP_NOWAIT, GFP_NOIO, GFP_NOFS, GFP_KERNEL, GFP_USER, GFP_DMA, GFP_HIGHUSER\nWhich flag to use.\n\nkfree\nMemory allocated with kmalloc() needs to be freed with kfree()(declared in include/linux/slab.h).\n12345678struct my_struct *ptr;ptr = kmalloc(sizeof(struct my_struct), GEP_KERNEL);if(!ptr)&#123;  /* handle error. */&#125;/* work with ptr. */kfree(ptr);\nvmalloc()\nvmalloc()  allocates virtually contiguous pages that are not guarantee to map to physically contiguous ones.\n1void *vmalloc(unsigned long s i z e ) ; void vfree(const void *addr);\n123456789struct my_struct *ptr;ptr = vmalloc(sizeof(struct my_struct));if(!ptr) &#123;  /* handler error. */&#125;/* work with ptr. */vfree(ptr);\n1234567891011121314151617181920212223242526/* kmalloc() allocatedsizelimitation */#include &lt;linux/module.h&gt; #include &lt;linux/kernel.h&gt;#include &lt;linux/init.h&gt; #include &lt;linux/slab.h&gt;#define PRINT_PREF &quot;[KMALLOC_TEST]: &quot;static int _init my_mod_init(void) &#123;  unsigned long i ; void *ptr;\tprintk(PRINT_PREF &quot;Entering module.¥n&quot;);\tfor(i=1;;i*=2) &#123;\t\tptr = kmalloc(i, GFP_KERNEL);     if(!ptr) &#123;\t\t\tprintk(PRINT_PREF &quot;could not allocate %lu bytes¥n&quot;, i);      break;\t\t&#125;\t\tkfree(ptr);  &#125;  return 0;&#125;static void _exit my_mod_exit(void) &#123;  printk(KERN_INFO &quot;Exiting module.¥n&quot;);&#125;module_init(my_mod_init);module_exit(my_mod_exit); MODULE_LICENSE(&quot;GPL&quot;);\nPart.7 Slab layer\nAllocating/freeing data structures is done very often in the kernel and the data should be cached. An allocator aware of data structure size, page size, and total cache size is more efficient and should be NUMA-aware and implement cache-coloring.\nSlab layer/slab allocator: Linux’s generic allocation caching interface. Each cache contains one or several slabs( physically contiguous pages). Slabs contain objects(actual data structure slots). In order to reduce the fragmentation, allocation requests are served from partial slabs if present and a new empty slab is actually allocated in case the cache is full.\n123456/* a new cache is crested using: */struct kmem_cache *kmem_cache_create(const char *name,                                      size_t size,                                     size_t align,                                      unsigned long flags,                                     void (*ctor)(void *));\n\nFlags\n\nSLAB_HW_CACHEALIGN: Each object in a slab is aligned to a cache line.\nSLAB_POISON : Fill the slab with know values (a5a5a5a5) to detect accesses to uninitialized memory.\nSLAB_PANIC: Slab layer panics if the allocation fails.\nSLAB_CACHE_DMA: Allocation made from DMA-enabled memory.\nSLAB_RED_ZONE : Extra padding around objects to detect buffer overflows.\n\n\n1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253/* Slab layer usage example */#include &lt;linux/module.h&gt; #include &lt;linux/kernel.h&gt; #include &lt;linux/init.h&gt; #include &lt;linux/slab.h&gt;#define PRINT_PREF &quot;[SLAB_TEST] &quot;struct my_struct &#123;   int int_param;  long long_param; &#125;;static int _init my_mod_init(void) &#123;  int ret=0;\tstruct my_struct *ptr1, *ptr2;   struct kmem_cache *my_cache;\tprintk(PRINT_PREF &quot;Entering module.¥n&quot;);\tmy_cache = kmem_cache_create(&quot;pierre-cache&quot;,                                sizeof(struct my_struct), 0, 0, NULL);\tif(!my_cache) return -1;  ptr1 = kmem_cache_alloc(my_cache, GFP_KERNEL);\tif(!ptr1)&#123;    ret = -ENOMEM;\t\tgoto destroy_cache;  &#125;  \tptr2 = kmem_cache_alloc(my_cache, GFP_KERNEL);\tif(!ptr2)&#123;    ret = -ENOMEM;     goto freeptr1;\t&#125;\tptr1-&gt;int_param =42;   ptr1-&gt;long_param = 42;   ptr2-&gt;int_param =43;  ptr2-&gt;long_param = 43;    printk(PRINT_PREF &quot;ptr1 = &#123;%d, %ld&#125; ; ptr2 = &#123;%d, %ld&#125;¥n&quot;,          ptr1-&gt;int_param, ptr1-&gt;long_param, ptr2-&gt;int_param,          ptr2-&gt;long_param);    kmem_cache_free(my_cache, ptr2);  freeptr1:  \t\tkmem_cache_free(my_cache, ptr1);  destroy_cache:   \t\tkmem_cache_destroy(my_cache);      return ret;&#125;static void _exit my_mod_exit(void) &#123;  printk(KERN_INFO &quot;Exiting module.¥n&quot;);&#125;module_init(my_mod_init); module_exit(my_mod_exit);MODULE_LICENSE(&quot;GPL&quot;);\nPart.8 Stack, high memory and per-cpu allocation\nStack\nA user-space stack for execution in user space and it is is large and grows dynamically.\nA kernel stack for execution in the kernel and it is small and has a fixed-size (Generally 8KB on 32-bit architectures and 16KB on 64-bit).\nUse a per-cpu stack (1 single page) dedicated to interrupt handlers.\nHigh memory allocation\nOn x86_32, physical memory above 896MB is not permanently mapped within the kernel address space. Because of the limited size of the address space and the 1G/3G kernel/user-space physical memory split. Before usage, pages from highmem must be mapped after allocation.\nPermanent mapping (include/linux/highmem.h):\n1void *kmap(struct page *page);\n· Works on low and high memory.\n· Maps (update the page table) and return the given\n· May sleep, use only in process context\n· Number of permanent mappings is limited, unmap when done:\n1void kunmap(struct page *page);\n12345678910111213141516171819202122232425262728293031323334353637#include &lt;linux/module.h&gt; #include &lt;linux/kernel.h&gt; #include &lt;linux/init.h&gt; #include &lt;linux/gfp.h&gt; #include &lt;linux/highmem.h&gt;#define PRINT_PREF &quot;[HIGHMEM]: &quot; #define INTS_IN_PAGE (PAGE_SIZE/sizeof(int))static int _init my_mod_init(void) &#123;  struct page *my_page;   void *my_ptr;\tint i, *int_array;\tprintk(PRINT_PREF &quot;Entering module.¥n&quot;);     my_page = alloc_page(GFP_HIGHUSER);\tif(!my_page) return -1;  \tmy_ptr = kmap(my_page);   int_array = (int *)my_ptr;    for(i=0; i&lt;INTS_IN_PAGE; i++) &#123;     int_array[i] = i;    printk(PRINT_PREF &quot;array[%d] = %d¥n&quot;, i, int_array[i]);  &#125;    kunmap(my_page);   free_pages(my_page, 0);  return 0;&#125;static void _exit my_mod_exit(void) &#123;  printk(PRINT_PREF &quot;Exiting module.¥n&quot;);&#125;module_init(my_mod_init); module_exit(my_mod_exit);\nTemporary mappings: Also called atomic mappings as they can be used from interrupt context and uses a per-cpu pre-reserved slot. Do not sleep while holding a temporary mapping.\n12void *kmap_atomic(struct page *page);void kunmap_atomic(void *addr);\n123456789101112131415161718192021222324252627282930313233343536#include &lt;linux/module.h&gt; #include &lt;linux/kernel.h&gt; #include &lt;linux/init.h&gt; #include &lt;linux/gfp.h&gt; #include &lt;linux/highmem.h&gt;#define PRINT_PREF &quot;[HIGHMEM_ATOMIC]: &quot; #define INTS_IN_PAGE (PAGE_SIZE/sizeof(int))static int _init my_mod_init(void) &#123;  struct page *my_page;   void *my_ptr;\tint i, *int_array;\tprintk(PRINT_PREF &quot;Entering module.¥n&quot;);    my_page = alloc_page(GFP_HIGHUSER);\tif(!my_page) return -1;  my_ptr = kmap_atomic(my_page);   int_array = (int *)my_ptr;    for(i=0; i&lt;INTS_IN_PAGE; i++) &#123;    int_array[i] = i;\t\tprintk(PRINT_PREF &quot;array[%d] = %d¥n&quot;, i , int_array[i]);  &#125;  \tkunmap_atomic(my_ptr);   __free_pages(my_page, 0);  return 0;&#125;static void _exit my_mod_exit(void) &#123;  printk(PRINT_PREF &quot;Exiting module.¥n&quot;);&#125;module_init(my_mod_init); module_exit(my_mod_exit);\nPer-cpu\nPer-cpu data: data that is unique to each CPU (i.e. each core)  and is implemented through arrays in which each index corresponds to a CPU.\n1unsigned long my_percpu[NR_CPUS]; /* NR_CPUS contains the number of cores */\n12345int cpu;cpu = get_cpu(); /* get current CPU, disable kernel preemption */my_percpu[cpu]++; /* access the data */put_cpu(); /* re-enable kernel preemption */\nDisabling kernel preemption(get cpu()/put cpu()) while accessing per-cpu data is necessary.\nPreemption then reschedule on another core → cpu not valid anymore.\nAnother task preempting the current one might access the per-cpu data → race condition.\nLinux provides an API to manipulate per-cpu data: percpu in  include/linux/percpu.h\n123456789/* Compile-time per-cpu data structure usage: */DEFINE_PER_CPU(type, name) ; /* Creation *//* To refer to a per-cpu data structure declared elsewhere */DECLARE_PER_CPU(name, type); /* Data manipulation */get_cpu_var(name)++; /* increment name on this CPU */ put_cpu_var(name);  /* Done, disable kernel preemption *//* Access another CPU data */per_cpu(name, cpu)++; /* increment name on the given CPU */\n1234567891011/* Per-cpu data at runtime *//* Allocation */struct my_struct *my_var = alloc_percpu(struct my_struct); if(!my_var) &#123;/* allocation error */&#125;/* Manipulation: */get_cpu_var(my_var)++;put_cpu_var(my_var);/* Deallocation: */free_percpu(my_var);\nBenefits of per-cpu data:\n· Removes/minimizes the need for locking.\n· Reduces cache thrashing.Processor access local data so there is less cache coherency overhead (invalidation) in multicore systems.\n1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950/* Per-CPU allocation: usage example (static) */#include &lt;linux/module.h&gt;#include &lt;linux/kernel.h&gt;#include &lt;linux/init.h&gt;#include &lt;linux/percpu.h&gt;#include &lt;linux/kthread.h&gt;#include &lt;linux/sched.h&gt;#include &lt;linux/delay.h&gt;#include &lt;linux/smp.h&gt;#define PRINT_PREF &quot;[PERCPU] &quot;struct task_struct *thread1, *thread2, *thread3;DEFINE_PER_CPU(int, my_var) ; static int thread_function(void *data) &#123;  while(!kthread_should_stop()) &#123;    int cpu;    get_cpu_var(my_var)++;    cpu = smp_processor_id();\t\tprintk(&quot;cpu[%d] = %d¥n&quot;,           cpu, get_cpu_var(my_var));     put_cpu_var(my_var);    msleep(500);  &#125;  do_exit(0);&#125;static int _init my_mod_init(void) &#123;  int cpu;\tprintk(PRINT_PREF &quot;Entering module.¥n&quot;);  for(cpu=0; cpu&lt;NR_CPUS; cpu++) per_cpu(my_var, cpu) = 0;\t  wmb();\tthread1 = kthread_run(thread_function, NULL, &quot;percpu-thread1&quot;);\tthread2 = kthread_run(thread_function, NULL, &quot;percpu-thread2&quot;);\tthread3 = kthread_run(thread_function, NULL, &quot;percpu-thread3&quot;);\treturn 0;&#125;static void exit my_mod_exit(void) &#123;  kthread_stop(thread1);   kthread_stop(thread2);   kthread_stop(thread3);\tprintk(KERN_INFO &quot;Exiting module.¥n&quot;);&#125;module_init(my_mod_init); module_exit(my_mod_exit);MODULE_LICENSE(&quot;GPL&quot;);\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960/* Per-CPU allocation: usage example (dynamic) */#include &lt;linux/module.h&gt; #include &lt;linux/kernel.h&gt; #include &lt;linux/init.h&gt;#include &lt;linux/percpu.h&gt; #include &lt;linux/kthread.h&gt; #include &lt;linux/sched.h&gt; #include &lt;linux/delay.h&gt;#include &lt;linux/smp.h&gt;#define PRINT_PREF &quot;[PERCPU] &quot;struct task_struct *thread1, *thread2, * thread3;void my_var2;static int thread_function(void *data) &#123;  while(!kthread_should_stop()) &#123;    int *local_ptr, cpu;    local_ptr = get_cpu_ptr(my_var2);     cpu = smp_processor_id();     (*local_ptr)++;\t\tprintk(&quot;cpu[%d] = %d¥n&quot;, cpu, *local_ptr);     put_cpu_ptr(my_var2);     msleep(500);  &#125;  do_exit(0);&#125;static int _init my_mod_init(void) &#123;  int *local_ptr;\tint cpu;\tprintk(PRINT_PREF &quot;Entering module.¥n&quot;);  \tmy_var2 = alloc_percpu(int);  if(!my_var2) return -1;    for(cpu=0; cpu&lt;NR_CPUS; cpu++) &#123;    local_ptr = per_cpu_ptr(my_var2, cpu);    *local_ptr = 0;\t\tput_cpu();   &#125;  \twmb();\tthread1 = kthread_run(thread_function, NULL, &quot;percpu-thread1&quot;);\tthread2 = kthread_run(thread_function, NULL, &quot;percpu-thread2&quot;);\tthread2 = kthread_run(thread_function, NULL, &quot;percpu-thread2&quot;);\treturn 0;&#125;static void exit my_mod_exit(void) &#123;  kthread_stop(thread1);  kthread_stop(thread2);  kthread_stop(thread3);  free_percpu(my_var2);  printk(KERN_INFO &quot;Exiting module.¥n&quot;);&#125;module_init(my_mod_init);module_exit(my_mod_exit); sMODULE_LICENSE(&quot;GPL&quot;);\nChoosing the right allocation method\nNeed physically contiguous memory?\n· kmalloc() or low-level allocator, with flags:\nGFP_KERNELif sleeping is allowed.\nGFP_ATOMIC otherwise.\nNeed large amount of memory, not physically contiguous:\n· vmalloc()\nFrequently creating/destroying large amount of the same data structure:\n· Use the slab layer\nNeed to allocate from high memory?\n· Use alloc_page() then kmap() or kmap_atomic().\n","plink":"https://oreodu.github.io/2020/20201025-Memory-Management/"},{"title":"Process Management","date":"2020-10-24T02:13:00.000Z","date_formatted":{"ll":"Oct 24, 2020","L":"10/24/2020","MM-DD":"10-24"},"updated":"2020-10-28T08:31:19.830Z","content":"Process Management\nPart.1 Process\nEvery application(program) comes into execution through means of process, process is a running instance of a program. Processes are created through different system calls, most popular are fork() and exec().\nThe fork() creates a new process by duplicating the calling process, The new process, referred to as child, is an exact duplicate of the calling process, referred to as parent.\nIn computing, exec is a functionality of an operating system that runs an executable file in the context of an already existing process, replacing the previous executable.  As a new process is not created, the process identifier (PID) does not change, but the machine code, data, heap, and stack of the process are replaced by those of the new program.\n\nTutorial on [fork()](http://www.csl.mtu.edu/cs4411.ck/www/NOTES/ process/fork/create.html) usage.\nCombining  fork() and exec(). (execl(), execlp(), execle(), execv(), execvp(), execve())\n12345678910111213if (fork() == 0)&#123;\t\t//child process\t\tchar * execve_str[] = &#123;&quot;env&quot;,NULL&#125;;\t\tchar * env[] = &#123;&quot;PATH=/tmp&quot;, &quot;USER=lei&quot;, &quot;STATUS=testing&quot;, NULL&#125;;\t\tif (execve(&quot;/usr/bin/env&quot;,execve_str,env) &lt;0 )&#123;\t\t\tperror(&quot;error on exec&quot;);\t\t\texit(0);\t\t&#125;&#125;else&#123;\t\t//parent process\t\twait(&amp;childpid);\t\tprintf(&quot;execve done\\n\\n&quot;);&#125;\nPart.2 The process descriptor\nSee more details from here or here.\nIn the Linux kernel, processes are defined as task_struct structures in include/linux/sched.h, line 281. This structure contains every relevant information about a process.\nList of processes implemented as a linked list of task struct. It is dynamically allocated (heap) through the slab allocator.\nQuick access to task struct of the task currently running on a core: arch/x86/include/asm/current.h.\n\n1234567891011121314151617181920/* Full structure definition in linux/sched.h */struct tastk_struct &#123; \tvolatile long state;   void *stack;\t/* ... */\tint prio;   /* ... */\tcpumask_t cpus_allowed;\t/* ... */\tstruct list_head tasks;   /* ... */\tstruct mm_struct *mm;   /* ... */\tpid_t pid;\t/* ... */\tstruct task_struct *parent;  struct list_head children;\tstruct list_head sibling;   /* ... */&#125;\nProcess states\nState field of the task struct:\n· TASK_RUNNING:\nProcess is runnable (running or in a CPU run queue) In user or kernel space.\n· TASK_INTERRUPTIBLE:\nProcess is sleeping waiting for some condition.\nSwitched to TASK RUNNING on condition true or signal received.\n· TASK_UNINTERRUPTIBLE:\nSame as TASK INTERRUPTIBLE but does not wake up on signal.\n· TASK_TRACED:\nTraced by another process(ex:debugger)\n· TASK_STOPPED:\nNot running nor waiting,result of the reception of some signals to pause the process.\n\nProcess hierarchy\n· Root: init, PID 1\nLaunched by the kernel as the last step of the boot process.\n· fork-based process creation:\nEach process has aparent: parent pointer in the task_struct.\n· Processes may have children: children field(list head).\n· Processes may have siblings: siblings field.\n· List of all tasks: tasks field.\nEasy manipulation through next task(t) and for eachprocess(t).\nPart.3 Process creation\nLinux does not implements creating a tasks from nothing.\nfork() &amp; exec()\n· fork() creates a child, copy of the parent process. Only PID, PPID and some resources/stats differ. Linux duplicates the parent page tables and creates a new process descriptor.\nPage table access bits: read-only.\nCopy-On-Write (COW): memory pages are copied only when they are referenced for write operations.\n· exec() loads into a process address space a new executable.\nForking : fork() and vfork()\nfork() is implemented by the clone() system call. sys_clone() calls do_fork(), which calls copy_process() and starts the new task.\ncopy_process():\n\nCalls dup_tasks_truct(). Duplicates kernel stack, task_struct and thread_info.\nChecks that we do not overflow the processes number limit.\nSmall amount of values are modified in the task_struct.\nCalls sched_fork() to set the child state set to TASK_NEW .\nCopies parent info: files, signal handlers, etc.\nGets a new PID through alloc_pid().\nReturns a pointer to the created child task_struct.\n\nFinally, do_fork() calls wake up new_task(). State becomes TASK_RUNNING\nvfork(): alternative without copy of the address space.\n1234567891011121314151617181920212223242526272829/* ProcessCreation.c */#include &lt;stdio.h&gt;#include &lt;stddef.h&gt;#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/wait.h&gt;int main(void)&#123;  int status;  pid_t pid;  pid = fork();  if (pid == 0) &#123;      /* This is the child process.  print my student id. */      printf(&quot;My student id is : 31206833\\n&quot;);      exit(0);  &#125;else if (pid &lt; 0) &#123;      /* The fork failed.  Report failure.  */      perror(&quot;fork&quot;);      return EXIT_FAILURE;  &#125;else&#123;     /* This is the parent process.  Wait for the child to complete.  */     if (waitpid (pid, &amp;status, 0) != pid)       status = -1;     return status;  &#125;&#125;\nPart.4 Threads\nThreads are concurrent flows of execution belonging to the same program sharing the same address space.\n\nIn Linux there is no concept of a thread.\n\nNo scheduling particularity.\nA thread is just another process sharing some information with other processes.\nEach thread has its own task_struct.\nCreated through clone() with specific flags indicating sharing. More information form here.\n\n1234567891011121314151617181920212223242526272829303132333435363738394041/* ThreadCreation.c */#define _GNU_SOURCE#include &lt;sched.h&gt;#include &lt;sys/wait.h&gt;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;#define STACK_SIZE 4096#define errExit(msg)    do &#123; perror(msg); exit(EXIT_FAILURE);&#125; while (0)int childFunc() &#123;    printf(&quot;My student id is : 312. \\n&quot;);    sleep(1);    printf(&quot;Terminating func...\\n&quot;);    return 0;&#125;int main(void)&#123;    printf(&quot;In the main.&quot;);    char *stack;    char *stackTop;    pid_t pid;        stack = malloc(STACK_SIZE);    if (stack == NULL)        errExit(&quot;malloc&quot;);    stackTop = stack + STACK_SIZE;      pid = clone(&amp;childFunc, stackTop, CLONE_VM｜CLONE_VFORK， 0);    if (pid == -1)        errExit(&quot;clone&quot;);    printf(&quot;clone() returned %ld\\n&quot;, (long) pid);    sleep(1);    free(stack);    exit(0);&#125;\nKernel threads\nKernel threads are schedulable entities (like regular processes) and do not have their own address space( mm  in task_struct is NULL).\nKernel threads are all forked from the kthread  kernel thread (PID 2), using clone(). To create a kernel thread, use kthread_create() .\nWhen created through kthread_create(), the thread is not in a runnable state and need to call wake_up_process() or use kthread run().\nThread runs until it calls do exit() or until another part of the kernel calls kthread_stop().\nPart.5 Process termination\nTermination on invoking the exit() system call which can be implicitly inserted by the compiler on return from main. sys_exit() calls do_exit().\ndo exit() (kernel/exit.c):\n\nCall exit_signals() which set the PF EXITING flag in the task_struct\nSet the exit code in the exit_code field of the task_struct. (To be retrieved by the parent.)\nCall exit_mm() to release the mm_struct for the task. If it is not shared with any other process, it is destroyed.\nCall exit_sem():process dequeued from potential semaphores queues.\nCall exit_fs() and exit_files() to update accounting information. Potential data structures that are not used anymore are freed.\nCall exit_notify(). Send signals to parent and reparent potential children. Set the exit_state of the task_struct to EXIT ZOMBIE .\nCall do_taskdead(). Set the state to TASK DEAD ,  call schedule() and never returns.\n\nAt that point, what is left is the task_struct, thread info and kernel stack. To provide information to the parent. Parent notifies the kernel when everything can be freed.\ntask_struct cleanup:\n\n\nSeparated from the process of exiting because of the need to pass exit information to the parent. Until the parent grab the exit information through wait4().\n\n\nCleanup implemented in release_task() called from the wait4() implementation.\nRemove the task from the task list. Release and free remaining resources.\n\n\nA parent exits before its child. Child must be reparented(To another process in the current thread group or init if that fails).\nexit notify() calls forget_original_parent(), that calls find_newreaper(). Returns the task_struct of another task in the thread group if it exists, otherwise the one from init. Then, all the children of the currently dying task are reparented to the reaper.\n","plink":"https://oreodu.github.io/2020/20201024-Process-Management/"},{"title":"Linux Basics","date":"2020-10-23T04:43:00.000Z","date_formatted":{"ll":"Oct 23, 2020","L":"10/23/2020","MM-DD":"10-23"},"updated":"2020-10-24T02:17:46.464Z","content":"Linux Basics\nPart.1 History\n\n​            (From Advanced Operating Systems in The University of Tokyo)\nUnix:\nUnix is very popular and ported to multiple architectures due to its simple design and ease of use.\nSimplicity:\n➢ Small number of system calls with clearly defined design.\n➢ Everything is a file.\n➢ Written in C for portability.\n➢ Easy and fast process creation (fork()).\n➢ Simple and efficient Inter-Process Communication mechanisms (IPC).\nPart.2 Linux open source model\nBenefits of open source vs closed development:\n➢ Security, stability: Given enough eyeballs, all bugs are shallow.\n➢ Code quality.\n➢ Freely modifiable by anyone having an interest to do so.\n➢ Education, research:  We can PEEK at the code to understand how it works and we can POKE it to experiment and build new systems.\nPart.3 Linux Kernel\nSources are freely available.\nManages the hardware and provides interfaces or user space processes to access the hardware and perform privileged operations.\nMonolithic Model: Opposed to the microkernel model, Linux is monolithic. All the OS services run in kernel, privileged mode. System calls are the one and only way an application can enter the kernel to request OS services and privileged operations such as accessing the hardware.\nKernel vs user level programming:\n➢ No C library mostly because of speed and size. However, the kernel implements lots of usefull functions from the C library.\n➢ 2% assembly, the rest in GNU C (GCC extensions).\n➢ No memory protection.\n➢ Highly concurrent: Preemption, interrupts, running on SMP (Symmetric Multiprocessor System). Race conditions without proper synchronization.\n\n​      \t\t\t\t\t\t\t\t      (From Advanced Operating Systems in The University of Tokyo)\n\n​        \t\t\t\t\t\t\t       (From Advanced Operating Systems in The University of Tokyo)\nSystem calls\nSyscalls can be classified into groups:\n➢ Process management/scheduling: fork, exit, execve, nice,{get|set}priority,{get|set}pid, etc.\n➢ Memory management: brk, mmap, swap{on|of}, etc.\n➢ File system: open, read, write, lseek, stat, etc.\n➢ Inter-Process Communication: pipe, shmget, semget, etc.\n➢ Time management: {get|set}timeofday, time, timer create, etc.\n➢ Others: *{get|set}*uid, syslog, connect, etc.\nSystem calls table syscall identifier(unique integer).\n123450 common read sys_read1 common write sys_write2 common open sys_open3 common close sys_close# ...\nSyscall invocation(user space side)\n\n​\t\t\t\t\t\t\t\t\t\t   (From Advanced Operating Systems in The University of Tokyo)\nSyscalls are rarely invoked directly. Most of them are wrapped by the C library. The programmer uses the C library Application Programming Interface (API).\n\n​\t\t\t\t\t\t\t\t \t\t (From Advanced Operating Systems in The University of Tokyo)\nSystem calls behavior is documented in man pages.\n1man &lt;syscall name&gt;\nSome syscalls does not have a wrapper in the C library. A syscall can be called directly through syscall man syscall.(invocation without the wrapper)\n1bytes_written = syscall(SYS_write, 1, message, 14);\nOn x86 64, syscalls can be used directly through thesyscall assembly instruction.(invocation without the C library)\n1234567891011121314151617# syscall_asm.s\t\t\t.global _start      .text _start:\t\t\t\t# write(1, message, 14) \t\t\t\tmov $1, %rax\t\t\t\tmov $1, %rdi\t\t\t\tmov $message, %rsi         mov $14, %rdx         syscall\t\t\t\t        # exit(0)\t\t\t\tmov $60, %rax x        or %rdi, %rdi         syscallmessage:\t\t\t\t.ascii &quot;Hello, world!¥n&quot;\nSyscall execution(kernel space side)\nWhen an interrupt is received by the CPU, it stops whatever it is doing and the kernel executes the interrupt handler.\nInterrupts:\nAsynchronous: hardware interrupts, issued from devices.\nSynchronous: exceptions, triggered involuntarily by the program Itself.\nSynchronous, programmed exceptions: software interrupts, issued voluntarily by the code of the program itself.\nHow is a syscall invoked from user space:\n➢ User space put the syscall identifier and parameters values into registers (x86)\n➢ Then issues a software interrupt\n➢ The kernel executes the interrupt handler, system call handler.\nPuts the registers values into a data structure placed on the stack\nChecks the validity of the syscall (number of arguments)\nThen execute the system call implementation.\nHow to exchange data between user and memory areas with pointers:\n➢When a kernel function gets a pointer to some memory in user space it needs to use: The kernel copies it into its memory area (copy from user) .\n➢ When the kernel wants to write in a user space buffer: It uses copy to user.\nImplementing a new system call\n\nWrite your syscall function\nIn an existing file if it makes sense. Is it related to time management ? → kernel/time/time.c\nOr, if the implementation is large and self-contained: in a new file. You will have to edit the kernel Makefiles to integrate it in the compilation process.\nAdd it to the syscall table and give it an identifier\narch/x86/syscalls/syscall 64.tblfor Linux 4.0\nAdd the prototype in include/linux/syscalls.h.\n\n12asmlinkage long sys_gettimeofday(struct timeval_user *tv,                                  struct timezone_user *tz);\n\nRecompile, reboot and run. Touching the syscall table will trigger the entire kernel compilation\n\n➢ Pros: Easy to implement and use, fast\n➢ Cons:\nNeeds an official syscall number\nInterface cannot change after implementation\nMust be registered for each architecture\nProbably too much work for small exchanges of information\n➢ Alternative:\nDevice or virtual file:User/kernel space communication through read,write,ioctl.\nPart.4 Virtual machine\n\nI would classify virtual machine technologies into three categories (not all products fit clearly into one category):\n\nFull virtualization, i.e., complete hardware emulation. Examples: Qemu, Dosbox. Pro: you can potentially emulate any architecture on any hardware. Con: it’s the slowest way to do it.\nHardware-assisted virtualization, where you can emulate machine X on machine X. This can be a lot faster than full virtualization, because most instructions are executed natively, but you lose the ability to run a foreign architecture. There are two sub-categories:\nHypervisor-based VMs: you run several OSes alongside each other. The bottom layer, called the hypervisor, is a special-purpose OS that runs the VMs and nothing else. Examples: Xen, VMware ESX.\nHosted VMs: there is a main OS, the VM is an application on this main OS. Examples: VirtualBox, KVM.\nOS-level virtualization: you run several instances of the same OS. This can be in turn a lot more lightweight than hardware virutalization, but you lose some isolation and of course the ability to run different OSes. Examples: OpenVZ, FreeBSD jails.\n\n(From here.)\n\n\n​                                      \t\t\t\t           (KVM + Qemu. From here)\nGDB server: more details from here.\n","plink":"https://oreodu.github.io/2020/20201023-Linux-Basics/"},{"title":"Exercises in Lad","date":"2020-10-14T06:37:00.000Z","date_formatted":{"ll":"Oct 14, 2020","L":"10/14/2020","MM-DD":"10-14"},"updated":"2020-10-14T06:38:40.276Z","content":"Exercises\n研究テーマを決める前に、以下のプログラミング課題を一通り\n\n課題１：　A*　（基本的な探索アルゴリズムの実装、　高速なコードの実装）\nRussell &amp;Norvigで紹介された8パズルを、Ａ＊アルゴリズムを用いて解くプログラムを実装する。\n　　以下の３つの条件における性能（実行時間）を評価・比較する\na)　ヒューリスティック関数を使わないＡ＊（h(s)=0 for all states)\nb)  ゴールの位置にないタイルの数をヒューリスティックとする　　（Russell and Norvig p.106）\nb)  マンハッタン距離をヒューリスティックとする　　（Russell and Norvig p.106）\n評価実験は１００個以上のランダムに作成したパズル初期状態に対して行う。\n但し、単純ランダムにタイルを割り当てて初期状態を作ると、解が存在しない初期状態が多い。\n正しいパズルの初期状態の生成方法：　まず、正しい状態（＝ゴール状態）から、一歩ランダムな方向にに空タイルを移動する。\nこのように空タイルをランダムな方向に移動する作業を繰り返すとパズルはどんどん崩れるが、必ず解（ゴールまでの経路）が存在する。\n一般的には、ランダム移転数を増やすほど、「難しい」パズルが生成される。\n** C/C++で実装すればどんな問題でも1秒以内で解けるはず(信原君がRubyで実装したソルバは数秒以内で全ての問題が解けた）\n課題１A:　データ構造等の工夫で高速な１５パズルの実装を目指す\nまず、１５パズルのソルバを実装する（８パズルのソルバを作成していれば簡単なはず）。\nヒューリスティックはマンハッタン距離を使う。\n上記の８パズルのように１５パズルの問題をランダム生成すれば、かなり難しい問題が生成される。\n一秒間に展開されるノード数を測る（ソルバを実行して、終了時に生成されたノード数　/ 実行時間）。\n目標：　一秒間に１００万ノード以上生成するソルバを実装。\nある程度自力で頑張った後、以下の論文を読む。\nhttp://www.aaai.org/ocs/index.php/SOCS/SOCS12/paper/viewFile/5404/5682\n\n課題２\n任意の数独パズルを解くソルバを実装しなさい。\n入力ファイル：　以下のページの「test cases」にテキスト形式の問題集が置かれてます。\nhttp://www2.warwick.ac.uk/fac/sci/moac/people/students/peter_cock/python/sudoku/\n上のページには数独の解き方の解説も書かれてますが、\n殆ど一般性が無いアドバイスなので（全てのパズルを解く保障が無い）、解き方の解説は無視しましょう。\n正しい解き方はRusell&amp;Norvigの教科書の制約充足の章に紹介されている手法です。\n１）まず、深さ優先探索を用いたバックトラック法を実装\n２）更に効率良く解く為に、制約伝播(constraint propagation)を実装する。\n今回の課題の味噌は（２）です。\n正しく実装すれば、「難しい」と言われているパズルもミリ秒単位以内で解けます\n** 遠藤君が実装した制約伝播＋バックトラックを用いたPython ソルバ(PyPy JIT)は上記サイトのmsk_009問題集1,011門を全問解くのに要した時間が15秒。\n\n課題３\n数独の課題でバックトラック＋制約伝播はかなり強力な手法だと実感したと思います。\nでは、ＢＴ＋制約伝播はどこまで通用するのか、違う問題を通じて確認しましょう。\nついでに、そろそろ本物の学術論文を読み始めましょう。\nRussell&amp;Norvig 5.3 (p.151)にN-Queens問題が紹介されてます。\nこのN-Queens問題に対して：\n１）バックトラック法＋制約伝播を用いたソルバを実装する\n　　入力：　Queenの数N\n２）　局所探索法（min-conflicts法)を用いたソルバを実装する。\n制約充足における局所探索法は教科書（第２版）の制約充足の章で簡潔に説明されているが、\n教科書の洗練された説明だけでなく、原文を読む（当時、かなり大きなインパクトがあった有名な論文で、ＡＩ分野の「名作」の一つ。\nSolving Large-Scale Constraint Satisfaction and Scheduling Problems\nUsing a Heuristic Repair Method presented at the Eighth National\nConference on Artificial Intelligence (AAAI-90)\nhttps://www.aaai.org/Papers/AAAI/1990/AAAI90-003.pdf\nこの論文で紹介されたアルゴリズムを実装する。\n局所探索法のソルバを正しく、効率良く実装すれば、かなり大規模な問題が解けるはず。\n３）　上記ソルバ１，２、を比較する\n**遠藤君の結果（３・２６）\nN=1,000,000の問題を128秒で解けた(python, pypy JIT on 1.06GHz Core 2 Duo, 2GB RAM)\n\n課題４\n今度はN-Queens問題をboolean satisfiability (SAT)として表現し\nて解くプログラムを作りましょう。\n以下の資料(Chumin Li作)にNQueensSATモデルの概要が説明されている：\nhttps://sites.google.com/site/aflabinternal/sharedfiles/Li-SAT-modeling-slides.pdf?attredirects=0&amp;d=1\n但し、SATソルバは自分で作らず、\nネットから高性能のソルバを拾って利用する。例えば、\nhttp://minisat.se/   （他のソルバでも構わない）\nminisatf等が処理可能な標準ファイル形式(.cnf 形式)の説明：\nhttp://www.satcompetition.org/2009/format-benchmarks2009.html\n要するに、Queenの数Nを入力として、\n１）SATソルバが処理できる形式のファイルを作成、\n（この変換作業が今回の課題の味噌）\n２）SATソルバを実行、\n３）結果を読み込み、正しい解か確認\nminisatは基本的には制約伝播＋木探索なので局所探索には劣るが、汎用ＳＡＴソルバでどこまで解けるか実感する（前回作った、自作の制約伝播＋深さ優先探索ソルバと比較する）\n\n課題５：汎用なプランナと、問題に特化した探索アルゴリズムを比較する\n課題＃1で実装した8パズルのソルバと、最新の汎用プランナFast Downwardを比較する\n汎用プランナFast Downwardをダウンロードして、コンパイルする\nhttp://www.fast-downward.org/HomePage\nhttp://www.fast-downward.org/ObtainingAndRunningFastDownward\nFastDownwardを実装するには、問題(ドメイン）の一般的なモデルファイルおよび具体的な問題のインスタンスファイルが必要\nこのサイトから8パズルのモデル・インスタンスファイルのペア３問：eight01.pddl, eight01x.pddl　,\neight02,eight02x, eight03,eight03xをダウンロード：\nhttp://www.ida.liu.se/~TDDC65/ai/la/strips/\nまず、eight01.pddl, eight01x.pddlをなるべく理解する。\nPDDL形式を理解するには、まずはRussell&amp;Norvigのプランニングの章（１１）を復習。\nPDDL形式の入門的な説明 http://users.cecs.anu.edu.au/~patrik/pddlman/writing.html\n課題１で作った8パズルソルバの為に、eight01.pddl, eight01x.pddl… eight3x.pddlに相当する\n入力ファイルを作成する（自動的な変換でなく、手作業でＯＫ）。\n8パズルソルバとFastDownwardの探索性能を比較する：\nFast Downwardの実行：　http://www.fast-downward.org/PlannerUsage\n\n課題６：　進化計算\nBlack-box関数最適化contest\nhttp://www.ntu.edu.sg/home/EPNSugan/index_files/CEC2016/CEC2016.htm\nここで紹介されている４番目のtechnical report (single parameter)のベンチマーク問題に対する進化アルゴリズムを実装する。\nJ. J. Liang, B-Y. Qu, P. N. Suganthan, “Problem Definitions and Evaluation Criteria for the CEC 2014 Special Session and Competition on Single Objective Real-Parameter Numerical Optimization”, Technical Report 201311, Computational Intelligence Laboratory, Zhengzhou University, Zhengzhou, China  and  Technical Report, Nanyang Technological University, Singapore, December 2013. (Single parameter-operator set based case)\nまずは自分で考えて、何か実装する。\n次に、SHADEを実装してみる。\nhttp://metahack.org/CEC2013-SHADE.pdf\n参考に：田邊のコード（C++版、Java版　Matlab/Octave版）　https://sites.google.com/site/tanaberyoji/software\nハマったら、　今年のcontestに投稿してみる：　http://www.ntu.edu.sg/home/EPNSugan/index_files/CEC2017/CEC2017.htm\n","plink":"https://oreodu.github.io/2020/20201014-Exercises-in-Lad/"},{"title":"Mathematical Proof and Discussion of \"Fast and Slow Pointer\"","date":"2020-10-14T06:08:00.000Z","date_formatted":{"ll":"Oct 14, 2020","L":"10/14/2020","MM-DD":"10-14"},"updated":"2020-10-14T06:39:44.177Z","content":"Mathematical Proof and Discussion of  “Fast and Slow Pointer”\n\n\n https://math.stackexchange.com/questions/913499/proof-of-floyd-cycle-chasing-tortoise-and-hare\n\n\n\n https://hongyangyu.github.io/algorithm/2017/09/04/Fast-Pointer-and-Slow-Pointer/\n\n\n\n https://zhuanlan.zhihu.com/p/60736361\n\n\n\n https://www.jianshu.com/p/a821b0a15b51\n\n\n","plink":"https://oreodu.github.io/2020/20201014-Mathematical-Proof-and-Discussion-of-Fast-and-Slow-Pointer/"},{"title":"Collections in Java","date":"2020-10-13T01:06:00.000Z","date_formatted":{"ll":"Oct 13, 2020","L":"10/13/2020","MM-DD":"10-13"},"updated":"2020-10-13T01:07:30.140Z","content":"Collections in Java\n","plink":"https://oreodu.github.io/2020/20201013-Collection-in-Java/"},{"title":"Java Basics 03","date":"2020-10-07T08:13:00.000Z","date_formatted":{"ll":"Oct 7, 2020","L":"10/07/2020","MM-DD":"10-07"},"updated":"2020-11-23T01:12:50.015Z","content":"Java Basics 03\nPart.1 Iterator\nIterator is an interface which belongs to collection framework in the java.util.Iterator. It allows us to traverse the collection, access the data element and remove the data elements of the collection.\n123public interface Iterable&lt;Item&gt; &#123;    Iterator&lt;Item&gt; iterator();&#125;\n12345public interface Iterator&lt;Item&gt; &#123;    boolean hasNext();    Item next();    void remove(); // usually don&#x27;t use remove.&#125;\n12345678910111213141516public class SLLStack&lt;Item&gt; implements Iterable&lt;Item&gt; &#123;    //...    public class Iterator&lt;Item&gt; iterator() &#123;return new ListIterator();&#125;        private class ListIterator implements Iterator&lt;Item&gt; &#123;        private Node&lt;Item&gt; current = sentinel.next;                public boolean hasNext() &#123;return current != null;&#125;        public Item next() &#123;            Item item = current.item;            current = current.next;            return item;        &#125;    &#125;    // ...&#125;\n123456789101112public static void main(String[] args) &#123;    SLListStack&lt;Integer&gt; s = new SLListStack&lt;&gt;();    s.push(2);    s.push(5);    // s is iterable.    for(int n: s) System.out.println(n);    Iterator&lt;Integer&gt; i = SLListStack.iterator();    while(i.hasNext()) &#123;        int n = i.next();        System.out.println(n);    &#125;       &#125;\nPart.2 Testing\nAssertion: statement to test assumptions about the program.\nHelps detect logic bugs.\nDocument the code.\n12java -ea Myprogram &#x2F;&#x2F; enable assertionsjava -da Myprogram &#x2F;&#x2F; disable assertions (default)\nPart.3 Exception\n","plink":"https://oreodu.github.io/2020/20201007-Java-Basics-03/"},{"title":"Union Find","date":"2020-10-05T00:55:00.000Z","date_formatted":{"ll":"Oct 5, 2020","L":"10/05/2020","MM-DD":"10-05"},"updated":"2020-12-08T07:23:54.471Z","content":"Union-Find\nOverview\n(概略图)\n· materials:\n· Wikipedia\n· CS61B Spring 2019 at UCB\n· Algorithms, Part I,Ⅱ by Princeton University\n· You can see the implementations of those linear list here.\nA  disjoint-set data structure is a data structure that keeps track of a set of elements partitioned into a number of disjoint (non-overlapping) subsets.\nA  union-find algorithm is an algorithm that performs two useful operations on such a data structure:\n· Find: Determine which subset a particular element is in. Used to check if two elements are in the same subset.\n· Union: Join two subsets into a single subset.\nPart.1 Quik-Find (eager approach)\nData structure: Integer array id[] of length N\nInterpretation: p and q are connected iff they have the same id.\n     \n1234567891011121314151617181920212223public class QuickFind &#123;    private int[] id;    public QuickFind(int N) &#123;    id  = new int[N];    for(int i = 0; i &lt; N; i++) &#123;      id[i] = i;    &#125;  &#125;    public boolean connected(int p, int q) &#123;    return id[p] == id[q];  &#125;    //change all entries whose id equals id[p] to id[q].  public void union(int p,int q) &#123;      int pid = id[p];      int qid = id[q];      for (int i = 0; i&lt;id.length; i++)          if (id[i] == pid) id[i] = qid;  &#125; &#125;\nPart.2  Quik-Union (lazy approach)\nData structure: Integer array id[] of length N\nInterpretation: id[i] is the parent of i.\n        \n123456789101112131415161718192021222324public class QuickUnion &#123;    private int[] id;        public QuickUnion(int N) &#123;        id  = new int[N];        for(int i = 0; i&lt;N; i++) id[i] = i;    &#125;        private int root(int p) &#123;        while(p!=id[p]) p = id[p];        return p;    &#125;        public boolean connected(int p, int q) &#123;        return root(p) == root(q);    &#125;        // set the id of p&#x27;s root to the id of q&#x27;s root.    public void union(int p, int q)&#123;        int pr = root(p);        int qr = root(q);        id[pr] = qr;    &#125;&#125;\nPart.3 Improvement: Weighed quick union\nIn order to avoid tall trees, we can keep track of the size of each tree and balance by linking root of smaller tree to root of larger tree.\nData structure: Integer array id[] of length N and extra helper array size[].\n          \n123456789101112131415// Only need to change the union methodpublic void union(int p, int q)&#123;        int pr = root(p);        int qr = root(q);        if (pr == qr) return;        if (size[pr]&lt;size[qr]) &#123;            id[pr] = qr;            size[qr] += size[pr];        &#125;        else &#123;            id[qr] = pr;            size[pr] += size[qr];        &#125;    &#125;\nWe can also link the root based on the rank(or height). But tracking the size is better.\n\nPart.4 Improvement: path compression\nIn order to reduce the height of the trees, we can update the parent of the node to the root we found.\n123456789101112131415161718192021// Only need to change the root method.//add second loop to root() to set the id[] of each examined node to the root.private int root(int p) &#123;    int r = p;    while(r!=id[r]) r = id[r];    while(p!= id[p])&#123;        int tmp = id[p];        id[p] = r;        p = tmp;    &#125;    return r;&#125;// Make every other node in path point to its grandparentprivate int root(int p) &#123;    while(p!=id[p])&#123;        id[p] = id[id[p]];        p = id[p];    &#125;    return p;&#125;\nAnalysis of running time:\n(lg* : times you take logN to get one)\n\nUnion Find Application\n· Percolation.\n· Games (Go, Hex).\n· Dynamic connectivity.\n· Least common ancestor.\n· Equivalence of finite state automata.\n· Hinley-Milner polymorphic type inference.\n· Kruskal’s minimum spanning tree algorithm.\n· Compiling equivalence statements in Fortran.\n· Morphological attribute openings and closings.\n· Matlab’s bwlabel() function in image processing.\n","plink":"https://oreodu.github.io/2020/20201005-Union-Find/"},{"title":"Tree","date":"2020-10-05T00:50:00.000Z","date_formatted":{"ll":"Oct 5, 2020","L":"10/05/2020","MM-DD":"10-05"},"updated":"2020-12-23T10:26:00.420Z","content":"Tree\nOverview\n(概略图)\n· materials:\n· Wikipedia\nPart.1 Basis\nRecursive Description: A tree has a root and a list of branchesEach branch is a treeA tree with zero branches is called a leaf.\nRelative Description: Each location in a tree is called a nodeEach node has a label valueOne node can be the parent/child of another.\n\n1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162# Use the recursive description# We can also use the class to define the tree and its related attributes and methods.# Constructordef tree(label, branches=[]):    for branch in branches:        assert is_tree(branch)    return [label] + list(branches)# Selectorsdef label(tree):    return tree[0]def branches(tree):    return tree[1:]def is_tree(tree):    if type(tree) != list or len(tree) &lt; 1:        return False    for branch in branches(tree):        if not is_tree(branch):            return False    return Truedef is_leaf(tree):    return not branches(tree)print(tree(3, [tree(1),tree(2, [tree(1),tree(1)])])) # [3, [1], [2, [1], [1]]]# Tree processing# conut the nodes in a Treedef count_nodes(tree):    if is_leaf(tree): return 1    lst = [count_nodes(b) for b in branches(tree)]    return sum(lst,1)# count the leavesdef count_leaves(tree):    if is_leaf(tree): return [label(tree)]    # leaves = [count_leaves(b) for b in branches(tree)] #[[1],[[1],[1]]]    leaves = []    for b in branches(tree):        leaves += count_leaves(tree) # [1,1,1]    return leaves# print the treedef print_tree(tree,indent = 0):    print(&#x27; &#x27;*indent,label(tree))    for b in branches(tree):            print_tree(b,indent+1)# create a tree from an exsisted treedef square_tree(tree):    if is_leaf(tree): return tree(label(tree)**2)    lst = []    for b in brannches(tree):        lst += [suqare_tree(b)]    return tree(label(tree)**2,lst)# prune the tree def prune(t,x):    if label(t) == x: return null    branches(t) = [b for b in branches(t) if label(b) != x ]    for b in branchces():        prune( b,x)\nPart.2 Binary tree\nBinary tree is a tree in which each node has at most two children and it is empty or node with links to left and right binary trees.\n1. Definitions\nArray representation.\n・Indices start at 1.\n・Take nodes in level order.\n・No explicit links needed!\n2. properties\n3. Operations\nInsertion\nDeletion\nTraversal\n4. Types\nFull binary tree\n\nComplete binary tree\nPerfectly balanced, except for bottom level.\nProperty. Height of complete tree with N nodes is \n⎣lg N⎦\n\n\n\n\n\n\n⎣\n \n \n \n\n⎦\n\n\n.\n\nBalanced binary tree\n5. Applications\nSort and Search\nBinary heap\n\nDefinition\n\nBinary heap is defined as a binary tree with two additional constrains.\n· Shape property: it must be a complete binary tree, represented in level order in an array (not using the first entry).\n· Heap property: (partially ordered) the key stored in each node is either greater than or equal to or less than or equal to the keys in the node’s children, according to some total order.\n\nOperations and implementations\n\nBinary heap is usually represented by the array which is the same with the binary tree implementation above.\n\nBoth insert and remove operations are adding or removing from the end of the heap. Then in order to restore the heap property, we traverse up or down the heap.\nInsert\nTo add an element to a heap:\n\nAdd the element to the bottom level of the heap at the leftmost open space.\nCompare the added element with its parent; if they are in the correct order, stop.\nIf not, do the Bottom-up reheapify (swim) operation, swap the element with its parent and return to the previous step.()\n\nDelete\nTo delete the root(maximum in a max-heap or minimum in a min-heap)  or an arbitrary element from the heap:\n\nReplace the root of the heap with the last element on the last level.\nCompare the new root with its children; if they are in the correct order, stop.\nIf not, do the Top-down heapify (sink) operation, swap the element with one of its children and return to the previous step. (Swap with its smaller child in a min-heap and its larger child in a max-heap.)\n\nSearch\nFinding an arbitrary element takes O(n) time.\nBuilding a heap\nBuilding a heap from an array of n input elements can be done by starting with an empty heap, then successively inserting each element.\nOr we can treat the array as a binary tree of arbitrary order and start from the second lowest level and sift the root of each subtree downward until the heap property is restored.\nDecrease key\n· Find the index of the element we want to modify\n· Decrease the value of the node\n· Sink down (assuming a max heap) to restore the heap property\n**Increase key **\n· Find the index of the element we want to modify\n· Increase the value of the node\n· Swim up (assuming a max heap) to restore the heap property\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180package DataStructure;import java.util.Comparator;import java.util.Iterator;import java.util.NoSuchElementException;public class BinaryMaxHeap&lt;Key extends Comparable&lt;Key&gt;&gt; implements Iterable&lt;Key&gt; &#123;    private Key[] heap;    public int N = 0;    private static final int REFACTOR = 2;    private Comparator&lt;Key&gt; comparator;  // optional comparator    public BinaryMaxHeap() &#123;        this(1);    &#125;    public BinaryMaxHeap(Comparator&lt;Key&gt; comparator) &#123;        this(1, comparator);    &#125;    public BinaryMaxHeap(int capacity) &#123;        heap = (Key[]) new Comparable[capacity + 1];    &#125;    public BinaryMaxHeap(int capacity, Comparator&lt;Key&gt; comparator) &#123;        this.comparator = comparator;        heap = (Key[]) new Object[capacity + 1];    &#125;    public BinaryMaxHeap(Key[] a) &#123;        N = a.length;        heap = (Key[]) new Comparable[N + 1];        System.arraycopy(a,0, heap, 1, N);        for (int k = N/2; k &gt;= 1; k--) &#123;            sink(k);        &#125;        assert isBinaryMaxHeap();    &#125;    public boolean isEmpty() &#123;        return size() == 0;    &#125;    public int size() &#123;        return N;    &#125;    public Key max() &#123;        if (isEmpty()) throw new NoSuchElementException(&quot;The heap is underflow!&quot;);        return heap[1];    &#125;    public void insert(Key x) &#123;        /* pq maintains the smallest N items        if (N == pq.length) &#123;            if (x.compareTo(max()) &lt; 0) delete(1);            else return;        &#125;         */        if (x == null) throw new IllegalArgumentException(&quot;The key can&#x27;t be null!&quot;);        if (N == heap.length - 1) resize(REFACTOR * heap.length);        heap[++N] = x;        swim(N);        assert isBinaryMaxHeap();    &#125;    public Key delMax() &#123;        return delete(1);    &#125;    public Key delete(int i) &#123;        if (isEmpty()) throw new NoSuchElementException(&quot;Priority queue underflow&quot;);        Key max = heap[i];        exch(i, N--);        sink(i);        heap[N + 1] = null;  // prevent loitering        assert isBinaryMaxHeap();        return max;    &#125;    private void resize(int capacity) &#123;        assert capacity &gt; N;        Key[] newArray = (Key[]) new Comparable[capacity];        System.arraycopy(heap,0, newArray, 0, N + 1);        heap = newArray;    &#125;    /***************************************************************************     * Helper functions to restore the heap invariant.     ***************************************************************************/    private void swim(int k) &#123;        while (k &gt; 1 &amp;&amp; less(k/2, k)) &#123;            exch(k, k/2);            k = k / 2;        &#125;    &#125;    private void sink(int k) &#123;        while(2*k &lt;= N) &#123;            int j = 2 * k;            if (j &lt; N &amp;&amp; less(j, j+1)) j++;            if (!less(k, j)) break;            exch(k, j);            k = j;        &#125;    &#125;    /***************************************************************************     * Helper functions for compares and swaps.     ***************************************************************************/    private boolean less(int i, int j) &#123;        if (comparator == null) &#123;            return ((Comparable&lt;Key&gt;) heap[i]).compareTo(heap[j]) &lt; 0;        &#125;        else &#123;            return comparator.compare(heap[i], heap[j]) &lt; 0;        &#125;    &#125;    private void exch(int i, int j) &#123;        Key tmp = heap[i];        heap[i] = heap[j];        heap[j] = tmp;    &#125;    // is heap[1..n] a max heap?    private boolean isBinaryMaxHeap() &#123;        for (int i = 1; i &lt;= N; i++) &#123;            if (heap[i] == null) return false;        &#125;        for (int i = N+1; i &lt; heap.length; i++) &#123;            if (heap[i] != null) return false;        &#125;        if (heap[0] != null) return false;        return isMaxHeapOrdered(1);    &#125;    // is subtree of heap[1..n] rooted at k a max heap?    private boolean isMaxHeapOrdered(int k) &#123;        if (k &gt; N) return true;        int left = 2*k;        int right = 2*k + 1;        if (left  &lt;= N &amp;&amp; less(k, left))  return false;        if (right &lt;= N &amp;&amp; less(k, right)) return false;        return isMaxHeapOrdered(left) &amp;&amp; isMaxHeapOrdered(right);    &#125;    /***************************************************************************     * Iterator.     ***************************************************************************/    public Iterator&lt;Key&gt; iterator() &#123;        return new HeapIterator();    &#125;    public class HeapIterator implements Iterator&lt;Key&gt; &#123;        private BinaryMaxHeap&lt;Key&gt; copy;        public HeapIterator() &#123;            if (comparator == null) copy = new BinaryMaxHeap&lt;&gt;(size());            else copy = new BinaryMaxHeap&lt;&gt;(size(), comparator);            for (int i = 1; i &lt;= N; i++)                copy.insert(heap[i]);        &#125;        public boolean hasNext() &#123; return !copy.isEmpty(); &#125;        public void remove() &#123; throw new UnsupportedOperationException(); &#125;        public Key next() &#123;            if (!hasNext()) throw new NoSuchElementException();            return copy.delMax();        &#125;    &#125;    public static void main(String[] args) &#123;        Integer[] a = &#123;4,5,9,2,0&#125;;        BinaryMaxHeap&lt;Integer&gt; bh = new BinaryMaxHeap&lt;&gt;(a);        System.out.println(bh.max());    &#125;&#125;\n\nApplications\n\nSee more about Priority queue.\nSee more about Heapsort\nBinary search tree\n\nDefinition\n\nA binary search tree (BST) is a binary tree where each node has a Comparable key (and an associated value) and satisfies the restriction that the key in any node is larger than the keys in all nodes in that node’s left subtree and smaller than the keys in all nodes in that node’s right subtree.\n\n\nOperations and implementations\n\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334package DataStructure;import java.util.*;public class BST&lt;Key extends Comparable, Value&gt; &#123;    private Node root;    private class Node &#123;        private Key key;        private Value val;        private Node left, right;        private int size;  // number of nodes in subtree        public Node(Key key, Value val, int size) &#123;            this.key = key;            this.val = val;            this.size = size;        &#125;    &#125;    public BST() &#123;&#125;    public boolean isEmpty() &#123;        return size() == 0;    &#125;    public int size() &#123;        return size(root);    &#125;    private int size(Node x) &#123;        if (x == null) return 0;        else return x.size;    &#125;    public boolean contains(Key key) &#123;        if (key == null) throw new IllegalArgumentException(&quot;argument to contains() is null&quot;);        return get(key) != null;    &#125;    public Value get(Key key) &#123;        return get(root, key);    &#125;    private Value get(Node x, Key key) &#123;        if (key == null) throw new IllegalArgumentException(&quot;calls get() with a null key&quot;);        if (x == null) return null;        int cmp = key.compareTo(x.key);        if (cmp &lt; 0) return get(x.left, key);        else if (cmp &gt; 0) return get(x.right, key);        else return x.val;    &#125;    public void put(Key key, Value val) &#123;        if(key == null) throw new IllegalArgumentException(&quot;calls to put() with a null key&quot;);        if (val == null) &#123;            delete(key);            return;        &#125;        root = put(root, key, val);        assert check();    &#125;    private Node put(Node x, Key key, Value val) &#123;        if (x == null) return new Node(key, val, 1);        int cmp = key.compareTo(x.key);        if (cmp &lt; 0) x.left = put(x.left, key, val);        else if (cmp &gt; 0) x.right = put(x.right, key, val);        else  x.val = val;        x.size = 1 + size(x.left) + size(x.right);        return x;    &#125;    public void deleteMin() &#123;        if (isEmpty()) throw new NoSuchElementException(&quot;BST unberflow&quot;);        root = deleteMin(root);        assert check();    &#125;    private Node deleteMin(Node x) &#123;        if (x.left == null) return x.right;        x.left = deleteMin(x.left);        x.size = 1 + size(x.left) + size(x.right);        return x;    &#125;    public void deleteMax() &#123;        if (isEmpty()) throw new NoSuchElementException(&quot;BST underflow&quot;);        root = deleteMax(root);        assert check();    &#125;    private Node deleteMax(Node x) &#123;        if (x.right == null) return x.left;        x.right = deleteMax(x.right);        x.size = 1 + size(x.left) + size(x.right);        return x;    &#125;    public void delete(Key key) &#123;        if (key == null) throw new IllegalArgumentException(&quot;calls delete() with a null key&quot;);        root = delete(root, key);    &#125;    private Node delete(Node x, Key key) &#123;        if (x == null) return null;        int cmp = key.compareTo(x.key);        if (cmp &gt; 0) x.right = delete(x.right, key);        else if (cmp &lt; 0) x.left = delete(x.left, key);        else &#123;            if (x.left == null) return x.right;            if (x.right == null) return x.left;            Node t = x;            x = min(t.right);            x.right = deleteMin(t.right);            x.left = t.left;        &#125;        x.size = 1 + size(x.right) + size(x.left);        return x;    &#125;    public Key min() &#123;        if (isEmpty()) throw new NoSuchElementException(&quot;calls min() with empty BST&quot;);        return min(root).key;    &#125;    private Node min(Node x) &#123;        if (x.left == null) return x;        else return min(x.left);    &#125;    public Key max() &#123;        if (isEmpty()) throw new NoSuchElementException(&quot;calls max() with empty BTS&quot;);        return max(root).key;    &#125;    private Node max(Node x) &#123;        if (x.right == null) return x;        else return max(x.right);    &#125;    public Key floor(Key key) &#123;        if (key == null) throw new IllegalArgumentException(&quot;argument to floor is null&quot;);        if (isEmpty()) throw new NoSuchElementException(&quot;calls to floor with empty BST&quot;);        Node x = floor(root, key);        if (x == null) throw new NoSuchElementException(&quot;argument to floor() is too small&quot;);        else return x.key;    &#125;    private Node floor(Node x,Key key) &#123;        if (x == null) return null;        int cmp = key.compareTo(x.key);        if (cmp == 0) return x;        else if (cmp &lt; 0) return floor(x.left, key);        else &#123;            Node t = floor(x.right, key);            if (t != null) return t;            else return x;        &#125;    &#125;    public Key floor2(Key key) &#123;        Key x = floor2(root, key, null);        if (x == null) throw new NoSuchElementException(&quot;argument to floor() is too small&quot;);        else return x;    &#125;    public Key floor2(Node x, Key key, Key best) &#123;        if (x == null) return best;        int cmp = key.compareTo(x.key);        if (cmp &lt; 0) return floor2(x.left, key, best);        else if (cmp &gt; 0) return floor2(x.right, key, x.key);        else return x.key;    &#125;    public Key ceiling(Key key) &#123;        if (key == null) throw new IllegalArgumentException(&quot;argument to ceiling() is null&quot;);        if (isEmpty()) throw new NoSuchElementException(&quot;calls to ceiling() with empty BTS&quot;);        Node x = ceiling(root, key);        if (x == null) throw new NoSuchElementException(&quot;argument to floor() is too large&quot;);        else return x.key;    &#125;    private Node ceiling(Node x, Key key) &#123;        if (x == null) return null;        int cmp = key.compareTo(x.key);        if (cmp == 0) return x;        else if (cmp &gt; 0) return ceiling(x.right, key);        else &#123;            Node t = ceiling(x.left, key);            if (t != null) return t;            else return x;        &#125;    &#125;    public Key select(int rank) &#123;        if (rank &lt; 0 || rank &gt;= size()) &#123;            throw new IllegalArgumentException(&quot;argument to select() is invaild: &quot; + rank);        &#125;        return select(root, rank);    &#125;    private Key select(Node x, int rank) &#123;        if (x == null) return null;        int leftsize = size(x.left);        if (leftsize &gt; rank) return select(x.left, rank);        else if (leftsize &lt; rank) return select(x.right, rank - leftsize - 1);        else return x.key;    &#125;    public int rank(Key key) &#123;        if (key == null) throw new IllegalArgumentException(&quot;argument to rank() is null&quot;);        return rank(key, root);    &#125;    private int rank(Key key, Node x) &#123;        if (x == null) return 0;        int cmp = key.compareTo(x.key);        if (cmp &lt; 0) return rank(key, x.left);        else if (cmp &gt; 0) return 1 + size(x.left) + rank(key, x.right);        else return size(x.left);    &#125;    public Iterable&lt;Key&gt; keys() &#123;        if (isEmpty()) return new ArrayList&lt;Key&gt;();        return keys(min(), max());    &#125;    public Iterable&lt;Key&gt; keys(Key lo, Key hi) &#123;        if (lo == null) throw new IllegalArgumentException(&quot;first argument to keys() is null&quot;);        if (hi == null) throw new IllegalArgumentException(&quot;second argument to keys() is null&quot;);        Queue&lt;Key&gt; queue = new LinkedList&lt;&gt;();        keys(root, queue, lo, hi);        return queue;    &#125;    private void keys(Node x, Queue&lt;Key&gt; queue, Key lo, Key hi) &#123;        if (x == null) return;        int cmplo = lo.compareTo(x.key);        int cmphi = hi.compareTo(x.key);        if (cmplo &lt; 0) keys(x.left, queue, lo, hi);        if (cmplo &lt;= 0 &amp;&amp; cmphi &gt;= 0) queue.add(x.key);        if (cmphi &gt; 0) keys(x.right, queue, lo, hi);    &#125;    public int size(Key lo, Key hi) &#123;        if (lo == null) throw new IllegalArgumentException(&quot;first argument to size() is null&quot;);        if (hi == null) throw new IllegalArgumentException(&quot;second argument to size() is null&quot;);        if (lo.compareTo(hi) &gt; 0) return 0;        if (contains(hi)) return rank(hi) - rank(lo) + 1;        else return rank(hi) - rank(lo);    &#125;    public int height() &#123;        return height(root);    &#125;    private int height(Node x) &#123;        if (x == null) return -1;        return 1 + Math.max(height(x.left), height(x.right));    &#125;    public Iterable&lt;Key&gt; levelorder() &#123;        Queue&lt;Key&gt; keys = new LinkedList&lt;Key&gt;();        Queue&lt;Node&gt; queue = new LinkedList&lt;Node&gt;();        queue.offer(root);        while(!queue.isEmpty()) &#123;            Node x = queue.poll();            if (x == null) continue;            keys.offer(x.key);            queue.offer(x.left);            queue.offer(x.right);        &#125;        return keys;    &#125;    public boolean check() &#123;        if (!isBST()) System.out.println(&quot;Not in symmetric order!&quot;);        if (!isSizeConsistent()) System.out.println(&quot;Subtree counts not consistent!&quot;);        if (!isRankConsistent()) System.out.println(&quot;Ranks not consistent&quot;);        return isBST() &amp;&amp; isSizeConsistent() &amp;&amp; isRankConsistent();    &#125;    private boolean isBST() &#123;return isBST(root, null, null);&#125;    private boolean isBST(Node x, Key min, Key max) &#123;        if (x == null) return true;        if (min != null &amp;&amp; x.key.compareTo(min) &lt;= 0) return false;        if (max != null &amp;&amp; x.key.compareTo(max) &gt;= 0) return false;        return isBST(x.left, min, x.key) &amp;&amp; isBST(x.right, x.key, max);    &#125;    private boolean isSizeConsistent() &#123;return isSizeConsistent(root);&#125;    private boolean isSizeConsistent(Node x) &#123;        if (x == null) return true;        if (x.size != size(x.left) + size(x.right) + 1) return false;        return isSizeConsistent(x.left) &amp;&amp; isSizeConsistent(x.right);    &#125;    private boolean isRankConsistent() &#123;        for (int i = 0; i &lt; size(); i++)            if (i != rank(select(i))) return false;        for (Key key : keys())            if (key.compareTo(select(rank(key))) != 0) return false;        return true;    &#125;    public static void main(String[] args) &#123;        BST&lt;String, Integer&gt; st = new BST&lt;&gt;();        st.put(&quot;J&quot;, 8);        st.put(&quot;A&quot;, 9);        st.put(&quot;S&quot;, 1);        st.put(&quot;B&quot;, 2);        st.put(&quot;K&quot;, 4);        st.put(&quot;L&quot;, 3);        st.put(&quot;Q&quot;, 6);        st.put(&quot;M&quot;, 7);        System.out.println(&quot;The height of the tree is :&quot; + st.height());        System.out.println(&quot;The Ceiling of the key C is :&quot; + st.ceiling(&quot;C&quot;));        System.out.println(&quot;The floor of the key N is :&quot; + st.floor(&quot;N&quot;));        System.out.println(&quot;The rank of the key J is :&quot; + st.rank(&quot;J&quot;));        System.out.println(&quot;Select :&quot; + st.select(4));        st.deleteMax();        st.deleteMin();        for (String s: st.keys()) &#123;            System.out.println(&quot;Key:&quot; + s + &quot;, Value&quot; + st.get(s));        &#125;        System.out.println(&quot;-----&quot;);        for (String s: st.levelorder()) &#123;            System.out.println(&quot;Key:&quot; + s + &quot;, Value&quot; + st.get(s));        &#125;    &#125;&#125;\n\nApplications\n\nAssociative arrays.\nRed-Black tree\nB-tree\nEncoding\nHuffman coding and cladograms\n","plink":"https://oreodu.github.io/2020/20201005-Tree/"},{"title":"Hash Table","date":"2020-10-05T00:45:00.000Z","date_formatted":{"ll":"Oct 5, 2020","L":"10/05/2020","MM-DD":"10-05"},"updated":"2020-10-05T00:52:04.553Z","content":"Overview\n(概略图)\n· materials:\n· Wikipedia\n","plink":"https://oreodu.github.io/2020/20201005-Hash-Table/"},{"title":"Other Algorithms","date":"2020-09-24T07:53:25.000Z","date_formatted":{"ll":"Sep 24, 2020","L":"09/24/2020","MM-DD":"09-24"},"updated":"2020-10-03T18:17:00.959Z","content":"Other Algorithms\nOverview\n(概略图)\n· materials:\n· Algorithms  by Dasgupta, C. H. Papadimitriou, U. V. Vazirani\n· Efficient Algorithms and Intractable Problems  (CS170 2018 Fall at UCB)\n· Algorithm Design by John Kleinberg, Eva Tardos\n· CS61B Spring 2019 at UCB\n· Algorithms, Part I,Ⅱ by Princeton University\n· Wikipedia\n\n","plink":"https://oreodu.github.io/2020/20200924-Other-Algorithms/"},{"title":"Basic Algorithm Ideas","date":"2020-09-24T06:29:25.000Z","date_formatted":{"ll":"Sep 24, 2020","L":"09/24/2020","MM-DD":"09-24"},"updated":"2020-10-04T03:06:29.268Z","content":"Basic Algorithm Ideas\nOverview\n(概略图)\n· materials:\n· Algorithms  by Dasgupta, C. H. Papadimitriou, U. V. Vazirani\n· Efficient Algorithms and Intractable Problems  (CS170 2018 Fall at UCB)\n· Algorithm Design by John Kleinberg, Eva Tardos\n· CS61B Spring 2019 at UCB\n· Algorithms, Part I,Ⅱ by Princeton University\n· Wikipedia\nPart.1 Greedy Algorithms\nleft to complete\nPart.2 Divide and Conquer\nleft to complete\nPart.3 Recursion\nRecursion is useful for solving problems with a naturally repeating structure - they are defined in terms of themselves.\nIt requires you to find patterns of smaller problems, and to define the smallest problem possible\nStructure of a Recursive Function:\n1.One or more base cases, usually the smallest input.\n2.One or more ways of reducing the problem, and then solving the smaller problem using recursion.\n3.One or more ways of using the solution to each smaller problem to solve our larger problem.\nRecursion has three main components\nBase case/s: The simplest form of the problem\nRecursive call/s: Smaller version of the problem\nUse the solution to the smaller version of the problem to arrive at the solution to the original problem\nFunctional abstraction: When working with recursion, use functional abstraction: assume the recursive call gives the correct result.\nList out all the cases.\nIdentify patterns between each case.\nSimplify repeated code with recursive calls.\nVerifying the correctness of recursive functions:\nVerify that the base cases work as expected.\nFor each larger case, verify that it works by assuming the smaller recursive calls are correct.\n12345def cascade(n):    print(n)    if n &gt;= 10:        cascade(n // 10)        print(n)\nPart.4 Back Tracking\nPart.5 Dynamic Programing\nPart.6 Enumeration algorithm\n","plink":"https://oreodu.github.io/2020/20200924-Basic-Algorithm-Ideas/"},{"title":"Graphs","date":"2020-09-24T06:29:25.000Z","date_formatted":{"ll":"Sep 24, 2020","L":"09/24/2020","MM-DD":"09-24"},"updated":"2020-10-03T18:16:55.621Z","content":"Graphs\nOverview\n(概略图)\n· materials:\n· Algorithms  by Dasgupta, C. H. Papadimitriou, U. V. Vazirani\n· Efficient Algorithms and Intractable Problems  (CS170 2018 Fall at UCB)\n· Algorithm Design by John Kleinberg, Eva Tardos\n· CS61B Spring 2019 at UCB\n· Algorithms, Part I,Ⅱ by Princeton University\n· Wikipedia\n","plink":"https://oreodu.github.io/2020/20200924-Graphs/"},{"title":"Strings","date":"2020-09-24T06:29:25.000Z","date_formatted":{"ll":"Sep 24, 2020","L":"09/24/2020","MM-DD":"09-24"},"updated":"2020-10-03T18:17:06.331Z","content":"Strings\nOverview\n(概略图)\n· materials:\n· Algorithms  by Dasgupta, C. H. Papadimitriou, U. V. Vazirani\n· Efficient Algorithms and Intractable Problems  (CS170 2018 Fall at UCB)\n· Algorithm Design by John Kleinberg, Eva Tardos\n· CS61B Spring 2019 at UCB\n· Algorithms, Part I,Ⅱ by Princeton University\n· Wikipedia\n","plink":"https://oreodu.github.io/2020/20200924-Strings/"},{"title":"Java Basics 02","date":"2020-09-23T01:30:00.000Z","date_formatted":{"ll":"Sep 23, 2020","L":"09/23/2020","MM-DD":"09-23"},"updated":"2020-10-07T02:55:43.570Z","content":"Java Basics 02\n· materials:\n· CS61B Spring 2019 at UCB\n· Java Tutorial\n· The Java Language Environment by James Gosling and Henry McGilton\n· Wikipedia\n· Google Java Style Guide\nPart.1 Interfaces\nA collection of methods with no implementation is called an interface. Methods form the object’s interface with the outside world. The interface is a blueprint of a class and is a mechanism to achieve abstraction.\nⅠ. Defining an interface\nAn interface is a reference type that can contain only constants, abstract methods, default methods, static methods, and nested types \nnote: not including fields\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n\n. Method bodies exist only for default methods and static methods.\nEmpty interfaces\nwithout methods\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n \n \n \n \n \n \n \n \n \n \n \n \n \n\n can be used as types and to mark classes without requiring any particular method implementations. For an example of a useful empty interface, see java.io.Serializable.\nAll abstract, default, and static methods in an interface are implicitly public and all constant values defined are implicitly public, static, and final. Interfaces cannot be instantiated—they can only be implemented by classes or extended by other interfaces and they can extend any number of other interfaces.\nDefault method: defined in the interface with the keyword defualt and enable you to add new functionality with implementation to the interfaces and ensure binary compatibility with code written for older versions of those interfaces. Implementation class can override the default method.\nFor more information about default method here or here.\nStatic method: defined in the interface with the keyword static and contain the complete definition of the function and cannot be overridden or changed in the implementation class.\nAbstract method: declared without an implementation.\n123456789101112131415161718192021222324252627282930interface TestInterface &#123;     // abstract method     public void square (int a);     // static method     static void showStatic() &#123;         System.out.println(&quot;Static Method Executed&quot;);     &#125;    // default method     default void showDefault() &#123;       System.out.println(&quot;Default Method Executed&quot;);     &#125; &#125; class TestClass implements TestInterface &#123;     // Implementation of square abstract method     public void square (int a) &#123;         System.out.println(a*a);     &#125;     public static void main(String args[]) &#123;         TestClass d = new TestClass();         d.square(4);  // 16        d.showDefault(); // Default Method Executed        // Static method executed         TestInterface.showStatic(); // Static Method Executed    &#125; &#125;\nⅡ. Implementing an Interface\nTo declare a class that implements an interface, we should include an implements clause in the class declaration. The class can implement more than one interface. By convention, the implements clause follows the extends clause, if there is one.\n1234567public interface Relatable &#123;    // this (object calling isLargerThan) and other must be instances of     // the same class returns 1, 0, -1 if this is greater than,     // equal to, or less than other    public int isLargerThan(Relatable other);&#125;\n1234567891011121314151617181920212223242526272829303132public class RectanglePlus implements Relatable &#123;    public int width = 0;    public int height = 0;    public Point origin;    public RectanglePlus(int w, int h) &#123;        origin = new Point(0, 0);        width = w;        height = h;    &#125;    public RectanglePlus(Point p, int w, int h) &#123;        origin = p;        width = w;        height = h;    &#125;    // a method for computing the area of the rectangle    public int getArea() &#123;        return width * height;    &#125;    // a method required to implement the Relatable interface    public int isLargerThan(Relatable other) &#123;        RectanglePlus otherRect = (RectanglePlus)other;        if (this.getArea() &lt; otherRect.getArea())            return -1;        else if (this.getArea() &gt; otherRect.getArea())            return 1;        else            return 0;                   &#125;&#125;\nIf we want to be able to compare the size of similar objects instantiated from the class and there is some way to compare the relative “size” of them, the class that instantiates them should and can implement Relatable interface.\nⅢ. Using an Interface as a Type\nBecause interface is a reference data type so we can use the interface name as a data type, However if a reference variable whose type is an interface, any objects assigned to it should be an instance of the class that implements the interface and its value can reference any object that is instantiated from any class that implements the interface. This also means that an object can have multiple types: the type of its own class and the types of all the interfaces that the class implements.\n123456789// Any objects that are instantiated from a class that implements Relatable.public Object findLargest(Object object1, Object object2) &#123;   Relatable obj1 = (Relatable)object1;   Relatable obj2 = (Relatable)object2;   if ((obj1).isLargerThan(obj2) &gt; 0)      return object1;   else       return object2;&#125;\nWhen the classes implement Relatable, objects instantiated from those classes can be of both their own class \nor superclass\n\n\n\n\n\n\n\n\n\n\n\n\n \n \n \n \n \n \n \n \n \n \n \n \n\n type and a Relatable type. This gives them some of the advantages of multiple inheritance, where they can have behavior from both a superclass and an interface.\nⅣ. Evolving Interfaces\nNormally, once we finished developing the interface we cannot modify it because all the classes that implemented the interface will break. So try to anticipate all uses for the interface and specify it completely from the beginning. However, you have several other options.\n123456// create a DoItPlus interface that extends DoItpublic interface DoItPlus extends DoIt &#123;   boolean didItWork(int i, double x, String s);&#125;\n12345678910// define new methods as default methods or static methods.public interface DoIt &#123;   void doSomething(int i, double x);   int doSomethingElse(String s);   default boolean didItWork(int i, double x, String s) &#123;       // Method body    &#125;&#125;\nUsers who have classes that implement interfaces enhanced with new default or static methods do not have to modify or recompile them to accommodate the additional methods.\nⅤ. Enhance the interface\nInterface can be enhanced with default methods, static methods, lambda expressions, and method references to create more expressive library methods whose functionality programmers can quickly deduce by looking at how they are invoked. See more details here.\n1234567891011121314151617181920212223242526public class StandardDeck implements Deck &#123;    private List&lt;Card&gt; entireDeck;    // ...    public void sort(Comparator&lt;Card&gt; c) &#123;    Collections.sort(entireDeck, c);&#125;      // ...&#125;public class SortByRankThenSuit implements Comparator&lt;Card&gt; &#123;    public int compare(Card firstCard, Card secondCard) &#123;        int compVal =            firstCard.getRank().value() - secondCard.getRank().value();        if (compVal != 0)            return compVal;        else            return firstCard.getSuit().value() - secondCard.getSuit().value();     &#125;&#125;StandardDeck myDeck = new StandardDeck();myDeck.shuffle();myDeck.sort(new SortByRankThenSuit());\n123456789101112StandardDeck myDeck = new StandardDeck();myDeck.shuffle();myDeck.sort(    (firstCard, secondCard) -&gt;        firstCard.getRank().value() - secondCard.getRank().value()); /*// static method comparing in the Comparator interface// compares any object that can return a numerical value from a methodmyDeck.sort(Comparator.comparing((card) -&gt; card.getRank()));  myDeck.sort(Comparator.comparing(Card::getRank));  */\n12345678910111213141516171819202122232425StandardDeck myDeck = new StandardDeck();myDeck.shuffle();myDeck.sort(    (firstCard, secondCard) -&gt; &#123;        int compare =            firstCard.getRank().value() - secondCard.getRank().value();        if (compare != 0)            return compare;        else            return firstCard.getSuit().value() - secondCard.getSuit().value();    &#125;      ); /*// the default method thenComparingmyDeck.sort(    Comparator        .comparing(Card::getRank)        .thenComparing(Comparator.comparing(Card::getSuit)));//  the default method reversed      myDeck.sort(    Comparator.comparing(Card::getRank)        .reversed()        .thenComparing(Comparator.comparing(Card::getSuit)));*/\nPart.2 Inheritance\nCommon behavior can be defined in a superclass and inherited into a subclass using the extends keyword. Every class has one and only one direct superclass \n[why single inheritance?](https://docs.oracle.com/javase/tutorial/java/IandI/multipleinheritance.html)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n\n. In the absence of any other explicit superclass, every class is implicitly a subclass of Object, and each superclass has the potential for an unlimited number of subclasses.\n\n\nFrom Java Tutorials\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n\n\nA subclass inherits all of the public and protected members\nfields, methods, and nested classes\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n\n from its superclass, no matter what package the subclass is in. If the subclass is in the same package as its parent, it also inherits the package-private members of the parent. Constructors are not members, so they are not inherited by subclasses, but the constructor of the superclass can be invoked from the subclass.\nA subclass does not inherit the private members of its parent class. However, if the superclass has public or protected methods for accessing its private fields, these can also be used by the subclass. A nested class has access to all the private members of its enclosing class—both fields and methods. Therefore, a public or protected nested class inherited by a subclass has indirect access to all of the private members of the superclass.\nⅠ. Multiple Inheritance of State, Implementation, and Type\nMultiple Inheritance of State: the ability to inherit fields from multiple classes, which is not supported by Java because only single inheritance is allowed between and interface don’t have fields.\nMultiple Inheritance of Implementation: the ability to inherit method definitions from multiple classes. In Java, a class can implement more than one interface, which can contain default methods that have the same name. The Java compiler provides some rules to determine which default method a particular class uses.\nMultiple Inheritance of Type: the ability of a class to implement more than one interface. An object can have multiple types: the type of its own class and the types of all the interfaces that the class implements. This is more detailed in Part.1.Ⅲ.\nⅡ. Overriding and Hiding Methods\nInherited fields and methods can be used directly. Subclass can declare new fields and methods in the subclass that are not in the superclass.\nWithin a class, a field that has the same name as a field in the superclass hides the superclass’s field, even if their types are different.\n1）Instance Methods\nAn instance method in a subclass with the same signature \nname, plus the number and the type of its parameters\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n\n and return type\nor the subclass of the return type in super class\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n\n as an instance method in the superclass overrides the superclass’s method.\n2) Static Methods\nIf a subclass defines a static method with the same signature as a static method in the superclass, then the method in the subclass hides the one in the superclass.\nThe distinction between hiding a static method and overriding an instance method has important implications:\n\nThe version of the overridden instance method that gets invoked is the one in the subclass.\nThe version of the hidden static method that gets invoked depends on whether it is invoked from the superclass or the subclass.\n\n12345678public class Animal &#123;    public static void testClassMethod() &#123;        System.out.println(&quot;The static method in Animal&quot;);    &#125;    public void testInstanceMethod() &#123;        System.out.println(&quot;The instance method in Animal&quot;);    &#125;&#125;\n1234567891011121314151617public class Cat extends Animal &#123;    public static void testClassMethod() &#123;        System.out.println(&quot;The static method in Cat&quot;);    &#125;    public void testInstanceMethod() &#123;        System.out.println(&quot;The instance method in Cat&quot;);    &#125;    public static void main(String[] args) &#123;        Cat myCat = new Cat();        Animal myAnimal = myCat;        Animal.testClassMethod();        myAnimal.testInstanceMethod();    &#125;&#125;// The static method in Animal// The instance method in Cat\n3) Interface Methods\nStatic methods in interfaces are never inherited.\nDefault methods and abstract methods in interfaces are inherited like instance methods. However, when the supertypes of a class or interface provide multiple default methods with the same signature, the Java compiler follows inheritance rules to resolve the name conflict. These rules are driven by the following those principles:\n\n· If two or more independently defined default methods conflict, or a default method conflicts with an abstract method, then the Java compiler produces a compiler error and we must explicitly override the supertype methods. Instance methods are preferred over interface default methods.\n\n1234567891011121314151617181920public interface OperateCar &#123;    // ...    default public int startEngine(EncryptedKey key) &#123;        // Implementation    &#125;&#125;public interface FlyCar &#123;    // ...    default public int startEngine(EncryptedKey key) &#123;        // Implementation    &#125;&#125;public class FlyingCar implements OperateCar, FlyCar &#123;    // ...    public int startEngine(EncryptedKey key) &#123;        FlyCar.super.startEngine(key);        OperateCar.super.startEngine(key);    &#125;&#125;\n\n· When supertypes share a common ancestor，methods that are already overridden by other candidates are ignored.\n\n123456789101112131415161718public interface Animal &#123;    default public String identifyMyself() &#123;        return &quot;I am an animal.&quot;;    &#125;&#125;public interface EggLayer extends Animal &#123;    default public String identifyMyself() &#123;        return &quot;I am able to lay eggs.&quot;;    &#125;&#125;public interface FireBreather extends Animal &#123; &#125;public class Dragon implements EggLayer, FireBreather &#123;    public static void main (String... args) &#123;        Dragon myApp = new Dragon();        System.out.println(myApp.identifyMyself());    &#125;&#125;// I am able to lay eggs.\n\n· Inherited instance methods from classes can override abstract interface methods.\n\n1234567891011121314public interface Mammal &#123;    String identifyMyself();&#125;public class Horse &#123;    public String identifyMyself() &#123;        return &quot;I am a horse.&quot;;    &#125;&#125;public class Mustang extends Horse implements Mammal &#123;    public static void main(String... args) &#123;        Mustang myApp = new Mustang();        System.out.println(myApp.identifyMyself());    &#125;&#125;\nYou will get a compile-time error if you attempt to change an instance method in the superclass to a static method in the subclass, and vice versa.\nWe could use use the @Override annotation that instructs the compiler that you intend to override a method in the superclass.\nⅢ. Using the Keyword super\n1) Accessing Superclass Members\nWe can use the key word super to access the members in the superclass, either a overridden method or hidden field.\nsuper.overriddenMethod();\n2) Subclass Constructors\nWe can also use the super keyword to invoke a superclass’s constructor and invocation of a superclass constructor must be the first line in the subclass constructor.\nsuper(parameter list);\nConstructor chaining: If a subclass constructor invokes a constructor of its superclass, there will be a whole chain of constructors called, all the way back to the constructor of Object.\nⅣ. Object Class\nThe Object class, in the java.lang package, sits at the top of the class hierarchy tree. Every class is a descendant, direct or indirect, of the Object class. Every class you use or write inherits the instance methods of Object.\nSome methods inherited from Object :\n\n\nprotected Object clone() throws CloneNotSupportedException\nCreates and returns a copy of this object.\n\n\npublic boolean equals(Object obj)\nIndicates whether some other object is “equal to” this one.\n\n\nprotected void finalize() throws Throwable\nCalled by the garbage collector on an object when garbage\ncollection determines that there are no more references to the object\n\n\npublic final Class getClass()\nReturns the runtime class of an object.\n\n\npublic int hashCode()\nReturns a hash code value for the object.\n\n\npublic String toString()\nReturns a string representation of the object.\n\n\nThe notify, notifyAll, and wait methods of Object all play a part in synchronizing the activities of independently running threads in a program. There are five of these methods:\n\n\npublic final void notify()\n\n\npublic final void notifyAll()\n\n\npublic final void wait()\n\n\npublic final void wait(long timeout)\n\n\npublic final void wait(long timeout, int nanos)\nSee more details about the method here .\n\n\nⅤ. final and abstract\n1）Final\nIf it has an implementation that should not be changed and it is critical to the consistent state of the object, we use the final keyword in a method declaration to indicate that the method cannot be overridden by subclasses.\nMethods called from constructors should generally be declared final. If a constructor calls a non-final method, a subclass may redefine that method with surprising or undesirable results.\nWe can also declare an entire class final. A class that is declared final cannot be subclassed. This is particularly useful, for example, when creating an immutable class like the String class.\n2) Abstract\nAn abstract class is a class that is declared abstract—it may or may not include abstract methods. Abstract classes cannot be instantiated, but they can be subclassed. When an abstract class is subclassed, the subclass usually provides implementations for all of the abstract methods in its parent class. However, if it does not, then the subclass must also be declared abstract.\nAn abstract method is a method that is declared without an implementation \nwithout braces, and followed by a semicolon\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n\n. If a class includes abstract methods, then the class itself must be declared abstract.\nDifference between the abstract class and interface: Abstract class can declare fields that are not static and final and define public, protected, and private concrete methods .But we can extend only one class. See more details here.\nA class that implements an interface must implement all of the interface’s methods. It is possible, however, to define a class that does not implement all of the interface’s methods, provided that the class is declared to be abstract.\nⅥ. Casting Objects\nNormally, an object is of the data type of the class from which it was instantiated.\nCasting shows the use of an object of one type in place of another type, among the objects permitted by inheritance and implementations.\nImplicit casting: Object obj = new MountainBike(); Explicit casting: MountainBike myBike = (MountainBike)obj;\nPart.3 Annotation\nAnnotations, a form of metadata, provide data about a program that has no direct effect on the operation of the code they annotate. Annotations can be applied to any type use.\nThe use of annotations: · Information for the compiler — Annotations can be used by the compiler to detect errors or suppress warnings. · Compile-time and deployment-time processing — Software tools can process annotation information to generate code, XML files, and so forth. · Runtime processing — Some annotations are available to be examined at runtime.\nThe annotation type can be one of the types that are defined in the java.lang or java.lang.annotation packages of the Java SE API or custom annotation types.\nSee predefined annotation types and annotations that apply to other annotations here.\nⅠ. Declaring an Annotation Type\nAnnotation types are a form of interface.\n1234567891011121314151617181920212223242526@interface ClassPreamble &#123;   String author();   String date();   int currentRevision() default 1;   String lastModified() default &quot;N/A&quot;;   String lastModifiedBy() default &quot;N/A&quot;;   // Note use of array   String[] reviewers();&#125;// make the information in @ClassPreamble appear in Javadoc-generated documentation@Documented@ClassPreamble (   author = &quot;John Doe&quot;,   date = &quot;3/17/2002&quot;,   currentRevision = 6,   lastModified = &quot;4/12/2004&quot;,   lastModifiedBy = &quot;Jane Doe&quot;,   // Note array notation   reviewers = &#123;&quot;Alice&quot;, &quot;Bob&quot;, &quot;Cindy&quot;&#125;)public class Generation3List extends Generation2List &#123;// class code goes here&#125;\nⅡ. Apply the annotations\nAnnotations can be applied to declarations \ndeclarations of classes, fields, methods, and other program elements\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n\n and any type use \ntype annotation\n\n\n\n\n\n\n\n\n\n\n\n \n \n \n \n \n \n \n \n \n \n \n \n \n \n\n as follows : · class instance creation expression ： new @Interned MyObject(); · type cast： myString = (@NonNull String) str; · implements clause： class UnmodifiableList&lt;T&gt; implements @Readonly List&lt;@Readonly T&gt; &#123; ... &#125; · thrown exception declaration： void monitorTemperature() throws @Critical TemperatureException &#123; ... &#125;). · …\nType annotations were created to support improved analysis of Java programs way of ensuring stronger type checking. The Java SE 8 release does not provide a type checking framework, but it allows you to write \nor download\n\n\n\n\n\n\n\n\n\n\n \n \n \n \n \n \n \n \n \n \n\n a type checking framework that is implemented as one or more pluggable modules that are used in conjunction with the Java compiler.\nFor more information about the framework provided by third parties, see the Checker Framework created by the University of Washington.\nⅢ. Repeating Annotations\nRepeating annotations enable you to apply the same annotation to a declaration or type use.\nFor compatibility reasons, repeating annotations are stored in a container annotation that is automatically generated by the Java compiler.\n123@Schedule(dayOfMonth=&quot;last&quot;)@Schedule(dayOfWeek=&quot;Fri&quot;, hour=&quot;23&quot;)public void doPeriodicCleanup() &#123; ... &#125;\n1) Declare a Repeatable Annotation\n12345678import java.lang.annotation.Repeatable;@Repeatable(Schedules.class)public @interface Schedule &#123;  String dayOfMonth() default &quot;first&quot;;  String dayOfWeek() default &quot;Mon&quot;;  int hour() default 12;&#125;\nThe value of the @Repeatable meta-annotation, in parentheses, is the type of the container annotation that the Java compiler generates to store repeating annotations. In this example, the containing annotation type is Schedules, so repeating @Schedule annotations is stored in an @Schedules annotation.\n2) Declare the Containing Annotation Type\n123public @interface Schedules &#123;    Schedule[] value();&#125;\nSee the AnnotatedElement class specification for information on all of the available methods to retrieve annotations.\nPart.4 Numbers and Strings\nⅠ. Numbers\n1）Numbers classes\nThe Java platform provides wrapper classes for each of the primitive data types. The Java compiler automatically wraps \nboxes\n\n\n\n\n\n\n\n\n \n \n \n \n \n\n primitives for you when necessary and unboxes them, again when necessary. All of the numeric wrapper classes are subclasses of the abstract class Number:\n\nBigDecimal and BigInteger are used for high-precision calculations. AtomicInteger and AtomicLong are used for multi-threaded applications.\nThere are three reasons that you might use a Number object rather than a primitive: 1.As an argument of a method that expects an object \noften used when manipulating collections of numbers\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n\n. 2.To use constants defined by the class, such as MIN_VALUE and MAX_VALUE, that provide the upper and lower bounds of the data type. 3.To use class methods for converting values to and from other primitive types, for converting to and from strings, and for converting between number systems \ndecimal, octal, hexadecimal, binary\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n\n.\nThe instance methods that all the subclasses of the Number class implement: here.\n1234byte byteValue()int compareTo(Byte anotherByte)// Return true if they have the same type and with the same numeric value)boolean equals(Object obj)\n12345String s1 = &#x27;12.1&#x27;;String s2 = &#x27;13.2&#x27;;float a = (Float.valueOf(s1)).floatValue(); float b = Float.parseFloat(s2);System.out.println(&quot;a + b =  &quot; + (a + b));  // --&gt; 25.3\n123456double d = 858.48;String s = Double.toString(d);int i = 0;String s1 = &quot;&quot; + i;String s2 = String.valueOf(i);\n2) Formatting Numeric Print Output\n· The printf and format Methods\nThe java.io package includes a PrintStream class that has two formatting methods \n`format` and `printf`, equivalent to one another\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n\n that you can use to replace print and println. The familiar System.out is a PrintStream object, so we can invoke PrintStream methods on System.out.\n123456789101112131415161718192021public class TestFormat &#123;    public static void main(String[] args) &#123;      long n = 461012;      System.out.format(&quot;%08d%n&quot;, n);    //  --&gt;  &quot;00461012&quot;      System.out.format(&quot;%+,8d%n%n&quot;, n); //  --&gt;  &quot;+461,012&quot;      double pi = Math.PI;      System.out.format(&quot;%f%n&quot;, pi);       // --&gt;  &quot;3.141593&quot;      System.out.format(&quot;%.3f%n&quot;, pi);     // --&gt;  &quot;3.142&quot;      System.out.format(&quot;%10.3f%n&quot;, pi);   // --&gt;  &quot;     3.142&quot;      System.out.format(Locale.FRANCE,                        &quot;%-10.4f%n%n&quot;, pi); // --&gt;  &quot;3,1416&quot;      Calendar c = Calendar.getInstance();      System.out.format(&quot;%tB %te, %tY%n&quot;, c, c, c); // --&gt;  &quot;May 29, 2006&quot;      System.out.format(&quot;%tl:%tM %tp%n&quot;, c, c, c);  // --&gt;  &quot;2:34 am&quot;      System.out.format(&quot;%tD%n&quot;, c);    // --&gt;  &quot;05/29/06&quot;    &#125;&#125;\nFormat specifiers begin with a percent sign \n%\n\n\n and end with a converter. The converter is a character indicating the type of argument to be formatted. In between the percent sign \n%\n\n\n and the converter you can have optional flags and specifiers. There are many converters, flags, and specifiers, which are documented in java.util.Formatter or here.\n· The DecimalFormat Class\nYou can use the java.text.DecimalFormat class to control the display of leading and trailing zeros, prefixes and suffixes, grouping \nthousands\n\n\n\n\n\n\n\n\n\n\n\n \n \n \n \n \n \n \n \n \n\n separators, and the decimal separator.\n12345678910111213141516import java.text.*;public class DecimalFormatDemo &#123;   static public void customFormat(String pattern, double value ) &#123;      DecimalFormat myFormatter = new DecimalFormat(pattern);      String output = myFormatter.format(value);      System.out.println(value + &quot;  &quot; + pattern + &quot;  &quot; + output);   &#125;   static public void main(String[] args) &#123;      customFormat(&quot;000000.000&quot;, 123.78);      customFormat(&quot;$###,###.##&quot;, 1212345.679);  // 1212345.679 $###,###.## $1212,345.67   &#125;&#125;\n3) Beyond Basic Arithmetic\nThe Math class in the java.lang package provides methods and constants for doing more advanced mathematical computation. The methods in the Math class are all static, so you call them directly from the class.\n· Constants and Basic Methods\nMath.E, Math.PI\ntype abs(type t), type ceil(type t), type floor(type t), type rint(type t), int round(float t), type min(type t1, type t2), type max(type t1, type t2),\n· Exponential and Logarithmic Methods\ndouble exp(double d), double log(double d), double pow(double base, double exponent), double sqrt(double d),\n· Trigonometric Methods\ndouble sin(double d), …\n· Random Numbers\nThe random() method returns a pseudo-randomly selected number \\(0.0 &lt;= Math.random\\(\\) &lt; 1.0).\nUsing Math.random works well when you need to generate a single random number. If you need to generate a series of random numbers, you should create an instance of java.util.Random and invoke methods on that object to generate numbers.\nⅡ. Characters\nWhen we use a char as an object—for example, as a method argument where an object is expected. The Java programming language provides a wrapper class that “wraps” the char in a Character object.\nCharacter ch = new Character('a');\nFor the methods in this class, refer to the java.lang.Character API specification.\nboolean isLetter(char ch), boolean isDigit(char ch), boolean isUpperCase(char ch), …\n· Escape Sequences\nA character preceded by a backslash () is an escape sequence and has special meaning to the compiler.\n\n\nEscape Sequence\nDescription\n\n\n\n\n\\t\nInsert a tab in the text at this point.\n\n\n\\b\nInsert a backspace in the text at this point.\n\n\n\\n\nInsert a newline in the text at this point.\n\n\n\\f\nInsert a formfeed in the text at this point.\n\n\n\\\\\nInsert a backslash character in the text at this point.\n\n\nⅢ. String\nStrings are a sequence of characters. The Java platform provides the String class to create and manipulate strings. Whenever it encounters a string literal in your code, the compiler creates a String object with its value. The String class is immutable, so that once it is created a String object cannot be changed.\n123String greeting = &quot;Hello world!&quot;;char[] helloArray = &#123; &#x27;h&#x27;, &#x27;e&#x27;, &#x27;l&#x27;, &#x27;l&#x27;, &#x27;o&#x27;, &#x27;.&#x27; &#125;;String helloString = new String(helloArray);\nThe String class has a number of methods:\n123456789101112131415161718String palindrome = &quot;Dot saw I was Tod&quot;;int len = palindrome.length(); // --&gt; 17char c = palindrome.charAt(2); // --&gt; &#x27;t&#x27;// convert a string, or a portion of a string, into an array of characters char[] ca = palindrome.getChars(0, len, tempCharArray, 0);String s = &quot;My name is &quot;.concat(&quot;Rumplestiltskin&quot;); // My name is Rumplestiltskin// Breaking strings between lines using the + concatenation operatorString quote =     &quot;Now is the time for all good &quot; +    &quot;men to come to the aid of their country.&quot;;String fs;// return a String objectfs = String.format(&quot;The value of the float variable is %f&quot;,floatVar);System.out.println(fs);// return a PrintStream objectSystem.out.printf(&quot;The value of the float variable is %f&quot;,floatVar);\n1) Manipulating Characters in a String\n1234// Get the elemment in the stringString anotherPalindrome = &quot;Niagara. O roar again!&quot;; char aChar = anotherPalindrome.charAt(9);  // OString roar = anotherPalindrome.substring(11, 15)  // roar\n12345678// Searches for a match as specified by the string argument and splits this string into an array of strings accordingly.String[] split(String regex, int limit)// Returns a new character sequenceCharSequence subSequence(int beginIndex, int endIndex)// Returns a copy of this string with leading and trailing white space removed.String trim()String toLowerCase()String toUpperCase()\n1234567891011// Search forward from the begainningint indexOf(int ch, int fromIndex)// Search backward form the ending int lastIndexOf(int ch, int fromIndex)int indexOf(String str, int fromIndex)int lastIndexOf(String str, int fromIndex)// CharSequence is an interface that is implemented by the String class.   // Therefore, we can use a string as an argument for the contains() method.boolean contains(CharSequence s)\n123String replace(CharSequence target, CharSequence replacement)String replaceAll(String regex, String replacement)String replaceFirst(String regex, String replacement)\n2) Comparing Strings and Portions of Strings\n12345678910111213boolean startsWith(String prefix, int offset)boolean endsWith(String suffix)int compareTo(String anotherStringint compareToIgnoreCase(String str)// Returns true if and only if the argument is a String object // that represents the same sequence of charactersboolean equals(Object anObject)boolean equalsIgnoreCase(String anotherString)boolean regionMatches(int toffset, String other, int ooffset, int len)boolean regionMatches(boolean ignoreCase, int toffset, String other, int ooffset, int len)boolean matches(String regex)\n3) The StringBuilder Class\nStringBuilder objects are like String objects, except that they can be modified. We hardly use it unless it has the advantages over the String objects, like when we concatenate a large number of strings.\nFor more details here.\nThere is also a StringBuffer class that is exactly the same as the StringBuilder class, except that it is thread-safe by virtue of having its methods synchronized.\nⅣ. Autoboxing and Unboxing\nAutoboxing is the automatic conversion that the Java compiler makes between the primitive types and their corresponding object wrapper classes. If the conversion goes the other way, this is called unboxing.\nThe Java compiler applies autoboxing when a primitive value is:\n\nPassed as a parameter to a method that expects an object of the corresponding wrapper class.\nAssigned to a variable of the corresponding wrapper class.\n\nThe Java compiler applies unboxing when an object of a wrapper class is:\n\nPassed as a parameter to a method that expects a value of the corresponding primitive type.\nAssigned to a variable of the corresponding primitive type.\n\n123Stack&lt;Integer&gt; s = new Stack&lt;Integer&gt;();s.push(17); // s.push(Integer.valueOf(17));int a = s.pop(); // int a = s.pop().intValue();\nPart.5 Generics\nGenerics enable types to be parameters when defining classes, interfaces and methods. Type parameters provide a way for you to re-use the same code with different inputs.\nThe benefits of code that use generics: · Stronger type checks at compile time. · Elimination of casts · Enabling programmers to implement generic algorithms.\nⅠ. Generic Types\nA generic type is a generic class or interface that is parameterized over types.\n123// A generic sclass// angle brackets (&lt;&gt;) specifies the type parameters (also called type variables) class Name&lt;T1, T2, ..., Tn&gt; &#123; /* ... */ &#125;\nA type variable can be any non-primitive type you specify: any class type, any interface type, any array type, or even another type variable.\n1) Type Parameter Naming Conventions\nBy convention, type parameter names are single, uppercase letters. The most commonly used type parameter names are: · E - Element \nused extensively by the Java Collections Framework\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n\n · K - Key · N - Number · T - Type · V - Value · S,U,V etc. - 2nd, 3rd, 4th types\n2) Invoking and Instantiating a Generic Type\nTo reference the generic class we must perform a generic type invocation, which replaces T with some concrete value(use reference type), such as Integer. To instantiate this class, use the new keyword.\n123456// T is the type parameter and Integer is the type arguement.Name&lt;Integer&gt; integerClass = new Name&lt;Integer&gt;();Name&lt;Integer&gt; integerClass = new Name&lt;&gt;();Name&lt;String, Integer&gt; pairClass = new Name&lt;&gt;(&quot;Even&quot;, 8);//substitute a type parameter with a parameterized type (i.e., List&lt;String&gt;)Name&lt;String, List&lt;String&gt;&gt; p = new Name&lt;&gt;(&quot;primes&quot;, new List&lt;String&gt;(...));\nOne provides type arguments in order to create a parameterized type.\n3) Raw Types\nA raw type is the name of a generic class or interface without any type arguments. Assigning a parameterized type to its raw type is allowed, but assigning a raw type to a parameterized type or using a raw type to invoke generic method will get warning. The warning shows that raw types bypass generic type checks, deferring the catch of unsafe code to runtime. Therefore, it’s better avoiding using raw types.\n1234// a parameterized type of Name&lt;T&gt; with arguement.Name&lt;Integer&gt; integerClass = new Name&lt;Integer&gt;();// a raw type without actual arguementsName rawName = new Name();\n4) Generic Methods\nGeneric methods are methods that introduce their own type parameters. This is similar to declaring a generic type, but the type parameter’s scope is limited to the method where it is declared. Static and non-static generic methods are allowed, as well as generic class constructors.\n12345678910public class Util &#123;    public static &lt;K, V&gt; boolean compare(Pair&lt;K, V&gt; p1, Pair&lt;K, V&gt; p2) &#123;        return p1.getKey().equals(p2.getKey()) &amp;&amp;               p1.getValue().equals(p2.getValue());    &#125;&#125;Pair&lt;Integer, String&gt; p1 = new Pair&lt;&gt;(1, &quot;apple&quot;);Pair&lt;Integer, String&gt; p2 = new Pair&lt;&gt;(2, &quot;pear&quot;);boolean same = Util.&lt;Integer, String&gt;compare(p1, p2);\n5) Bounded Type Parameters\nWhen we want to restrict the types that can be used as type arguments in a parameterized type, we can use bounded type parameters. To declare a bounded type parameter, list the type parameter’s name, followed by the extends keyword, followed by its upper bound.\n1234567public static &lt;T extends Comparable&lt;T&gt;&gt; int countGreaterThan(T[] anArray, T elem) &#123;    int count = 0;    for (T e : anArray)        if (e.compareTo(elem) &gt; 0)            ++count;    return count;&#125;\nIn addition to limiting the types you can use to instantiate a generic type, bounded type parameters allow you to invoke methods defined in the bounds.\n123456789101112public class NaturalNumber&lt;T extends Integer&gt; &#123;    private T n;    public NaturalNumber(T n)  &#123; this.n = n; &#125;    public boolean isEven() &#123;        return n.intValue() % 2 == 0;    &#125;    // ...&#125;\nA type parameter can have multiple bounds. A type variable with multiple bounds is a subtype of all the types listed in the bound. If one of the bounds is a class, it must be specified first.\n12345Class A &#123; /* ... */ &#125;interface B &#123; /* ... */ &#125;interface C &#123; /* ... */ &#125;class D &lt;T extends A &amp; B &amp; C&gt; &#123; /* ... */ &#125;\n6) Inheritance and Subtypes\nName&lt;A&gt; has no relationship to Name&lt;B&gt; even when class A is the parents of class B. The common parent of Name&lt;A&gt; and Name&lt;B&gt; is Object.\nWe can subtype a generic class or interface by extending or implementing it. The relationship between the type parameters of one class or interface and the type parameters of another are determined by the extends and implements clauses.\n1234interface PayloadList&lt;E,P&gt; extends List&lt;E&gt; &#123;  void setPayload(int index, P val);  ...&#125;\nThe following parameterizations of PayloadList are subtypes of List&lt;String&gt;: PayloadList&lt;String,String&gt;, PayloadList&lt;String,Integer&gt;, PayloadList&lt;String,Exception&gt;\n7) Type Inference\nType inference is a Java compiler’s ability to look at each method invocation and corresponding declaration to determine the types of the arguments and, if available, the type that the result is being assigned, or returned.\nType inference enables us to invoke a generic method without specifying a type between angle brackets. Java compiler can infer the type parameters of a generic method call.\n123456789public static &lt;U&gt; void addBox(U u, java.util.List&lt;Box&lt;U&gt;&gt; boxes) &#123;    Box&lt;U&gt; box = new Box&lt;&gt;();    box.set(u);    boxes.add(box);  &#125;java.util.ArrayList&lt;Box&lt;Integer&gt;&gt; listOfIntegerBoxes = new java.util.ArrayList&lt;&gt;();BoxDemo.&lt;Integer&gt;addBox(Integer.valueOf(10), listOfIntegerBoxes);BoxDemo.addBox(Integer.valueOf(20), listOfIntegerBoxes);\nWe can replace the type arguments required to invoke the constructor of a generic class with an empty set of type parameters \n`&lt;&gt;`\n\n\n\n\n\n\n \n\n \n \n\n \n\n as long as the compiler can infer the type arguments from the context.\n1Map&lt;String, List&lt;String&gt;&gt; myMap = new HashMap&lt;&gt;();\nConstructors can be generic in both generic and non-generic classes. The compiler infers the type Integer for the formal type parameter, X, of the generic class MyClass&lt;X&gt;. It infers the type String for the formal type parameter, T, of the constructor of this generic class.\n1234567class MyClass&lt;X&gt; &#123;  &lt;T&gt; MyClass(T t) &#123;    // ...  &#125;&#125;MyClass&lt;Integer&gt; myObject = new MyClass&lt;&gt;(&quot;&quot;);\nThe target type of an expression is the data type that the Java compiler expects depending on where the expression appears.\n12345static &lt;T&gt; List&lt;T&gt; emptyList();// Expect an instance of List&lt;String&gt;, so this data type is the target type.List&lt;String&gt; listOne = Collections.emptyList();// Or use a type witness and specify the value of T.List&lt;String&gt; listOne = Collections.&lt;String&gt;emptyList();\nInference algorithm uses only invocation arguments, target types, and possibly an obvious expected return type to infer types.\nⅡ. Wildcards\nIn generic code, the question mark \n`?`\n\n\n\n\n\n \n \n \n\n, called the wildcard, represents an unknown type. The wildcard can be used in a variety of situations: as the type of a parameter, field, or local variable; sometimes as a return type. The wildcard is never used as a type argument for a generic method invocation, a generic class instance creation, or a supertype.\n1) Bounded Wildcards\nYou can use an upper bounded wildcard to relax the restrictions on a variable.\n12345678910// matches a list of type Number or any of its subclasses.public static double sumOfList(List&lt;? extends Number&gt; list) &#123;    double s = 0.0;    for (Number n : list)        s += n.doubleValue();    return s;&#125;List&lt;Double&gt; ld = Arrays.asList(1.2, 2.3, 3.5);System.out.println(&quot;sum = &quot; + sumOfList(ld)); // 7.0\n","plink":"https://oreodu.github.io/2020/20200923-Java-Basics-02/"},{"title":"Java Basics 01","date":"2020-09-17T17:30:00.000Z","date_formatted":{"ll":"Sep 18, 2020","L":"09/18/2020","MM-DD":"09-18"},"updated":"2020-10-19T06:59:35.189Z","content":"Java Basics 01\n· materials:\n· CS61B Spring 2019 at UCB\n· Java Tutorial\n· The Java Language Environment by James Gosling and Henry McGilton\n· Wikipedia\n· Google Java Style Guide\nPart.1 General View\nJava is the general term for Java object-oriented programming language and Java platform launched by Sun Microsystems in May 1995.\nJava is divided into three systems:\nJavaSE \nJava2 Platform Standard Edition\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n\n , JavaEE \nJava 2 Platform, Enterprise Edition\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n\n , JavaME \nJava 2 Platform Micro Edition\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n\n.\nJava Platform： A platform is the hardware or software environment in which a program runs but Java platform is a software-only platform that runs on top of other hardware-based platforms. As a platform-independent environment, the Java platform can be a bit slower than native code. However, advances in compiler and virtual machine technologies are bringing performance close to that of native code without threatening portability.\nThe Java platform has two components:\n· The Java Virtual Machine A Java virtual machine \nJVM\n\n\n\n\n\n\n \n \n \n\n is a virtual machine that enables a computer to run Java programs as well as programs written in other languages that are also compiled to Java bytecode.\n· The Java Application Programming Interface \nAPI\n\n\n\n\n\n\n \n \n \n\n The API is a large collection of ready-made software components that provide many useful capabilities. It is grouped into libraries of related classes and interfaces; these libraries are known as packages.\nⅠ. Main Features\nSee more details here\n· Simple\nEasy to learn and use from the very beginning.\n· Object Oriented\nJava language is a pure object-oriented programming language and provides object-oriented features such as classes, interfaces, and inheritance. It only supports single inheritance between classes, but supports multiple inheritance between interfaces, and supports the implementation mechanism between classes and interfaces.\n· Portable and Architecture Neutral\nJava technology is designed to support applications that will be deployed into heterogeneous network environments which requires that applications must be capable of executing on a variety of hardware architectures. The Java Compiler generates bytecodes – an architecture neutral intermediate format designed to transport code efficiently to multiple hardware and software platforms. The architecture-neutral and portable language platform of Java technology is known as the Java virtual machine.\nAlso being strict in its definition of the basic language \nspecifies the sizes of its basic data types and the behavior of its arithmetic operators\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n\n makes the programs the same on every platform–there are no data type incompatibilities across hardware and software architectures.\n· Interpreted, Dynamic and Multithreaded\nThe Java interpreter can execute Java bytecodes directly on any machine to which the interpreter and run-time system have been ported. The classes required by the Java program can be dynamically loaded into the run-time system, and the required classes can also be loaded through the network. While the Java Compiler is strict in its compile-time static checking, the language and run-time system are dynamic in their linking stages. Classes are linked only as needed.\nThe Java platform supports multithreading at the language level with the addition of sophisticated synchronization primitives: the language library provides the Thread class, and the run-time system provides monitor and condition lock primitives.\n· Distributed\nJava supports the development of Internet applications. There is a network application programming interface \njava net\n\n\n\n\n\n\n\n\n\n \n \n \n \n \n \n \n\n in the basic Java application programming interface, which provides a class library for network application programming, including URL,etc. Java’s RMI \nRemote Method Activation\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n\n mechanism is also an important means of developing distributed applications.\n· Robust and Secure\nJava provides extensive compile-time checking, followed by a second level of run-time checking. Also there are no explicit programmer-defined pointer data types, no pointer arithmetic, and automatic garbage collection.\nJava is designed to operate in distributed environments, which means that applications written in the Java programming language are secure from intrusion by unauthorized code attempting to get behind the scenes and create viruses or invade file systems.\n· High performance\nThe Java platform achieves superior performance by adopting a scheme by which the interpreter can run at full speed without needing to check the run-time environment. The automatic garbage collector runs as a low-priority background thread, ensuring a high probability that memory is available when required, leading to better performance.\nⅡ. A Simple Example\n1) To write a java program, you’ll need:\n· The JDK\nDownload the Windows version now. \nMake sure you download the **JDK**, _not_ the JRE.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n\n \n \n\n \n\n \n \n\n \n \n \n \n \n \n\n Consult the installation instructions.\nJDK: \nJava Development Kit\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n\n It is an implementation of either one of the Java Platform and is the core of the entire Java development.The JDK integrates a private JVM and a few other resources\nsuch as javac...\n\n\n\n\n\n\n\n\n\n\n\n \n \n \n \n \n \n \n \n \n \n \n \n \n \n\n to finish the development of a Java application.\nJRE: \nJava Runtime Environment\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n\n It mainly contains two parts, the standard implementation of JVM and some basic Java libraries.\n· A text editor\n2) To create a program, you will:\n\n\nCreate a source file\nA source file contains code, written in the Java programming language. You can use any text editor to create and edit source files.\n123456789/** * The HelloWorldApp class implements an application that * simply prints &quot;Hello World!&quot; to standard output. */class HelloWorldApp &#123;    public static void main(String[] args) &#123;        System.out.println(&quot;Hello World!&quot;); // Display the string.    &#125;&#125;\n\n\nCompile the source file into a .class file\nThe Java programming language compiler \n`javac`\n\n\n\n\n\n\n\n\n \n \n \n \n \n \n \n\n takes your source file and translates its text into instructions that the Java virtual machine can easily understand. The instructions contained within this file are known as bytecodes. .class file has been type checked.\n\n\nRun the program\nThe Java application launcher tool uses the Java virtual machine to run your application.\n\n\n\n3) Content in the source file\n· Comment Comments are ignored by the compiler but are useful to other programmers. /* text */ /** documentation */ This indicates a documentation comment \n_doc comment_, for short\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n \n \n \n \n \n \n \n \n\n \n \n\n \n \n \n \n \n \n \n \n\n. The javadoc tool uses doc comments when preparing automatically generated documentation. For more information on javadoc, see the Javadoc™ tool documentation . // text\n· Class definition\nThe file name must be consistent with the class name, every java file must contain a class declaration and all code live inside a class, even helper functions, global constant \nexcept interface.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n\n\n· The main method\nTo run a Java program, every application must contain a main method whose signature is:\n1public static void main(String[] args)\nThe main method accepts a single argument: an array of elements of type String. This array is the mechanism through which the runtime system passes information to your application.\nPart.2 Language Basics\nⅠ. Variables\n· Different kinds of variables\n1) Instance Variables \nNon-Static Fields\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n\n Objects store their individual states in non-static fields. The values of instance variables are unique to each instance of a class.\n2) Class Variables \nStatic Fields\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n \n \n \n \n \n \n \n \n \n \n \n\n Any field declared with the static modifier is a class variable. It is a common variable that applies to all instances.\n3) Local Variables Methods store their temporary states in local variables. Local variables are only visible to the methods in which they are declared and they are not accessible from the rest of the class.\n4) Parameters\nVariables in method declarations.\n· Naming\n1) Case-sensitive\n2) Subsequent characters may be letters, digits, dollar signs, or underscore characters.\n3) Not a keyword or reserved word.\nThe convention is to always begin your variable names with a letter and use full words instead of cryptic abbreviations. If the name consists of only one word, spell that word in all lowercase letters. If it consists of more than one word, capitalize the first letter of each subsequent word. \n e.g. `gearRatio` \n\n\n\n\n\n\n\n\n\n\n\n\n\n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n\n\n· Primitive Data Types\nThe Java programming language is statically-typed, which means that all variables, parameters, expressions and methods must first be declared before they can be used. This involves stating the variable’s type and name. That type can never be changed. The compiler checks that all the types are compatible before the program ever runs.\nA variable’s data type determines the values it may contain, plus the operations that may be performed on it.\nPrimitive types are special data types built into the language; they are not objects created from a class.\n\n\nType\nRange\nDefault Value\n\n\n\n\nbyte\n8-bit signed two’s complement integer, -128 ~ 127 \ninclusive\n\n\n\n\n\n\n\n\n\n\n\n \n \n \n \n \n \n \n \n \n\n\n0\n\n\nshort\n16-bit signed two’s complement integer, -32,768 ~ 32,767 \ninclusive\n\n\n\n\n\n\n\n\n\n\n\n \n \n \n \n \n \n \n \n \n\n\n0\n\n\nint\n32-bit signed two’s complement integer, -2e31 ~ 2e31 - 1\n0\n\n\nlong\n64-bit signed two’s complement integer, -2e63 ~ 2e63-1\n0L\n\n\nfloat\nsingle-precision 32-bit IEEE 754 floating point\n0.0f\n\n\ndouble\ndouble-precision 64-bit IEEE 754 floating point\n0.0d\n\n\nboolean\n8-bit, true and false\n‘\\u0000’\n\n\nchar\nsingle 16-bit Unicode character, '\\u0000' \nor 0\n\n\n\n\n\n\n \n \n \n\n ~ '\\uffff' \nor 65,535 inclusive\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n \n\n \n \n\n \n\n \n \n \n\n \n \n \n \n \n \n \n \n \n\n.\nfalse\n\n\nFields\ninstance variables\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n\n that are declared but not initialized will be set to a reasonable default by the compiler. But compiler never assigns a default value to an uninitialized local variable. If you cannot initialize your local variable where it is declared, make sure to assign it a value before you attempt to use it. Accessing an uninitialized local variable will result in a compile-time error.\n· Literal\nThe value assigned to a primitive data type is called a literal. Literals of types byte, short, int and long can be expressed by these number systems: Decimal\n26\n\n\n\n\n\n \n \n\n, Hexadecimal\n0x1a\n\n\n\n\n\n\n\n \n \n \n \n\n, Binary\n0b11010\n\n\n\n\n\n\n \n \n\n \n \n \n \n \n\n\n.\nA floating-point literal is of type float if it ends with the letter F or f; otherwise its type is double and it can optionally end with the letter D or d. Also it can use E or e \nfor scientific notation\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n\n.\nLiterals of types char and String may contain any Unicode \nUTF-16\n\n\n\n\n\n\n\n\n\n \n \n \n \n\n \n \n\n\n characters or you can use a “Unicode escape” such as '\\u0108' \ncapital C with circumflex\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n\n. Always use ‘single quotes’ for char literals and “double quotes” for String literals.\nA special null literal that can be used as a value for any reference type. null may be assigned to any variable, except variables of primitive types.\nThe Java programming language also supports a few special escape sequences for char and String literals: \\b \nbackspace\n\n\n\n\n\n\n\n\n\n\n \n \n \n \n \n \n \n \n \n\n, \\t \ntab\n\n\n\n\n\n\n \n \n \n\n, \\n \nline feed\n\n\n\n\n\n\n\n\n\n \n \n \n \n \n \n \n \n\n, \\f \nform feed\n\n\n\n\n\n\n\n\n\n \n \n \n \n \n \n \n \n\n, \\r \ncarriage return\n\n\n\n\n\n\n\n\n\n\n\n\n \n \n \n \n \n \n \n \n \n \n \n \n \n \n\n, \\&quot; \ndouble quote\n\n\n\n\n\n\n\n\n\n\n\n \n \n \n \n \n \n \n \n \n \n \n\n, \\' \nsingle quote\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n \n \n \n \n \n \n \n \n \n \n\n, and \\\\ \nbackslash\n\n\n\n\n\n\n\n\n\n\n \n \n \n \n \n \n \n \n \n\n.\n· Reference Data Type\nReference datatypes in java are those which contains reference/address\n8 bytes\n\n\n\n\n\n\n\n\n\n \n \n \n \n \n \n\n of dynamically created objects. These are not predefined like primitive data types. Default value of any reference variable is null. A reference variable can be used to refer any object of the declared type or any compatible type.\nFollowing are the reference types in Java.\n\n\nclass types\nThis reference type points to an object of a class. See Number and String class here.\n\n\ninterface types\nThis reference type points to an object of a class which implements an interface. See interface here.\n\n\narray types − This reference type points to an array.\nAn array is a container object \n24 bytes + memory for each array entry\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n\n that holds a fixed number of values of a single type. The length of an array is established when the array is created. After creation, its length is fixed. We get one reference when it’s created and, unlike class, arrays don’t have methods.\nJava prohibits generic array creation! The problem is due to the interaction of Java arrays, which are not statically sound but are dynamically checked, with generics, which are statically sound and not dynamically checked. Arrays are covariant and generics are invariant.\nSee more details here or here.\n12345// Covariant: Can assign subclass type array to its superclass array reference. Object objectArray[] = new Integer[10]; // it will work fine// Invariant: Cannot assign subclass type generic to its super class generic reference // because in generics any two distinct types are neither a subtype nor a supertype. List&lt;Object&gt; objectList = new ArrayList&lt;Integer&gt;(); // won&#x27;t compile\n\n\n123456789101112131415// declares an array of integersint[] anArray;// create an array of integersanArray = new int[10];// initialize first elementanArray[0] = 100;int[] anotherArray = new int[10];// copy the array;System.arraycopy(anArray,0,anotherArray,0,10);// Create a multidimensional arrayString[][] names = &#123;  &#123;&quot;Mr. &quot;, &quot;Mrs. &quot;, &quot;Ms. &quot;&#125;,  &#123;&quot;Smith&quot;, &quot;Jones&quot;&#125;  &#125;; System.out.println(anArray.length); // 10\nFor your convenience, Java SE provides several methods for performing array manipulations \ncommon tasks, such as copying, sorting and searching arrays\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n\n in the java.util.Arrays class.\n· Enum Types\nAn enum type is a special data type that enables for a variable to be a set of predefined constants. The variable must be equal to one of the values that have been predefined for it.\n1234567891011121314151617181920212223242526272829303132333435public enum Planet &#123;    MERCURY (3.303e+23, 2.4397e6),    VENUS   (4.869e+24, 6.0518e6),    EARTH   (5.976e+24, 6.37814e6)    private final double mass;   // in kilograms    private final double radius; // in meters    Planet(double mass, double radius) &#123;        this.mass = mass;        this.radius = radius;    &#125;    private double mass() &#123; return mass; &#125;    private double radius() &#123; return radius; &#125;    // universal gravitational constant  (m3 kg-1 s-2)    public static final double G = 6.67300E-11;    double surfaceGravity() &#123;        return G * mass / (radius * radius);    &#125;    double surfaceWeight(double otherMass) &#123;        return otherMass * surfaceGravity();    &#125;    public static void main(String[] args) &#123;        if (args.length != 1) &#123;            System.err.println(&quot;Usage: java Planet &lt;earth_weight&gt;&quot;);            System.exit(-1);        &#125;        double earthWeight = Double.parseDouble(args[0]);        double mass = earthWeight/EARTH.surfaceGravity();        for (Planet p : Planet.values())           System.out.printf(&quot;Your weight on %s is %f%n&quot;,                             p, p.surfaceWeight(mass));    &#125;&#125;\nⅡ. Operators\nOperators are special symbols that perform specific operations on one, two, or three operands, and then return a result.\n\n\nOperators\nPrecedence\n\n\n\n\n\n\npostfix\nexpr++ expr--\n\n\n\n\nunary\n++expr --expr +expr -expr ~ !\n\n\n\n\nmultiplicative\n* / %\n\n\n\n\nadditive\n+ -\n\n\n\n\nshift\n&lt;&lt; &gt;&gt; &gt;&gt;&gt;\n\n\n\n\nrelational\n&lt; &gt; &lt;= &gt;= instanceof\n\n\n\n\nequality\n== !=\n\n\n\n\nbitwise AND\n&amp;\n\n\n\n\nbitwise exclusive OR\n^\n\n\n\n\nbitwise inclusive OR\n`\n`\n\n\n\nlogical AND\n&amp;&amp;\n\n\n\n\nlogical OR\n`\n\n`\n\n\nternary\n? :\n\n\n\n\nassignment\n`= += -= *= /= %= &amp;= ^=\n= &lt;&lt;= &gt;&gt;= &gt;&gt;&gt;=`\n\n\n\nThe operators in the table above are listed according to precedence order. Operators with higher precedence are evaluated before operators with relatively lower precedence.\nOperators on the same line have equal precedence. When operators of equal precedence appear in the same expression, a rule must govern which is evaluated first.\nAll binary operators except for the assignment operators are evaluated from left to right; assignment operators are evaluated right to left.\nⅢ. Expressions, Statements, and Blocks\n1) Expressions\nAn expression is a construct made up of variables, operators, and method invocations, which are constructed according to the syntax of the language, that evaluates to a single value. The data type of the value returned by an expression depends on the elements used in the expression.\n2) Statements\nA statement forms a complete unit of execution. The following types of expressions can be made into a statement by terminating the expression with a semicolon \n`;`\n\n\n\n\n\n \n \n \n\n.\n\nAssignment expressions\nAny use of ++ or --\nMethod invocations\nObject creation expressions\nDeclaration statements\nControl flow statements\n\n3) Blocks\nA block is a group of zero or more statements between balanced braces and can be used anywhere a single statement is allowed.\nⅣ. Control Flow Statements\nThis section describes the decision-making statements \n`if-then`, `if-then-else`, `switch`\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n\n, the looping statements \n`for`, `while`, `do-while`\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n\n, and the branching statements \n`break`, `continue`, `return`\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n\n\n1) The if-then-else Statement\nIt tells your program to execute a certain section of code only if a particular test evaluates to true.\n123456void applyBrakes() &#123;    if (isMoving) &#123;        currentSpeed--;    &#125; else &#123;        System.err.println(&quot;The bicycle has already stopped!&quot;);    &#125;\n2) The switch Statement\n12345678910111213141516public class SwitchDemo &#123;    public static void main(String[] args) &#123;        int month = 2;        String monthString;        switch (month) &#123;            case 1:  monthString = &quot;January&quot;;                     break;            case 2:  monthString = &quot;February&quot;;                     break;            case 3:  monthString = &quot;March&quot;;                     break;        &#125;        System.out.println(monthString);    &#125;&#125;\nAn if-then-else statement can test expressions based on ranges of values or conditions, whereas a switch statement tests expressions based only on a single integer, enumerated value, or String object.\n3) The while and do-while Statements\nThe while statement evaluates expression, which must return a boolean value.\n123456789class WhileDemo &#123;    public static void main(String[] args)&#123;        int count = 1;        while (count &lt; 11) &#123;            System.out.println(&quot;Count is: &quot; + count);            count++;        &#125;    &#125;&#125;\n123456789class DoWhileDemo &#123;    public static void main(String[] args)&#123;        int count = 1;        do &#123;            System.out.println(&quot;Count is: &quot; + count);            count++;        &#125; while (count &lt; 11);    &#125;&#125;\n4) The for Statement\nThe for statement provides a compact way to iterate over a range of values.\n1234567class ForDemo &#123;    public static void main(String[] args) &#123;         for(int i=1; i&lt;11; i++)&#123;              System.out.println(&quot;Count is: &quot; + i);         &#125;    &#125;&#125;\nThe for statement also has another form designed for iteration through Collections and arrays .\n123456789class EnhancedForDemo &#123;    public static void main(String[] args)&#123;         int[] numbers =              &#123;1,2,3,4,5,6,7,8,9,10&#125;;         for (int item : numbers) &#123;             System.out.println(&quot;Count is: &quot; + item);         &#125;    &#125;&#125;\n5) Branching Statements\nbreak : An unlabeled break statement terminates the innermost switch, for, while, or do-while statement, but a labeled break terminates an outer statement.\ncontinue: The continue statement skips the current iteration of a for, while , or do-while loop. The unlabeled form skips to the end of the innermost loop’s body and evaluates the boolean expression that controls the loop. A labeled continue statement skips the current iteration of an outer loop marked with the given label.\nreturn: The return statement exits from the current method, and control flow returns to where the method was invoked.\nPart.3 Object-Oriented Programming\nThe principles of OOP can be found in the article Python Basics 02 .\nⅠ. Class and Object\nObjects consist of state and related behavior. An object stores its state in fields and exposes its behavior through methods. Methods operate on an object’s internal state and serve as the primary mechanism for object-to-object communication.\nA class is the blueprint or prototype from which individual objects are created and includes fields \nclass variables, constants, instance variables\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n\n, nested classes and methods \nclass methods, abstract method...\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n\n.\n1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556/** * The class body contains all the code that provides * for the life cycle of the objects created from the class. */// The class name, with the initial letter capitalized by convention.public class Bicycle &#123;    // declarations for the fields that provide the state of the class and its objects    // public modifier—the field is accessible from all classes.    public int cadence;    public int speed;        // private modifier—the field is accessible only within its own class.    private int id;    private static int numberOfBicycles = 0;    // constructors with or without arguments for initializing new objects    public Bicycle() &#123;        cadence = 20;        speed = 0;    &#125;    public Bicycle(int startCadence, int startSpeed) &#123;        cadence = startCadence;        speed = startSpeed;        id = ++numberOfBicycles;    &#125;    // methods to implement the behavior of the class and its objects.    // the first (or only) word in a method name should be a verb.    public void setCadence(int newValue) &#123;        cadence = newValue;    &#125;    // use a construct called varargs to pass an arbitrary number of values to a method    // The method can be called either with an array or with a sequence of arguments.    // The code in the method body will treat the parameter as an array in either case.    public void speedUp(int... increments) &#123;        for(int increment:increments)&#123;            speed += increment;        &#125;    &#125;    // static method    public static int getNumberOfBicycles() &#123;        return numberOfBicycles;    &#125;    // access private fields indirectly by adding public methods that obtain them.    public int getId() &#123;        return id;    &#125;&#125;\n12345678910public ClassDemo &#123;    public static void main(String[] args) &#123;        Bicycle myBike = new Bicycle(30, 0);        // invokes the no-argument constructor and create a new object called yourBike        Bicycle yourBike = new Bicycle();         yourBike.speedUp(30);    &#125;&#125;\n1) Provide a constructor\nA class contains constructors that are invoked to create objects from the class blueprint. Constructor declarations look like method declarations—except that they use the name of the class and have no return type.\nAs with methods, the Java platform differentiates constructors on the basis of the number of arguments in the list and their types. We can create two different constructor with different arguments.\nAll classes have at least one constructor. If a class does not explicitly declare any, the Java compiler automatically provides a no-argument constructor, called the default constructor. This default constructor calls the class parent’s no-argument constructor, or the Object constructor if the class has no other parent. If the parent has no constructor \n`Object` does have one\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n\n, the compiler will reject the program.\nThere are two alternatives to using a constructor to initialize instance variables: initializer blocks and final methods.\n1234// initializer blocks&#123;    // whatever code is needed for initialization goes here&#125;\nThis approach can be used to share a block of code between multiple constructors.\n123456789// final methodclass Whatever &#123;    private varType myVar = initializeInstanceVariable();    protected final varType initializeInstanceVariable() &#123;        // initialization code goes here    &#125;&#125;\nA final method cannot be overridden in a subclass. This is useful if subclasses might want to reuse the initialization method. The method is final because calling non-final methods during instance initialization can cause problems.\n2) Use the this Keyword\nWithin an instance method or a constructor, this is a reference to the current object — the object whose method or constructor is being called.\nUsing this with a Field: The most common reason for using the this keyword is because a field is shadowed\nwith the same name\n\n\n\n\n\n\n\n\n\n\n\n\n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n\n by a method or constructor parameter.\nUsing this with a Constructor: From within a constructor, you can also use the this keyword to call another constructor in the same class which is called explicit constructor invocation.\n1234567891011121314public class Rectangle &#123;    private int x, y;    private int width, height;    public Rectangle(int width, int height) &#123;        this(0, 0, width, height);    &#125;    public Rectangle(int x, int y, int width, int height) &#123;        this.x = x;        this.y = y;        this.width = width;        this.height = height;    &#125;&#125;\n3) Overloading Methods\nWhen we create a method that need various types of data \nstrings, integers, and so on\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n\n in different situations, we can create methods with the same name but different parameter list. This can be supported by overloading methods in Java. They are differentiated by the number and the type of the arguments passed into the method.\n123456789public class DataArtist &#123;    ...    public void draw(String s) &#123;        ...    &#125;    public void draw(int i) &#123;        ...    &#125;&#125;\n4) Covariant return type\nA method returns to the code that invoked it when it completes all the statements in the method, reaches a return statement, or throws an exception. Any method declared void doesn’t return a value but we can use return; branch out of a control flow block and exit the method. The data type of the return value must match the method’s declared return type in the method that is not declared void .\nWhen a method uses a class name as its return type, the class of the type of the returned object must be either a subclass of, or the exact class of, the return type. We can also override a method and define it to return a subclass of the original method. This technique, called covariant return type, means that the return type is allowed to vary in the same direction as the subclass.\n5) Pass a information to the constructor or the method\nWhen we declare a parameter to a method or a constructor, we provide a name for that parameter. This name is used within the method body to refer to the passed-in argument. If the name is the same with the field in the class, we can use this to access the field.\nPrimitive arguments, such as an int or a double, are passed into methods by value. This means that any changes to the values of the parameters exist only within the scope of the method. When the method returns, the parameters are gone and any changes to them are lost.\nReference data type parameters, such as objects, are also passed into methods by value. This means that when the method returns, the passed-in reference still references the same object as before. However, the values of the object’s fields can be changed in the method, if they have the proper access level.\nIf we want to pass a method into a method, then use a lambda expression or a method reference.\nWhen invoke a method, the arguments used must match the declaration’s parameters in type and order.\n6) Creating Objects\n· Declaring a Variable to Refer to an Object.\ntype name; notifies the compiler that you will use name to refer to data whose type is type. With a primitive variable, this declaration also reserves the proper amount of memory for the variable.\n· Instantiating a Class. Initializing an Object.\nThe new operator instantiates a class by allocating memory for a new object and returning a reference\n8 bytes\n\n\n\n\n\n\n\n\n\n \n \n \n \n \n \n\n to that memory. The new operator also invokes the object constructor so it requires a single, postfix argument: a call to a constructor. Java first allocates a box of bits for each instance variable of class and fill them with a dfault value\n0, null, ... \n\n\n\n\n\n\n\n\n\n \n \n \n \n \n \n \n \n \n \n\n. The construtor then fills every such box with some other value. The name of the constructor provides the name of the class to instantiate.\nTypical memory usage for objects in java: Object overhead\n16 bytes\n\n\n\n\n\n\n\n\n\n\n \n \n \n \n \n \n \n\n, memory for each instance variable, pointer to enclosing class\n8 bytes\n\n\n\n\n\n\n\n\n\n \n \n \n \n \n \n\n and padding\neach objects uses a multiple of 8 bytes\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n\n.\nObjects of the same type have their own copy of the same instance fields. So if we want to access the fields or methods outside the class we have to use them in such way: objectReference.fieldName and objectReference.methodName(argumentList)\nThe Java runtime environment deletes objects when there are no more references to that object. This process is called garbage collection.\n7) Controlling Access to Members of a Class\nAccess level modifiers determine whether other classes can use a particular field or invoke a particular method.\nAccess Levels\n\n\nModifier\nClass\nPackage\nSubclass\nWorld\n\n\n\n\npublic\nY\nY\nY\nY\n\n\nprotected\nY\nY\nY\nN\n\n\nno modifier\npackage-private\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n\n\nY\nY\nN\nN\n\n\nprivate\nY\nN\nN\nN\n\n\n8)  static keyword\nFields that have the static modifier in their declaration are called static fields or class variables. They are associated with the class, rather than with any object. Every instance of the class shares a class variable, which is in one fixed location in memory. Any object can change the value of a class variable, but class variables can also be manipulated without creating an instance of the class. Class variables are referenced by the class name itself: ClassName.fieldName\nComplicated initialization of instance variables can be done through constructors, to provide the same capability for class variables, the Java programming language includes static initialization blocks or private static method. The advantage of private static methods is that they can be reused later if you need to reinitialize the class variable.\n1234// static initialization blockstatic &#123;    // whatever code is needed for initialization goes here&#125;\n12345678class Whatever &#123;    public static varType myVar = initializeClassVariable();    private static varType initializeClassVariable() &#123;        // initialization code goes here    &#125;&#125;\nStatic methods, which have the static modifier in their declarations, should be invoked with the class name, without the need for creating an instance of the class. \n`ClassName.methodName(args)`\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n\n. A common use for static methods is to access or initialize static fields. Class methods cannot access instance variables or instance methods directly—they must accesss instance variables via  a specific instance reference. Also, class methods cannot use the this keyword as there is no instance for this to refer to.\nThe static modifier, in combination with the final modifier, is also used to define constants. The final modifier indicates that the value of this field cannot change. By convention, the names of constant values are spelled in uppercase letters. If the name is composed of more than one word, the words are separated by an underscore \n\\_\n\n\n\n\n \n\n.\n\nIf a primitive type or a string is defined as a constant and the value is known at compile time, the compiler replaces the constant name everywhere in the code with its value. This is called a _compile-time constant_. \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n\n \n \n\n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n\n \n \n\n\n\nⅡ. More about class\n1)  Nested Class\nNested classes are divided into two categories: static and non-static.\nNested classes that are declared static are called static nested classes. As with class methods and variables, a static nested class is associated with its outer class so they do not have access to other instance members of the enclosing class. It can use them only through an object reference. To create an object for the static nested class: OuterClass.StaticNestedClass nestedObject = new OuterClass.StaticNestedClass();\nNon-static nested classes are called inner classes. As with instance methods and variables, an inner class is associated with an instance of its enclosing class so they have access to other members of the enclosing class, even if they are declared private and it cannot define any static members itself. An instance of InnerClass can exist only within an instance of OuterClass. There are two special kinds of inner classes: local classes and anonymous classes. To instantiate an inner class: OuterClass.InnerClass innerObject = outerObject.new InnerClass();\nNested class is a way of logically grouping classes that are only used in one place and increases encapsulation.\n2) Local Class\nLocal classes are classes that are defined in a block, which is a group of zero or more statements between balanced braces. For example, you can define a local class in a method body, a for loop, or an if clause.\nLocal classes has access to the members of its enclosing class. However, Local classes in static methods can only refer to static members of the enclosing class.\nBecause they have access to instance members of the enclosing block. Consequently, they cannot contain most kinds of static declarations. However, they can have static members provided that they are constant variables. \nA _constant variable_ is a variable of primitive type or type `String` that is declared final and initialized with a compile-time constant expression.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n\n \n \n\n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n\n\nThey also can access local variables of the enclosing block that are final or effectively final \nnever changed after it is initialized\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n\n and can access the method’s parameters.\nWe cannot declare an interface inside a block; interfaces are inherently static.\n1234567891011// inside a methodpublic void sayGoodbyeInEnglish(String name) &#123;     class EnglishGoodbye &#123;         public static final String farewell = &quot;Bye bye&quot;;         public void sayGoodbye() &#123;             System.out.println(name + farewell);         &#125;     &#125;     EnglishGoodbye myEnglishGoodbye = new EnglishGoodbye();     myEnglishGoodbye.sayGoodbye(); &#125;\n3) Anonymous classes\nAnonymous classes enable us to declare and instantiate a class at the same time. They are like local classes except that they do not have a name. Use them if you need to use a local class only once.\nAn anonymous class has access to the members of its enclosing class and cannot access local variables in its enclosing scope that are not declared as final or effectively final. We cannot declare static initializers, member interfaces or constructors in an anonymous class but an anonymous class can have static members provided that they are constant variables.\n1234567891011121314151617181920212223242526272829303132333435363738394041424344public class HelloWorldAnonymousClasses &#123;    interface HelloWorld &#123;        public void greet();        public void greetSomeone(String someone);    &#125;    public void sayHello() &#123;        // local class        class EnglishGreeting implements HelloWorld &#123;            String name = &quot;world&quot;;            public void greet() &#123;                greetSomeone(&quot;world&quot;);            &#125;            public void greetSomeone(String someone) &#123;                name = someone;                System.out.println(&quot;Hello &quot; + name);            &#125;        &#125;        HelloWorld englishGreeting = new EnglishGreeting();        // anonymous class        // an interface to implement or a class to extend        HelloWorld frenchGreeting = new HelloWorld() &#123;            String name = &quot;tout le monde&quot;;            public void greet() &#123;                greetSomeone(&quot;tout le monde&quot;);            &#125;            public void greetSomeone(String someone) &#123;                name = someone;                System.out.println(&quot;Salut &quot; + name);            &#125;        &#125;;        englishGreeting.greet();        frenchGreeting.greetSomeone(&quot;Fred&quot;);    &#125;    public static void main(String... args) &#123;        HelloWorldAnonymousClasses myApp =            new HelloWorldAnonymousClasses();        myApp.sayHello();    &#125;            &#125;\n4) Lambda expressions\nLambda expressions enable us to treat functionality as method argument, or code as data and express instances of single-method classes more compactly.\nLambda expressions are lexically scoped. This means that they do not inherit any names from a supertype or introduce a new level of scoping. Declarations in a lambda expression are interpreted just as they are in the enclosing environment. Consequently, you can directly access fields, methods, and local variables of the enclosing scope. Local variables referenced from a lambda expression must be final or effectively final.\nTo determine the type of a lambda expression, the Java compiler uses the target type\nthe data type that these methods expect\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n\n of the context or situation in which the lambda expression was found. It follows that you can only use lambda expressions in situations in which the Java compiler can determine a target type: Variable declarations, Assignments, Return statements, Array initializers, Method or constructor arguments, Lambda expression bodies, Conditional expressions, ?:, Cast expressions.\nSee more details.\n123456789101112131415161718192021interface CheckPerson &#123;    boolean test(Person p);&#125;// Specify Search Criteria Code in an Anonymous ClassprintPersons(    roster,    new CheckPerson() &#123;        public boolean test(Person p) &#123;            return p.getGender() == Person.Sex.MALE                &amp;&amp; p.getAge() &gt;= 18                &amp;&amp; p.getAge() &lt;= 25;        &#125;    &#125;);// Specify Search Criteria Code with a Lambda ExpressionprintPersons(    roster,    (Person p) -&gt; p.getGender() == Person.Sex.MALE        &amp;&amp; p.getAge() &gt;= 18        &amp;&amp; p.getAge() &lt;= 25);\n123456789101112131415161718192021// Use Standard Functional Interfaces with Lambda Expressionsinterface Predicate&lt;T&gt; &#123;    boolean test(T t);&#125;printPersonsWithPredicate(    roster,    p -&gt; p.getGender() == Person.Sex.MALE        &amp;&amp; p.getAge() &gt;= 18        &amp;&amp; p.getAge() &lt;= 25);// Use Aggregate Operations That Accept Lambda Expressions as Parametersroster    .stream()    .filter(        p -&gt; p.getGender() == Person.Sex.MALE            &amp;&amp; p.getAge() &gt;= 18            &amp;&amp; p.getAge() &lt;= 25)    .map(p -&gt; p.getEmailAddress())    .forEach(email -&gt; System.out.println(email));\nFor more aggregate operations, see the here.\n1234567891011121314151617181920212223// Method References: refer to the existing method by namePerson[] rosterAsArray = roster.toArray(new Person[roster.size()]);class PersonAgeComparator implements Comparator&lt;Person&gt; &#123;    public int compare(Person a, Person b) &#123;        return a.getBirthday().compareTo(b.getBirthday());    &#125;&#125;Arrays.sort(rosterAsArray, new PersonAgeComparator());/*Arrays.sort(rosterAsArray,    (Person a, Person b) -&gt; &#123;        return a.getBirthday().compareTo(b.getBirthday());    &#125;);Arrays.sort(rosterAsArray,    (a, b) -&gt; Person.compareByAge(a, b));Arrays.sort(rosterAsArray, Person::compareByAge);*/\n123456789101112131415161718192021public class Calculator &#123;    interface IntegerMath &#123;        int operation(int a, int b);       &#125;    public int operateBinary(int a, int b, IntegerMath op) &#123;        return op.operation(a, b);    &#125;    public static void main(String... args) &#123;        Calculator myApp = new Calculator();        IntegerMath addition = (a, b) -&gt; a + b;        IntegerMath subtraction = (a, b) -&gt; a - b;        System.out.println(&quot;40 + 2 = &quot; +            myApp.operateBinary(40, 2, addition));        System.out.println(&quot;20 - 10 = &quot; +            myApp.operateBinary(20, 10, subtraction));        &#125;&#125;\nWhen to Use Nested Classes, Local Classes, Anonymous Classes, and Lambda Expressions, see more from here.\nA namespace that organizes classes and interfaces by functionality is called a package. And the Java platform provides an enormous class library \na set of packages\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n \n \n \n \n \n \n \n \n \n \n \n \n \n\n suitable for use in applications. Application Programming Interface \nAPI\n\n\n\n\n\n\n \n \n \n\n provided by the Java platform: Java Platform API Specification .\n","plink":"https://oreodu.github.io/2020/20200917-Java-Basics-01/"},{"title":"SQL Basics","date":"2020-09-16T07:42:00.000Z","date_formatted":{"ll":"Sep 16, 2020","L":"09/16/2020","MM-DD":"09-16"},"updated":"2020-10-03T18:16:27.401Z","content":"SQL Basics\nOverview\n(概略图)\n· materials:\n· CS61A Summer 2019 at UCB\nSQL is an example of a (declarative) language with interacts with a  database management system (DBMS) in order to make data processing easier and faster\nPart.1 Create the Table\n· Make a table\nA CREATE TABLE statement gives a global name to a table.\n123CREATE TABLE [name]([columns]); # create empty tableCREATE TABLE dogs(name, fur, phrase DEFAULT &#39;woof&#39;); # using default values\n· Create rows of data\nCREATE TABLE [name] AS ...;\n123456789SELECT [expr] AS [name], [expr] AS [name], ... UNIONSELECT [expr] AS [name], [expr] AS [name], ... UNIONSELECT [expr] AS [name], [expr] AS [name], ...;CREATE TABLE cities AS  SELECT 38 AS latitude, 122 AS longitude, &quot;Berkeley&quot; AS name   UNION  SELECT 42,\t\t\t    71,\t\t\t     &quot;Cambridge&quot;        UNION  SELECT 45,\t\t\t    93,\t\t\t     &quot;Minneapolis&quot;;\n· Create rows of data from existing tables\nA SELECT statement can specify an input table using a FROM clause. A subset of the rows of the input table can be selected using a WHERE clause. Can declare the order of the remaining rows using an ORDER BY clause. Otherwise, no order. Column descriptions determine how each input row is projected to a result row.\n12345SELECT [columns] FROM [table] WHERE [condition] ORDER BY [order] [ASC&#x2F;DESC] LIMIT [number];SELECT &quot;west coast&quot; AS region, name FROM cities WHERE longitude &gt;&#x3D; 115 UNIONSELECT &quot;other&quot;, \t\t\t\t name FROM cities WHERE longitude &lt; 115;\n· Arithmetic in SELECT Statements\nIn a SELECT expression, column names evaluate to row values.Arithmetic expressions can combine row values and constants.\n1SELECT single + 2 * couple AS total FROM restaurant;\n· Join the Table\nWhen we join two tables, we get a new table with one row for each combination of rows from the original tables.\nSELECT * FROM table1, table2;\n12SELECT * FROM parents, dogs;SELECT parent FROM parents, dogs WHERE child &#x3D; name AND fur &#x3D; &quot;curly&quot;;\n12345SELECT s.name, s.artist       FROM songs AS s, artists AS ar, albums AS al      WHERE album &#x3D; al.name AND s.artist &#x3D; ar.name            AND release_year &#x3D; 2010            ORDER BY first_year_active;\n· Aliasing\n1SELECT a.child AS first, b.child AS second FROM parents AS a, parents AS b WHERE a.parent &#x3D; b.parent AND a.child &lt; b.child;\n· String Expression\n1234sql&gt; SELECT name || &quot; dog&quot; FROM dogs;abraham dogbarack dogclinton dog\nPart.2 Aggregation\nAggregation is the process of doing operations on groups of rows instead of just a single row. SQL provides aggregate functions whose return values can be used as entries in a column.\n1234SELECT AVG(age) AS avg_age FROM dogs;SELECT COUNT(*) AS count FROM dogs;SELECT SUM(age) AS sum_age FROM dogs;SELECT MIN(name) AS min_name FROM dogs;\n· Group\nBy default, aggregation is performed over all the rows of the table. We can GROUP BY any valid SQL expression, which includes using multiple column names and operators. We can specify  a single group consists of all rows for which [expression] evaluates to the same value. The output table will have one row per group.\n123456SELECT [columns] FROM [table] WHERE [condition]        GROUP BY [expression]       ORDER BY [order] [ASC&#x2F;DESC]       LIMIT [number];SELECT fur, AVG(age) AS avg_age FROM dogs GROUP BY fur;\n· Filtering Groups\nWe know how to filter individual rows using the WHERE clause.To filter groups, use the HAVING [condition] clause.\n123SELECT fur, AVG(age) AS avg_age       FROM dogs GROUP BY fur       HAVING COUNT(*) &gt; 1;\nPart.3 Mutating Tables\n· Remove Table\n12DROP TABLE [IF EXISTS] [name];DROP TABLE IF EXISTS parents;\n· Inserting Records\n1234INSERT INTO [table]([columns]) VALUES([values]), ([values]);INSERT INTO dogs(name, fur) VALUES(&#39;fillmore&#39;, &#39;curly&#39;);INSERT INTO dogs VALUES(&#39;delano&#39;, &#39;long&#39;, &#39;hi!&#39;);\n· Updating Records\n12345UPDATE [table] SET [column] &#x3D; [expression] WHERE [condition];DELETE FROM [table] WHERE [condition];UPDATE dogs SET phrase &#x3D; &#39;WOOF&#39; WHERE fur &#x3D; &#39;curly&#39;;DELETE FROM dogs WHERE fur &#x3D; &#39;curly&#39; and phrase &#x3D; &#39;WOOF&#39;;\n","plink":"https://oreodu.github.io/2020/20200916-SQL-Basics/"},{"title":"Scheme Basics","date":"2020-09-15T02:42:00.000Z","date_formatted":{"ll":"Sep 15, 2020","L":"09/15/2020","MM-DD":"09-15"},"updated":"2020-10-03T18:16:21.647Z","content":"Scheme Basics\nOverview\n(概略图)\n· materials:\n· CS61A Summer 2019 at UCB\nPart.1 Scheme values\nⅠ. Atoms: primitive values that cannot be broken up into smaller parts\n\nnumbers: 10, -6, 5.7, 4021\nbooleans:  #t, #f\nsymbols: hello, world\n\nⅡ. Pairs and Lists:  a sequence of zero or more values\n(1 2 3 4 5 6)\nThe pair is the basic compound value in Scheme. Lists in Scheme are created using pairs. They’re linked lists.\n1.Pair\nPairs are created using the cons expression in Scheme\ncar selects the first element in a pair\ncdr selects the second element in a pair\nThe second element of a pair must be another pair, or nil\n12345678scm&gt; (define x (cons 1 (cons 3 nil))xscm&gt; x(1 3)scm&gt; (car x)1scm&gt; (cdr x)(3)\n2.List\nThe list constructor takes in any number of elements and puts each element as a single element in a list.\n1234scm&gt; (list 1 2 3)(1 2 3)scm&gt; (list 0 (list 1 2 3))(0 (1 2 3))\nThe quote special form takes in a single argument and returns an unevaluated version of the argument. Quoting a symbol gives a symbol back. Quoting the representation of a list gives a list.\n12scm&gt; ‘(0 (1 2 3))(0 (1 2 3))\ncons: When you want to add an element on to the start of a list.\nEx: add an element to the start of the list returned by a recursive call\nlist:  When you have multiple elements you want to put into a list all at once.\nEx: want to create a two element list containing x and y\nquote:  When you know the exact structure of the list and the values it contains.\nEx: create a list to pass in as an argument in an interactive session\nⅢ. Procedures:  function objects, either built-in or user-defined\n(lambda (x) (* x x))\nPart.2 Scheme expressions\nScheme programs consist only of expressions, all of which can be categorized into either atomic expressions or combinations.\nⅠ. Atomic expressions\nSelf-evaluating: numbers, booleans\n3, 5.5, -10, #t, #f\nSymbols: names bound to values\n+, modulo, list, x, foo, hello-world\nⅡ. Combinations\n(&lt;operator&gt; &lt;operand1&gt; &lt;operand2&gt; …)\nA combination is either a call expression or a special form expression.\n(+ 2 3), (abs (/ 20 5)), (&lt; 4 8.5)\n(define x 5), (if #t 10 20), (lambda (x) (* x x))\n· Call expressions\nA call expression applies a procedure to some arguments.\nEvaluate call expressions:\nStep 1.  Evaluate the operator to get a procedure.\nStep 2.  Evaluate all operands left to right to get the arguments.\nStep 3. Apply the procedure to the arguments.\n· Special form expressions\n1.Assigning values to names\nThe define special form assigns a value to a name:\n(define &lt;name&gt; &lt;expr&gt;)\nEvaluate:\nStep 1. Evaluate the given expression.\nStep 2. Bind the resulting value to the given name in the current frame.\nStep 3. Return the name as a symbol.\n2.Defining functions with names\nThe second version of define is a shorthand for creating a function with a name:\n(define (&lt;name&gt; &lt;param1&gt; &lt;param2&gt; …) &lt;body&gt;)\nEvaluate:\nStep 1. Create a lambda procedure with the given parameters and body.\nStep 2. Bind it to the given name in the current frame.\nStep 3. Return the function name as a symbol.\n(If there is more than one expression in the body, the function returns the value of the last expression.)\n3.Creating functions\nThe lambda special form returns a lambda procedure.\n(lambda (&lt;param1&gt; &lt;param2&gt; …) &lt;body&gt;)\nEvaluate:\nStep 1. Create a lambda procedure with the given parameters and body.\nStep 2. Return the lambda procedure.\n4.Control flow\nThe if special form allows us to evaluate an expression based on a condition:\n(if &lt;predicate&gt; &lt;if-true&gt; &lt;if-false&gt;)\nEvaluate:\nStep 1. Evaluate the &lt;predicate&gt;.\nStep 2. If &lt;predicate&gt; evaluates to anything but #f, evaluate &lt;if-true&gt; and return the value. Otherwise, evaluate &lt;if-false&gt; if provided and return the value.\nThe cond special form allows us to specify many conditions and consequences:\n(cond (&lt;pred1&gt; &lt;expr1&gt;) (&lt;pred2&gt; &lt;expr2&gt;) … (else &lt;else-expr&gt;))\nEvaluate:\nStep 1. Evaluate &lt;pred1&gt;, &lt;pred2&gt;, etc. until one evaluates to a truth-y value.\nStep 2. Evaluate and return the expression corresponding to the first truth-y predicate. If no predicate evaluates to a truth-y value, evaluate and return &lt;else-expr&gt; if provided.\n5.Others\n(equal? e1 e2) checks if e1 and e2 evaluate to equivalent values.\n(eq? e1 e2) checks if e1 and e2 evaluate to identical values.\nPart.3 Tail Recursion\nWe know that a function call will form a “call record” in memory, also known as a “call frame”, which saves information such as the call location and internal variables. If function B is called inside function A, then a call frame of B will be formed above the call frame of A. Wait until the end of B runs and return the result to A, then the call frame of B will disappear. If function B also calls function C, then there is a call frame of C, and so on. All call frames form a “call stack” (call stack).\n· Tail Call\nIn computer science, a tail call is a subroutine call performed as the final action of a procedure.  If all recursive calls are in tail contexts, we say that function is  tail recursive. If a language supports tail call optimization, a tail recursive function will only ever open a constant number of frames.\nTail calls can be implemented without adding a new stack frame to the call stack. Most of the frame of the current procedure is no longer needed, and can be replaced by the frame of the tail call, modified as appropriate (similar to overlay for processes, but for function calls). The program can then jump to the called subroutine.\n1234567891011121314; original recursive call(define (fact n)  (if (= n 0)   1   (* n (fact (- n 1)))))  ;We need to keep these frames open because the last step in the function is to multiply n with the result of the recursive call.; tail call(define (fact n)  (define (fact-tail n result)    (if (&lt;= n 1)        result        (fact-tail (- n 1) (* n result))))  (fact-tail n 1))\nPart.5 Macros\nIn Scheme,  expressions are lists (or primitive values) and quoting prevents evaluation of an expression. Calling eval on an unevaluated expression will evaluate that value. So it means that they’re also a form of data. And we can assign expressions to variables, pass expressions into functions, and create and return new expressions within functions.\n' : takes in a single argument and returns an unevaluated version of the argument.\nlist: takes in any number of elements and puts each element as a single element in a list.\n1234scm&gt; (list &#x27;quotient 10 2)(quotient 10 2)scm&gt; (eval (list &#x27;quotient 10 2))5\n12345(define (dounle expr)        (begin (eval expr) (eval expr))scm&gt; (double &#x27;(print 2))22\n12345(define (dounle expr)        (list &#x27;begin expr expr))scm&gt; (eval  (double &#x27;(print 2)))22\nMacros are a more convenient way to transform or create expressions. The define-macro special form will create a macro procedure. Macros take in and return expressions, which are then evaluated in place of the call to the macro.\n12345(define-macro (twice expr)  (list &#x27;begin expr expr))scm&gt; (twice (print 2)) ;Equivalent to: (begin (print 2) (print 2))22\nbegin is a special form takes in any number of expressions, evaluates them in order, and evaluates to the value of the final expression.\n· The evaluation procedure of Macros:\nStep.1: Evaluate the operator sub-expression, which evaluates to a macro procedure.\nStep.2: Apply the macro procedure to the operand expressions without evaluating them first.\nStep.3: Evaluate the expression returned by the macro procedure in the frame the macro was called in.(must return an unevaluated expression. e.g. a linked list)\nScheme doesn’t have for loops, but thanks to macros, we can add them.\n1234567(define-macro (for sym in vals do expr)  (list &#x27;map (list &#x27;lambda (list sym) expr) vals))scm&gt; (for x in &#x27;(1 2 3 4) do (* x x))(1 4 9 16)scm&gt; (map (lambda (x) (* x x)) &#x27;(1 2 3 4))(1 4 9 16)\n12(define-macro (for sym vals expr)  `(map (lambda (,sym) ,expr) ,vals))\nQuasiquotation allows you to have some parts of a list be read literally and some parts be evaluated.\n**** Short for(quasiquote …), ,`Short for (unquote …)\nPart.6 Streams\nScheme uses streams just like the iterators in Python whose rest is lazily evaluated.\n1234567891011121314(define (ints first)    (cons-stream first                 (ints (+ first 1)))scm&gt; (ints 1)(1 . #[promise (not forced)]) ;repesent these expressions are only valuated when we ask.  scm&gt; (define s (cons-stream 1 (cons-stream 2 nil)))sscm&gt; s(1 . #[promise (not forced)])scm&gt; (cdr-stream s)           ; cdr-stream forces Scheme to compute the rest.(2 . #[promise (not forced)])scm&gt; (cdr-stream (cdr-stream s))()\npromise:  an object that delays evaluation of an expression.\nThe delay special form creates promises.\nThe force procedure evaluates the expression inside the promise\n12345678scm&gt; (define x (delay (print 5)))xscm&gt; x#[promise (not forced)]scm&gt; (force x)5scm&gt; x#[promise (forced)]\n· Constant Stream\nA constant stream is an infinitely long stream with a number repeated.\n1234567(define (constant-stream i)        (cons-stream i (constant-stream i)))scm&gt; (define ones (constant-stream 1))scm&gt; (car ones)1scm&gt; (car (cdr-stream ones))1\n· Add-Stream and Ints-Stream\n1234567(define (add-stream s1 s2)\t(cons-stream (+ (car s1) (car s2))\t\t\t\t  (add-stream (cdr-stream s1) (cdr-stream s2))))(define ones (cons-stream 1 ones))(define ints (cons-stream 1 (add-stream ones ints))\nPart.7 Evaluating Process\nⅠ. Evaluating primitive expressions\nSelf-evaluating expressions:\nThese expressions evaluate to themselves.\nSymbols:\nLook in the current frame for the symbol. If it is found, return the value bound to it.\nIf it is not found in the current frame, look in the parent frame. If it is not found in the parent frame, look in its parent frame, and so on. If the global frame is reached and the name is not found, raise a SchemeError.\nⅡ. Evaluating Combinations\n1.Special form\nIf the operator is a symbol and is found in the dictionary of special forms, the combination is a special form. Each special form has special rules for evaluation.\n2.Call expression\nStep 1. Evaluate the operator to get a procedure.\nStep 2. Evaluate all of the operands from left to right.\nStep 3. Apply the procedure to the values of the operands.\nA built-in procedure is a procedure that is predefined in our Scheme interpreter, e.g. +, list, modulo, etc.\nA user-defined procedure is a procedure defined by the user, either with a lambda expression or a define expression.\n· Applying user-defined procedures:\nStep 1. Open a new frame whose parent is the parent frame of the procedure being applied.\nStep 2. Bind the formal parameters of the procedure to the arguments in the new frame.\nStep 3. Evaluate the body of the procedure in the new frame.\n\n​                                                            （from CS61A Summer 2019 at UCB）\n","plink":"https://oreodu.github.io/2020/20200915-Scheme-Basics/"},{"title":"Programs Basics 01","date":"2020-09-10T05:07:00.000Z","date_formatted":{"ll":"Sep 10, 2020","L":"09/10/2020","MM-DD":"09-10"},"updated":"2020-10-03T18:16:16.604Z","content":"Programs Basis 01\nOverview\n(概略图)\n· materials:\n· Structure and Interpretation of Computer Programs by Harold Abelson and Gerald Jay Sussman with Julie Sussman\n· CS61A Summer 2019 at UCB\n· Wikipedia\nGoals of Program Decomposition\n1.Complexity Management\n2.Reusability and abstraction\nPart.1 Building Abstractions with Procedures\nA function should solve one problem.\nA function should have the smallest number of parameters possible to solve its problem.\nA repeated sequence should be put in its own function.\nAvoid repeating more than a couple lines of code.\nmicro level - take one of those smaller functions and identify smaller problems within that that WONT necessarily identifying separate questions and reusing them\nPart.2 Building Abstractions with Data\nData abstraction lets us manipulate compound values as units.\nIsolate two parts of any program that uses data:\nHow data are represented (as parts)\nHow data are manipulated (as units)\nData abstraction: A methodology by which functions enforce an abstraction barrier between representation and use.\nAbstraction Barriers:\n1234567891011121314151617# constructor rational(n,d)  returns a rational number # Selector numerator(x),     returns the numerator of x#          denominator(x)    returns the denominator of xdef mul_rational(x, y):    return rational(numer(x) * numer(y),                    denom(x) * denom(y))def add_rational(x, y):    nx, dx = numer(x), denom(x)    ny, dy = numer(y), denom(y)    return rational(nx * dy + ny * dx, dx * dy)def print_rational(x):    print(numer(x), &#x27;/&#x27;, denom(x))def rationals_are_equal(x, y):    return numer(x) * denom(y) == numer(y) * denom(x)\n\n\nParts of the program that…\nTreat rationals as…\nUsing…\n\n\n\n\nUse rational numbers to perform computation\nwhole data values\nadd_rational, mul_rational, rationals_are_equal, print_rational\n\n\nCreate rationals or implement rational operations\nnumerators and denominators\nrational, numer, denom\n\n\nImplement selectors and constructor for rationals\ntwo-element lists\nlist literals and element selection\n\n\n\n\nDecomposition\nProgram Decomposition is a process for breaking down large problems into logical sub-problems.\n\n\n1.A well decomposed function is sometimes likened to a “black box”. The black box presents the simplest possible abstraction to describe what the output will be and hides the implementation. Its inner workings are not revealed.\nData abstraction is an example of this. For constructors &amp; selectors, we don’t care about the body of the function. We only need to know what they take as input and their intended result.\n2.Decomposition is a divide and conquer strategy. （The process of breaking a large problem into more manageable sub-problems）\nFrom the outside, black boxes are simply defined in terms of their input and output, so they are easy to piece together.\nPart.3 Program Paradigms\nProgram is the way approach writing program and program’s relationship to how it’s executed by  the interpreter or complier.\nImperative program contain explicit instructions to tell the computer how to accomplish something. The interpreter(which is designed to execute as optimally as possible) then executes those instructions.\nDeclarative programming, where we can just tell the computer what we want, instead of how we want it done. The interpreter then figures out how to accomplish that.\nPart.4 Interpreting Computer Programs\n**Ⅰ. Interpreter **\nThere are two languages involved:\nImplemented language: this is the language the user types in.\nImplementation language: this is the language that interpreter is implemented in.\n(Implemented Language is translated into the Implementation Language)\nThe translation step in a couple forms:\t\nCompiled (pre-translated) - translate all at once and run later. (C, C++…)\nInterpreted (translated on-the-fly) - translate while the program is running. (Python, Java…)\nAn interpreter does 3 things:\nReads input from user in a specific programming language.\nTranslates input to be computer readable and evaluates the result.\nPrints the result for the user.\n\n​                                                    (from CS61A Summer 2019 at UCB)\n1.Read\n1.Lexical Analysis (Lexer):\nTurning the input into a collection of tokens. A token: single input of the input string, e.g. literals, names, keywords, delimiters.\n2.Syntactic Analysis (Parser):\nTurning tokens into a representation of the expression in the implementing language.\n2.Evaluate\nRules for evaluating an expression depends on the expression’s type.\n· Frames and Environments\nWhen evaluating expressions, the current environment consists of the current frame, its parent frame, and all its ancestor frames until the Global Frame.\nFrames are represented in our interpreter as instances of the Frame class. Each frame instance has two instance attributes:\nbindings: a dictionary that binds strings to values.\nparent: the parent frame, another Frame instance.\nThe evaluator needs to know the current environment, given as a single Frame instance, in order to look up names in expressions.\nSee the evaluating process of Scheme here\nPart.3 Modularity, Objects, and State\nPart.4 Meta-Linguistic Abstraction\nPart.5 Register Machine’ Model of Control\n","plink":"https://oreodu.github.io/2020/20200910-Programs-Basics-01/"},{"title":"Python Basis 03","date":"2020-09-08T13:28:00.000Z","date_formatted":{"ll":"Sep 8, 2020","L":"09/08/2020","MM-DD":"09-08"},"updated":"2020-10-03T18:16:10.730Z","content":"Python Basis 03\nOverview\n· materials:\n· Python for Everybody (Exploring Data Using Python 3)  by Charles R. Severance\n· Learn Python 3 the Hard Way by Zed A. Shaw\n· Python-100-Days by jackfrued\n· Python Tutorial\n· Google Python Style Guide\nPart.1 Process and thread\nPart.2 Network Programming\nPart.3 Using Web Services\nPart.4 Databases\nPart.5 Data Visualization\n","plink":"https://oreodu.github.io/2020/20200908-Python-Basics-03/"},{"title":"Python Basis 02","date":"2020-09-06T07:48:00.000Z","date_formatted":{"ll":"Sep 6, 2020","L":"09/06/2020","MM-DD":"09-06"},"updated":"2020-10-03T18:16:02.960Z","content":"Python Basis 02\nOverview\n\n· materials:\n· Python for Everybody (Exploring Data Using Python 3)  by Charles R. Severance\n· Learn Python 3 the Hard Way by Zed A. Shaw\n· Python-100-Days by jackfrued\n· Python Tutorial\n· Google Python Style Guide\nPart.1 Input and Output\nUsually, we have several ways to get the data we need from the outside. There are two main ways.\nWe can simply use input() to get the data from the input devices like keyboards.\n1data = input(&quot;Enter the data:&quot;)\nAnother way is to read the files from our computers or different database.\nⅠ. File\nOpen the file.\n12file = open(filename, mode=&#x27;r&#x27;, buffering=-1, encoding=None, errors=None, newline=None, closefd=True, opener=None)# mode can be &#x27;w&#x27;,&#x27;r&#x27;,&#x27;a&#x27;... (describing the way in which the file will be used)\n\n(from here)\nIt is better to use the with keyword when dealing with file objects. The advantage is that the file is properly closed after all the operations have finished, even if an exception is raised at some point. Otherwise,  you should call f.close() to close the file and immediately free up any system resources used by it.\n12with open(&#x27;workfile&#x27;) as f:    read_data = f.read()\nThe open() method returns a file object and it has lots of built-in methods to deal with the data.\n1234567891011121314151617181920# Reads some quantity of data and returns it as a string (in text mode)f.read(size)# Read a single line from the file,a newline character (\\n) is left.f.readline()# Read lines from a file, you can loop over the file object. for line in f:     print(line, end=&#x27;&#x27;)# Read all the lines of a file in a list or use readlines().list(f)f.readlines()# Write the contents of string to the file, returning the number of characters written.# Other types of objects need to be converted before writing to the file.f.write(string)# Returns an integer giving the file object’s current position.f.tell()# Change the file object’s position# whence: 0-begining,1-current,2-endf.seek(offset, whence)\nⅡ. Output Formatting\nThere are several ways to present the output of a program : expression statements and the print()  function. (A third way is using the write() method of file objects;)\n12345a  = int(input (&#x27;a = &#x27;)) # 123.4b  = int(input (&#x27;a = &#x27;)) # 123.3print(&#x27;%d +%d = %d&#x27; % (a, b,a + b)) # 123 + 123 = 246print(f&#x27;&#123;a&#125;+&#123;b&#125; = &#123;a+b&#125;&#x27;) # 123 + 123 = 246print(&#x27;&#123;0&#125;+&#123;1&#125; = &#123;2&#125;&#x27;.format(a, b, a + b)) # 123 + 123 = 246\n( % is  format operator.  %x is a placeholder. %d is for the integer.  %f is for the decimal.%% is for the percent sign. The strings after the % will replace the placeholder and output to the terminal )\nWhen you don’t need fancy output but just want a quick display of some variables for debugging purposes, you can convert any value to a string with the repr() or str() functions.\n12345&gt;&gt;&gt; s = &#x27;Hello, world.&#x27;&gt;&gt;&gt; str(s)&#x27;Hello, world.&#x27;&gt;&gt;&gt; repr(s)&quot;&#x27;Hello, world.&#x27;&quot;\nPart.2  Scopes and Namespaces\nⅠ. Namespaces\nA namespace is a mapping from names to objects. Most namespaces are currently implemented as Python dictionaries.\nExamples of namespaces are:\n· the set of built-in names (containing functions such as abs(), and built-in exception names);\n· the global names in a module;\n· the local names in a function invocation.\nThere is absolutely no relation between names in different namespaces. Users of the modules must prefix the  items, which are the same name, with the module name.\nNamespaces are created at different moments and have different lifetimes.\nThe namespace containing the built-in names is created when the Python interpreter starts up, and is never deleted.\nThe global namespace for a module is created when the module definition is read in. Normally, module namespaces also last until the interpreter quits.\nThe local namespace for a function is created when the function is called, and deleted when the function returns or raises an exception that is not handled within the function.\nⅡ. Scope\nA scope is a textual region of a Python program where an unqualified reference to a name attempts to find the name in the namespace.\nAlthough scopes are determined statically, they are used dynamically. At any time during execution, there are 3 or 4 nested scopes whose namespaces are directly accessible:\n\n· the innermost scope, which is searched first, contains the local names\n· the scopes of any enclosing functions, which are searched starting with the nearest enclosing scope, contains non-local, but also non-global names\n· the next-to-last scope contains the current module’s global names\n· the outermost scope (searched last) is the namespace containing built-in names\n\nThe global statement can be used to indicate that particular variables live in the global scope and should be rebound there;\nThe nonlocal statement is used to rebind variables found outside of the innermost scope and indicates that particular variables live in an enclosing scope.\n12345678910111213141516171819202122def scope_test():    def do_local():        spam = &quot;local spam&quot;    def do_nonlocal():        nonlocal spam        spam = &quot;nonlocal spam&quot;    def do_global():        global spam        spam = &quot;global spam&quot;    spam = &quot;test spam&quot;    do_local()    print(&quot;After local assignment:&quot;, spam) # After local assignment: test spam    do_nonlocal()    print(&quot;After nonlocal assignment:&quot;, spam) # After nonlocal assignment: nonlocal spam    do_global()    print(&quot;After global assignment:&quot;, spam) # After global assignment: nonlocal spamscope_test()print(&quot;In global scope:&quot;, spam) # In global scope: global spam\nPart.3  Class\nⅠ. Object-oriented programming (OOP)\nPython is  an object-oriented programing language and almost every operational item in python is an object. OOP is a computer programming model that organizes software design around objects, rather than functions and logic.  An object can be defined as a data field that has unique attributes and behavior.\nObject-oriented programming is based on the following principles:\n\n\nEncapsulation: The implementation and state of each object are privately held inside a defined  class and require all interaction to be performed through an object’s methods.\n\n\nAbstraction:  Objects only reveal internal mechanisms that are relevant for the use of other objects, hiding any unnecessary implementation code.\n\n\nInheritance: Relationships and subclasses between objects can be assigned, allowing developers to reuse a common logic while still maintaining a unique hierarchy.\n\n\nPolymorphism: It is the provision of a single interface to entities of different types or the use of a single symbol to represent multiple different types.\n\n\nPython is multi-paradigm with OOP support and is class-based. Classes provide a means of bundling data and functionality together. Each class instance can have attributes attached to it for maintaining its state(the set of values of the attributes of a particular instance) and methods (defined by its class) for modifying its state.\nⅡ. Create a class\nSome concepts:\n· Class: Used to describe a collection of objects with the same properties and methods. It defines the attributes and methods common to each object in the collection. A class serves as a blueprint for its instances\n· Method: The function defined in the class.\n· Class variable: Class Variables are variables that are shared by all instances of a class and are defined in the class and outside the function body. Class variables are usually not used as instance variables.\n· Instance variable: Instance variables are variables used for data that is unique to a particular instance and an instance variable is a variable modified with self.\n· Data members: Class variables or instance variables which are used to process data related to the class and its instance objects.\n· Instantiation: Create an instance of a class, the concrete object of the class.\n· Class method: A class method receives the class as implicit first argument  which is bound to the class and not the instance of the class. They have the access to the state of the class as it takes a class parameter that points to the class and not the object instance. It can modify a class state that would apply across all the instances of the class. For example it can modify a class variable that will be applicable to all the instances.\n· Static method: A static method does not receive an implicit first argument. A static method is also a method which is bound to the class and not the instance of the class. It can’t access or modify class state. It is present in a class because it makes sense for the method to be present in class.\n· Abstract method: An abstract method represents a method of the base class, which is not implemented, so the base class cannot be instantiated. And the subclass can only be instantiated if the abstract method is implemented.\n· Bound method: Methods that are accessed through an instance will be bound methods. They couple together a function and the object on which that method will be invoked. This means that when we invoke bound methods, the instance is automatically passed in as the first argument (self).\nClass objects support two kinds of operations: attribute references and instantiation.\n1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950class people:    # define the basic attribute    kind = &#x27;mammalia&#x27; # class variable shared by all instances        # define the construction method with &#x27;__init__()&#x27;.    # the instantiation operation of the class will automatically call this method.    # The method must contain the parameter &#x27;self&#x27; in the first.    # &#x27;Self&#x27; represents an instance of the class.    def __init__(self,n,a,w):        self.name = n   # instance variable unique to each instance        self.age = a        # define private attributes which cannot be accessed directly outside the class        # starting with two underscores &#x27;__&#x27;.        # It can be accessed by getter and modified by setter.        self.__weight = w            @property # Accessor-getter method    def weight(self):        return self.__weight        @weight.setter # Modifier-setter method    def weight(self, weight):        self.__weight = weight            # define private method    def __foo(self):                  print(&#x27;This is a private method.&#x27;)            def speak(self):        print(&quot;%s said: I am %d years old.&quot; %(self.name,self.age))        self.__foo()         @staticmethod    def staticm():        print(&#x27;static&#x27;)            @classmethod    def classm(cls):        print(&#x27;class&#x27;,cls）                  @abstractmethod    def abstractm(self):        pass# Instance objects can only understand attribute references operations. # There are two kinds of valid attribute names: data attributes and methods.# The instantiation operation of the classp = people(&#x27;Oreo&#x27;,10,30)p.speak() # Oreo said: I am 10 years old. This is a private method. # This is equal to people.speak(p)\nWhen a class definition is entered, a new namespace is created, and used as the local scope — thus, all assignments to local variables go into this new namespace. In particular, function definitions bind the name of the new function here. Binding an object to a new name using assignment does not create a new object(only created when the class is called). Every object that is an instance of a user-defined class has a unique identity.\nPython allows you to define a special __slots__ variable when defining a class to limit the attributes that can be added to the class instance.\nThe dir() method can return a list of valid attributes and methods of the object.\nThere are built-in functions that can help us access attributes.\n12getattr(p, &#x27;name&#x27;) # which is the same as p.namegetattr(people, &#x27;kind&#x27;) # which is the same as people.kind\n12hasattr(p, &#x27;balance&#x27;) # returns Falsehasattr(people, &#x27;kind&#x27;) # returns True\n**The evaluation of dot expression: **\nWe can access class or instance attributes with dot notation. To evaluate a dot expression:\n1.Evaluate &lt;expression&gt;, which yields an object.\n2.&lt;name&gt; is matched against the instance attributes of that object; if an attribute with that name exists, its value is returned.\n3.If not, the name is looked up in the class, which yields a class attribute value. If it is not found in the class, look in any superclasses.\n4.That value is returned unless it is a function, in which case a bound method is returned instead.\nⅢ. Features\n· Inheritance\nThis allows classes to be arranged in a hierarchy that represents “is-a-type-of” relationships and allows easy re-use of the same procedures and data definitions.\n· Method override\nSubclasses can override the methods defined by superclass.\n123456789101112131415161718192021222324252627282930313233# Single inheritanceclass student(people):    grade = &#x27;&#x27;    def __init__(self,n,a,w,g):        # Call the constructor of the parent class        people.__init__(self,n,a,w)        self.grade = g     # Override the method of the parent class    def speak(self):        print(&quot;%s said: I am %d years old and is %d grade.&quot;%(self.name,self.age,self.grade)) class speaker():    topic = &#x27;&#x27;    name = &#x27;&#x27;    def __init__(self,n,t):        self.name = n        self.topic = t    def speak(self):        print(&quot;My name is %s，I am a speaker and the topic of my speech is %s.&quot;%(self.name,self.topic)) # Multiple inheritanceclass sample(speaker,student):    a =&#x27;&#x27;    def __init__(self,n,a,w,g,t):        student.__init__(self,n,a,w,g)        speaker.__init__(self,n,t) test = sample(&quot;Oreo&quot;,25,80,4,&quot;Python&quot;)# If the method names are the same, # the method of the parent class in front of the brackets is called by default.test.speak()   # My name is Oreo，I am a speaker and the topic of my speech is Python.# test.speak() is a method object and can be stored away and called at a later time.\nThe super() function is a method used to call the parent class. super(student,test).speak()\n· Operator overloading\nIt is a specific case of polymorphism, where different operators have different implementations depending on their arguments.\n1234567891011121314class Vector:   def __init__(self, a, b):      self.a = a      self.b = b    def __str__(self):      return &#x27;Vector (%d, %d)&#x27; % (self.a, self.b)      def __add__(self,other):      return Vector(self.a + other.a, self.b + other.b) v1 = Vector(2,10)v2 = Vector(5,-2)print (v1 + v2)\n· Special method\nThey are a variety of instance methods that are reserved by Python, which affect an object’s high level behavior and its interactions with operators.\n\n\nMethod\nSignature\nExplanation\n\n\n\n\nReturns string for a printable representation of object\n__repr__(self)\nrepr(x) invokes x.__repr__(),this is also invoked when an object is returned by a console.\n\n\nReturns string representation of an object\n__str__(self)\nstr(x) invokes x.__str__()\n\n\nAdd\n__add__(self, other)\nx + y invokes x.__add__(y)\n\n\nSubtract\n__sub__(self, other)\nx - y invokes x.__sub__(y)\n\n\nMultiply\n__mul__(self, other)\nx * y invokes x.__mul__(y)\n\n\nDivide\n__truediv__(self, other)\nx / y invokes x.__truediv__(y)\n\n\nPower\n__pow__(self, other)\nx ** y invokes x.__pow__(y)\n\n\nLength\n__len__(self)\nlen(x) invokes x.__len__()\n\n\nGet Item\n__getitem__(self, key)\nx[key] invokes x.__getitem__(key)\n\n\nSet Item\n__setitem__(self, key, item)\nx[key] = item invokes x.__setitem__(key, item)\n\n\nContains\n__contains__(self, item)\nitem in x invokes x.__contains__(item)\n\n\nIterator\n__iter__(self)\niter(x) invokes x.__iter__()\n\n\nNext\n__next__(self)\nnext(x) invokes x.__next__()\n\n\nPart.4 Iterators and Generators\nIn python, iterators and generators allowed for lazy evaluation. (delays evaluation of an expression until its value is needed.)\nⅠ. Iterators\nIterators are used to represent infinite sequences.\nIterable - An object capable of returning its members one at a time. Examples include all sequences (lists, strings, tuples) and some non-sequence types (dictionaries).\nAn iterator is an object that can remember the position of the traversal. It accesses the first element of the collection(any container object) until all the elements are accessed and it can only go forward.\nAll iterators are iterables. Not all iterables are iterators. Iterables are books &amp; Iterators are bookmarks.\nThere are two basic methods for iterators: iter(iterable) and next(iterator). String, list or tuple objects can all be used to create iterators.\n123list=[1,2,3,4]it = iter(list)    # Create iterator object (Turn iterables into iterators)print (next(it))   # Output the next element of the iterator # 1\nUsing a class as an iterator requires implementing two methods in the class __iter__() and __next__().\n12345678910111213141516171819class MyNumbers:  def __iter__(self):    self.a = 1    return self   def __next__(self):    if self.a &lt;= 20:      x = self.a      self.a += 1      return x    else:      raise StopIteration     # be triggered to end the iteration after completing the specified number of loops. myclass = MyNumbers()myiter = iter(myclass) for x in myiter:  print(x)\nThe __iter__() method returns a special iterator object, which implements the __next__() method that returns the next iterator object and accesses elements in the container one at a time. When there are no more elements, __next__() raises a  StopIteration exception  to identify the completion of the iteration.\nⅡ.  Generators\nIn Python, a function that uses yield is called a generator.\nGenerators are a simple and powerful tool for creating iterators. They are written like regular functions but use the yield statement whenever they want to return data. Each time next() is called on it, the generator goes into the function and evaluates to the first yield statement. The next time we call next on it, it  resumes where it left off (it remembers all the data values and which statement was last executed). Once the generator hits a return statement, it raises a StopIteration.\nWhen a generator function is called, it returns a generator instead of going into the body of the function. The only way to go into the body of a generator function is by calling next on the returned generator.\n123456789101112131415161718import sys def fibonacci(n):    a, b, counter = 0, 1, 0    while True:        if (counter &gt; n):             return        yield a        a, b = b, a + b        counter += 1        f = fibonacci(10) # f is an iterator and return by the generator function(fibonacci). while True:    try:        print (next(f), end=&quot; &quot;)    except StopIteration:        sys.exit()\nA yield from statement yields all values from an iterable.\n123456def countdown(k):\tif k == 0:\t\tyield &#x27;Blast off&#x27;\telse:\t\tyield k\t\tyield from countdown(k-1)\nPart.5 Regular Expressions\nⅠ. Basic concept\nRegular expression is a sequence of characters that define a search pattern. It can be used to check whether a string contains a certain substring, replace the matched substring, or extract it.\n123Oreoisa*irl # &#x27;*&#x27; means the preceding character can appear 0 or 1 or more times.Oreoisa+irl # &#x27;+&#x27; means the preceding character must appear at least once.Oreoisa?irl # &#x27;?&#x27; means the preceding character can appear only 0 or 1 time.\nRegular expressions are text patterns composed of ordinary characters (such as characters a to z) and special characters (called “metacharacters”). The components of a regular expression can be a single or a set of characters, the range of characters, a selection between characters, or any combination of all these components.\n· ordinary character\n\n\ncharacter\ndescription\n\n\n\n\n[ABC]\nmatch all the characters in the […]\n\n\n[^ABC]\nmatch any character except the ones in the […]\n\n\n[A-Z]\nmatch all the characters range from the first character in the […] to the last one.\n\n\n.\nmatches any single character except the newline character (\\n, \\r), which is equivalent to [^\\n\\r].\n\n\n[\\s\\S]\nmatch all the characters. \\s matches all whitespace characters, including newlines, \\S  matches non-whitespace characters, including newlines.\n\n\n\\w\nmatch letters, numbers, and underscores. Equivalent to [A-Za-z0-9_]\n\n\n…\n\n\n\n· Non-printing characters\n\n\ncharacter\ndescription\n\n\n\n\n\\f\nMatches a form feed character. Equivalent to \\x0c and \\cL.\n\n\n\\n\nMatch a newline character. Equivalent to \\x0a and \\cJ.\n\n\n\\r\nMatches a carriage return character. Equivalent to \\x0d and \\cM.\n\n\n…\n\n\n\n· Special characters\n\n\ncharacter\ndescription\n\n\n\n\n$\nMatch the end position of the input string. To match the $ character itself, use \\$.\n\n\n()\nMark the beginning and end of a sub-expression. The sub-expression can be retrieved for later use. To match these characters, use \n` and `\n\n\n\n\n\n\n\n \n \n \n \n \n\n.\n\n\n*,+,?\nSee details above. To match the *,+,? character itself, use \\*,\\+,\\?\n\n\n|\nSpecify a choice between the two. To match \\|, use \\|\n\n\n…\n\n\n\n· Qualifier\nThe qualifier is used to specify how many times a given component of the regular expression must appear to satisfy the match. There are 6 kinds of * or + or ? or &#123;n&#125;  or &#123;n,&#125; or  &#123;n,m&#125;.\n\n\ncharacter\ndescription\n\n\n\n\n&#123;n&#125;\nn is a non-negative integer. Matches certain character n times.\n\n\n&#123;n,&#125;\nn is a non-negative integer. Matches certain character at least n times.\n\n\n&#123;n,m&#125;\nBoth m and n are non-negative integers, where n &lt;= m. Matches certain character at least n times and at most m times.\n\n\nThe repeat character(* or + ) push outward in both directions(greedy matching) to match the largest possible string. However, if we add a ? , * or +  chill out a bit.\n· Locator\nThe locator allows you to fix the regular expression to the beginning or end of a line. Or used to describe the boundary of a string or word.\n\n\ncharacter\ndescription\n\n\n\n\n^\nMatches the position at the beginning of the input string.\n\n\n$\nMatches the position at the end of the input string.\n\n\n\\b\nMatch a word boundary, that is, the position between a word and a space.\n\n\n\\B\nMatch any character except a word boundary.\n\n\n· Selection\n()  means the capture group, () will save the matching value in each group, multiple matching values can be viewed by the number n (n is a number, representing the content of the nth capture group).\n12/([0-9])([a-z]+)  \\1 /g  # \\1 specifies the first submatch.# Capture all strings that start with a number and end with multiple letters\nParentheses tell where to start and stop what string to extract.\n· Non-capturing element\n\n\ncharacter\ndescription\n\n\n\n\n?=\nexp1(?=exp2) : Find exp1 before exp2\n\n\n?&lt;=\n(?&lt;=exp2)exp1 : Find exp1 after exp2\n\n\n?!\nexp1(?!exp2) : Find exp1 that does not follow exp2.\n\n\n?&lt;!\n(?&lt;!=exp2)exp1 : Find exp1 that is not preceding exp2.\n\n\n· Modifier (tag)\nTags are used to specify additional matching strategies and are written outside the expression.\n\n\ncharacter\ndescription\n\n\n\n\ni\nignore : not case sensitive\n\n\ng\nglobal : Global match\n\n\nm\nmore : Multi-line matching\n\n\ns\nMake the special character dot contains the newline character \\n\n\n\n· Operator precedence\n\\, (), (?:), (?=), [], *, +, ?, &#123;n&#125;, &#123;n,&#125;, &#123;n,m&#125;, ^, $, \\any character、any character, |\nⅡ. re — Regular expression operation\nMore details\n· re.match and re.search\nre.match only matches the beginning of the string. If the string does not match the regular expression at the beginning, the match fails, the function returns None, and re.search matches the entire string until a match is found.\n12345678910111213141516171819202122# re.match(pattern, string, flags=0)import re line = &quot;Cats are smarter than dogs&quot; matchObj = re.match( r&#x27;dogs&#x27;, line, re.M|re.I)if matchObj:   print (&quot;match --&gt; matchObj.group() : &quot;, matchObj.group())else:   print (&quot;No match!!&quot;) matchObj = re.search( r&#x27;dogs&#x27;, line, re.M|re.I)if matchObj:   print (&quot;search --&gt; matchObj.group() : &quot;, matchObj.group())else:   print (&quot;No match!!&quot;)&quot;&quot;&quot;No match!!search --&gt; matchObj.group() :  dogs&quot;&quot;&quot;\n· re.sub\n1234567891011# re.sub(pattern, repl, string, count=0, flags=0)import re # Multiply the matched number by 2def double(matched):    value = int(matched.group(&#x27;value&#x27;))    return str(value * 2) s = &#x27;A23G4HFD567&#x27;# ?P&lt;value&gt; means to name a group as value to match the rule to match the following /d+print(re.sub(&#x27;(?P&lt;value&gt;\\d+)&#x27;, double, s)) # A46G8HFD1134\n· re.compile\nThe compile function is used to compile regular expressions and generate a regular expression (Pattern) object for use by the match() and search() functions.\n12345678910111213&gt;&gt;&gt;import re&gt;&gt;&gt; pattern = re.compile(r&#x27;\\d+&#x27;)                    # Match at least one digit&gt;&gt;&gt; m = pattern.match(&#x27;one12twothree34four&#x27;, 3, 10) # Match from the position of &#x27;1&#x27;&gt;&gt;&gt; print( m )                                        # Returns a Match object&lt;_sre.SRE_Match object at 0x10a42aac0&gt;&gt;&gt;&gt; m.group(0)   &#x27;12&#x27;&gt;&gt;&gt; m.start(0)   3&gt;&gt;&gt; m.end(0)     5&gt;&gt;&gt; m.span(0)    (3, 5)\n· findall\n12345678import re pattern = re.compile(r&#x27;\\d+&#x27;)   # find numberresult1 = pattern.findall(&#x27;runoob 123 google 456&#x27;)result2 = pattern.findall(&#x27;run88oob123google456&#x27;, 0, 10) print(result1) # [&#x27;123&#x27;, &#x27;456&#x27;]print(result2) # [&#x27;88&#x27;, &#x27;12&#x27;]\nPart.5 Test\nⅠ. doctest — Test interactive Python examples\nThe doctest module searches for pieces of text that look like interactive Python sessions, and then executes those sessions to verify that they work exactly as shown.\n123456789101112def multiply(a, b):    &quot;&quot;&quot;    &gt;&gt;&gt; multiply(4, 3)    12    &gt;&gt;&gt; multiply(&#x27;a&#x27;, 3)    &#x27;aaa&#x27;    &quot;&quot;&quot;    return a * bif __name__==&#x27;__main__&#x27;:    import doctest    doctest.testmod(verbose=True)\nⅡ. unittest — Unit testing framework\nThe unittest unit testing framework was originally inspired by JUnit and has a similar flavor as major unit testing frameworks in other languages. It supports test automation, sharing of setup and shutdown code for tests, aggregation of tests into collections, and independence of the tests from the reporting framework.\n1234567891011121314151617181920import unittestclass TestStringMethods(unittest.TestCase):    def test_upper(self):        self.assertEqual(&#x27;foo&#x27;.upper(), &#x27;FOO&#x27;)    def test_isupper(self):        self.assertTrue(&#x27;FOO&#x27;.isupper())        self.assertFalse(&#x27;Foo&#x27;.isupper())    def test_split(self):        s = &#x27;hello world&#x27;        self.assertEqual(s.split(), [&#x27;hello&#x27;, &#x27;world&#x27;])        # check that s.split fails when the separator is not a string        with self.assertRaises(TypeError):            s.split(2)if __name__ == &#x27;__main__&#x27;:    unittest.main()\nPart.6 Errors and Exceptions\nProgram should be written precisely otherwise the deviations and mistakes in your code will cause the Python to stop and can’t work out the final result. There are three main types of errors that you may encounter during.\n· Syntax errors:\nA syntax error means that you have violated the “grammar” rules of Python.\n· Logic errors:\nA mistake in the order of the statements or in how the statements relate to one another.\n· Semantic errors:\nThe program is perfectly correct but it does not do what you intended for it to do.\n· Exceptions\nErrors detected during execution are called exceptions and are not unconditionally fatal. Most exceptions are not handled by programs, however, and result in error messages. Exceptions come in different types, and the type is printed as part of the message.\nBuilt-in Exceptions  lists the built-in exceptions and their meanings.\n· Handling Exceptions\nIt is possible to write programs that handle selected exceptions. A user-generated interruption is signaled by raising different types of exception.\ntry/except :\n12345678910111213import systry:    f = open(&#x27;myfile.txt&#x27;)    s = f.readline()    i = int(s.strip())except OSError as err:    print(&quot;OS error: &#123;0&#125;&quot;.format(err))except ValueError:    print(&quot;Could not convert data to an integer.&quot;)except:    print(&quot;Unexpected error:&quot;, sys.exc_info()[0])    raise\ntry/except … else :\n123456789for arg in sys.argv[1:]:    try:        f = open(arg, &#x27;r&#x27;)    except IOError:        print(&#x27;cannot open&#x27;, arg)    else:        # Excute when there is no error happen        print(arg, &#x27;has&#x27;, len(f.readlines()), &#x27;lines&#x27;)         f.close()\ntry-finally :\n123456789101112try:    function()except AssertionError as error:    print(error)else:    try:        with open(&#x27;file.log&#x27;) as file:            read_data = file.read()    except FileNotFoundError as fnf_error:        print(fnf_error)finally:    print(&#x27;This line will be executed regardless of whether an exception occurs.&#x27;)\n· Raising Exceptions\nThe sole argument to raise indicates the exception to be raised. This must be either an exception instance or an exception class\n123456try:    if x &gt; 5:        raise Exception(&#x27;x can not be greater than 5。x : &#123;&#125;&#x27;.format(x))except Exception:     print(&#x27;An exception flew by!&#x27;)     raise\n· User-defined Exceptions\nPrograms may name their own exceptions by creating a new exception class\n12345678910class MyError(Exception):        def __init__(self, value):            self.value = value        def __str__(self):            return repr(self.value)   try:    raise MyError(2*2)except MyError as e:    print(&#x27;My exception occurred, value:&#x27;, e.value) # My exception occurred, value: 4\n· Assert (prevent bugs)\nThe assert keyword lets you test if a condition in your code returns True, if not, the program will raise an AssertionError.\n1234567assert expressionif not expression:    raise AssertionError    import sysassert (&#x27;linux&#x27; in sys.platform), &quot;This code can only be excuted in Linux.&quot;\nPart.7 Standard Library\nFor details\nPart. Exercise\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110import randomclass Card(object):    &quot;&quot;&quot;One card&quot;&quot;&quot;    def __init__(self, suite, face):        self._suite = suite        self._face = face    @property    def face(self):        return self._face    @property    def suite(self):        return self._suite    def __str__(self):        if self._face == 1:            face_str = &#x27;A&#x27;        elif self._face == 11:            face_str = &#x27;J&#x27;        elif self._face == 12:            face_str = &#x27;Q&#x27;        elif self._face == 13:            face_str = &#x27;K&#x27;        else:            face_str = str(self._face)        return &#x27;%s%s&#x27; % (self._suite, face_str)        def __repr__(self):        return self.__str__()class Poker(object):    &quot;&quot;&quot;A deck of cards&quot;&quot;&quot;    def __init__(self):        self._cards = [Card(suite, face)                        for suite in &#x27;♠♥♣♦&#x27;                       for face in range(1, 14)]        self._current = 0    @property    def cards(self):        return self._cards    def shuffle(self):        &quot;&quot;&quot;Shuffle (random out of order)&quot;&quot;&quot;        self._current = 0        random.shuffle(self._cards)    @property    def next(self):        &quot;&quot;&quot;Deal a card&quot;&quot;&quot;        card = self._cards[self._current]        self._current += 1        return card    @property    def has_next(self):        &quot;&quot;&quot;have card or not&quot;&quot;&quot;        return self._current &lt; len(self._cards)class Player(object):    &quot;&quot;&quot;Player&quot;&quot;&quot;    def __init__(self, name):        self._name = name        self._cards_on_hand = []    @property    def name(self):        return self._name    @property    def cards_on_hand(self):        return self._cards_on_hand    def get(self, card):        &quot;&quot;&quot;Draw a card&quot;&quot;&quot;        self._cards_on_hand.append(card)    def arrange(self, card_key):        &quot;&quot;&quot;Arrange the cards in his hand&quot;&quot;&quot;        self._cards_on_hand.sort(key=card_key)# Sorting rules-sort by suit and then by pointsdef get_key(card):    return (card.suite, card.face)def main():    p = Poker()    p.shuffle()    players = [Player(&#x27;1&#x27;), Player(&#x27;2&#x27;), Player(&#x27;3&#x27;), Player(&#x27;4&#x27;)]    for _ in range(13):        for player in players:            player.get(p.next)    for player in players:        print(player.name + &#x27;:&#x27;, end=&#x27; &#x27;)        player.arrange(get_key)        print(player.cards_on_hand)if __name__ == &#x27;__main__&#x27;:    main()\n","plink":"https://oreodu.github.io/2020/20200906-Python-Basics-02/"},{"title":"Feature Engineering","date":"2020-07-16T09:32:00.000Z","date_formatted":{"ll":"Jul 16, 2020","L":"07/16/2020","MM-DD":"07-16"},"updated":"2020-10-03T18:15:53.917Z","content":"Overview\n(概略图)\n· materials:\n· Wikipedia\n· Machine Learning\n","plink":"https://oreodu.github.io/2020/20200716-Feature-Engineering/"},{"title":"Convolutional Neural Networks","date":"2020-06-25T15:36:00.000Z","date_formatted":{"ll":"Jun 25, 2020","L":"06/25/2020","MM-DD":"06-25"},"updated":"2020-10-03T18:15:47.459Z","content":"Convolutional Neural Networks (CNN)\nOverview\n(概略图)\n· materials:\n· Wikipedia\n· Sources NO.1\n· Sources NO.2\n· Sources NO.3\n\nA Convolutional Neural Network is a Deep Learning algorithm which can take in an input image, assign importance (learnable weights and biases) to various objects in the image and be able to differentiate one from the other. ConvNets have the ability to learn these characteristics.\nThe architecture of a ConvNet is analogous to that of the connectivity pattern of Neurons in the Human Brain and was inspired by the organization of the Visual Cortex. Individual neurons respond to stimuli only in a restricted region of the visual field known as the Receptive Field. A collection of such fields overlap to cover the entire visual area.\nWhy CNN?\nA CNN, in specific, has one or more layers of convolution filters comparing to the multilayer perceptron. A convolution filter receives its input from multiple units from the previous layer which together create a proximity.\nThe convolution layers (as well as pooling layers) are especially beneficial as:\n\n**·**They uset the parameter sharing. A single filter is applied across different parts of an input to produce a feature map. So, they reduce the number of parameters in the network which reduces the chance of overfitting as the model would be less complex than a fully connected network (MLP).  Also, different filters can extract different kinds of features from an input.\n· They consider the shared information (the spatial features) in the small neighborhoods. Filters in the ConNets are used to extract the relevant features from the input using the convolution operation.\n· They learn the filters automatically without mentioning it explicitly. These filters help in extracting the right and relevant features from the input data.\n\nLayers\nConvolution layer\n\nThe convolution filters or kernels moves to the right with a certain Stride Value and  do the dot product till it parses the complete width. Moving on, it hops down to the beginning (left) of the image with the same Stride Value and repeats the process until the entire image is traversed.\nThe objective of the Convolution Operation is to extract the high-level features such as edges, from the input image. Each filter can extract different features.\nPading\nPadding is a technique to simply add zeros around the margin of the image to increase it’s dimension. Padding allows us to emphasize the border pixels and in order lose less information.\n\nSame Padding: Dimensionality is remains the same.\nValid Padding: Dimensionality is increased.\nFeature size = ((Image size + 2 * Padding size − Kernel size) / Stride)+1\nPooling layer\nPooling layer helps reduce the spatial size of the convolved features and also helps reduce over-fitting by providing an abstracted representation of them. It is a sample-based discretization process. Furthermore, it is useful for extracting dominant features which are rotational and positional invariant, thus maintaining the process of effectively training of the model.\n\nThe kernel take the max or average of the region from the input overlapped by the kernel.\nMax Pooling also performs as a Noise Suppressant. It discards the noisy activations altogether and also performs de-noising along with dimensionality reduction. On the other hand, Average Pooling simply performs dimensionality reduction as a noise suppressing mechanism. Hence, we can say that Max Pooling performs a lot better than Average Pooling.\nFully connected layer\nAdding a Fully-Connected layer is a cheap way of learning non-linear combinations of the high-level features as represented by the output of the convolutional layer.\nWe flatten the image into a column vector. The flattened output is fed to a feed-forward neural network and backpropagation applied to every iteration of training. Over a series of epochs, the model is able to distinguish between dominating and certain low-level features in images and classify them using the Softmax Classification technique.\n\nUsually, activation function and dropout layer are used between two consecutive fully connected layers to introduce non-linearity and reduce over-fitting respectively. At the last fully connected layer we choose the output size based on our application.\nDropout layer\nDropout is a regularization technique used to reduce over-fitting on neural networks. Usually, deep learning models use dropout on the fully connected layers, but is also possible to use dropout after the max-pooling layers, creating image noise augmentation.\nDropout randomly zeroes some of the connections of the input tensor with probability p using samples from a Bernoulli distribution.\n","plink":"https://oreodu.github.io/2020/20200625-Convolutional-Neural-Networks/"},{"title":"Support Vector Machines","date":"2020-06-05T07:45:00.000Z","date_formatted":{"ll":"Jun 5, 2020","L":"06/05/2020","MM-DD":"06-05"},"updated":"2020-10-03T18:15:41.145Z","content":"Support Vector Machines\nOverview\n(概略图)\n· materials:\n· Wikipedia\n· Machine Learning\n","plink":"https://oreodu.github.io/2020/20200605-Support-Vector-Machines/"},{"title":"Basic Model Selection and Evaluation","date":"2020-05-31T04:45:00.000Z","date_formatted":{"ll":"May 31, 2020","L":"05/31/2020","MM-DD":"05-31"},"updated":"2020-10-03T18:15:32.385Z","content":"Basic Model Selection and Evaluation\nOverview\n(概略图)\n· materials:\n· Wikipedia\n· Machine Learning\nThe recommended approach to solving machine learning problems is to:\n1) Start with a simple algorithm, implement it quickly, test it early on your cross validation data.\n2) Diagnosing bias and variance by ploting learning curves($ J_ {CV}(\\Theta)$ and $ J_ {train}(\\Theta)$) and gain guidance as to choose the right and effective solution to improve its performance.\n3) Tune the model hyperparameters.\n​      For example: Getting more training examples, Adding features, Decreasing λ…\n4) Manually examine the errors on examples in the cross validation set and try to spot a trend where most of the errors were made.\nModel Evaluation\nDuring the process of assessing the learning algorithm’s performance, it is important to do error analysis using some error metrics.\n1. Bias-Variance Trade-Off\nThe prediction error for most machine learning algorithm can be broken down into three parts:\n\nBias Error\nVariance Error\nIrreducible Error (introduced from the chosen framing of the problem which cannot be reduced.)\n\n· Bias are the simplifying assumptions made by a model to make the target function easier to learn.\n\nLow Bias: Suggests less assumptions about the form of the target function.\nHigh-Bias: Suggests more assumptions about the form of the target function.\n\n· Variance is the amount that the estimate of the target function will change if different training data was used.\n\nLow Variance: Suggests small changes to the estimate of the target function with changes to the training dataset, meaning that the algorithm is good at picking out the hidden underlying mapping between the inputs and the output variables.\nHigh Variance: Suggests large changes to the estimate of the target function with changes to the training dataset, meaning that the specifics of the training have influences the number and types of parameters used to characterize the mapping function.\n\nExamples of low-bias and high-variance machine learning algorithms include: Decision Trees, k-Nearest Neighbors and support Vector Machine.\nExamples of high-bias and low-variance machine learning algorithms include: Linear Regression, Linear Discriminant Analysis and Logistic Regression.\nMore details from here.\nUnderfitting, or high bias, is when the form of our hypothesis function h maps poorly to the trend of the data. It is usually caused by a function that is too simple or uses too few features.\nOverfitting, or high variance, is caused by a hypothesis function that fits the available data but does not generalize well to predict new data. It is usually caused by a complicated function that creates a lot of unnecessary curves and angles unrelated to the data.\nOptions address the issue of overfitting:\n\n\nReduce the number of features. (Manually or use model selection algorithm)\n\n\nRegularization. (Keep all the features, but reduce the magnitude of parameters $ \\theta_j$.)\n\n\nReduces over-fitting by adding a penalty to the loss function.\n\nDropout\n\nRegularization\nMore details from here.\n1.For linear regression:\nCost function:\n$  J(\\theta) =  \\frac{1}{2m} [ \\sum^{m}_ {i=1} {( h_ \\theta(x^{(i)}) - y^{(i)} )^2} +  \\lambda \\sum^{n}_ {j=1} \\theta_j^2 ] $\n$ \\lambda $ is the regularization parameter. It determines how much the costs of our theta parameters are inflated. (we don’t penalize the $\\theta_0 $)\nUsing the above cost function with the extra summation, we can smooth the output of our hypothesis function to reduce overfitting. If lambda is chosen to be too large, it may smooth out the function too much and cause underfitting.\nGradient descent:\n$ \\theta_0 := \\theta_0 - \\alpha \\frac{1}{m} \\sum_ {i=1}^m (h_\\theta(x^{(i)}) - y^{(i)})x_0^{(i)} $\n$ \\theta_j := \\theta_j (1-\\alpha \\frac{\\lambda}{m}) - \\alpha \\frac{1}{m} \\sum_ {i=1}^m ( h_\\theta(x^{(i)}) - y^{(i)})x_j^{(i)} $\nNormal Equation:\n$\\theta = \\left( X^TX + \\lambda \\cdot L \\right)^{-1} X^Ty $\n$ \\text{where}\\ \\ L = \\begin{bmatrix} 0 &amp; &amp; &amp; &amp; \\newline &amp; 1 &amp; &amp; &amp; \\newline &amp; &amp; 1 &amp; &amp; \\newline &amp; &amp; &amp; \\ddots &amp; \\newline &amp; &amp; &amp; &amp; 1 \\newline\\end{bmatrix} $\nIf m &lt; n (features), then $ X^TX $ is non-invertible. However, when we add the term λ⋅L, then $X^TX + λ⋅L $ becomes invertible.\n2.For logistic regression:\nCost function:\n$ J(\\theta) = - \\dfrac{1}{m} \\sum_ {i=1}^m[y^{(i)} \\log(h_ \\theta(x^{(i)})) + (1- y^{(i)}) \\log(1-h_ \\theta(x^{(i)})) ] + \\frac{1}{2m} \\lambda \\sum^{n}_ {j=1} \\theta_j^2  $\nGradient descent:\n$ \\theta_0 := \\theta_0 - \\alpha \\frac{1}{m} \\sum_ {i=1}^m (h_\\theta(x^{(i)}) - y^{(i)})x_0^{(i)} $\n$ \\theta_j := \\theta_j (1-\\alpha \\frac{\\lambda}{m}) - \\alpha \\frac{1}{m} \\sum_ {i=1}^m ( h_\\theta(x^{(i)}) - y^{(i)})x_j^{(i)} $\n2. Precision and Recall Trade-Off\n\n\n\nActual positive\nActual negative\n\n\n\n\nPredicted positive\nTrue Positive\nFalse Positive\n\n\nPredicted negative\nFalse Negative\nTrue Negative\n\n\n$ Accuracy  = \\frac{TP +TN }{TP + FP + FP + TN} $\nAccuracy is the most intuitive performance measure and it is simply a ratio of correctly predicted observation to the total observations and it is a great measure only when you have symmetric datasets and  false positives and false negatives have similar cost. If the cost of false positives and false negatives are very different, we have to breakdown the accuracy formula even further and find a better evaluation metric.\n$ Precision  = \\frac{TP}{TP + FP}$\nHigh precision means less data is predicted positive and relates to high false negative and low false positive.\n$ Recall  = \\frac{TP}{TP + FN}$ (Sensitivity)\nHigh recall means more data is predicted positive and relates to high false positive and low false negative.\n$ F_1  = 2 * \\frac{Precision * Recall}{Precision + Recall} $\nF1 Score is the weighted average of precision and recall. Therefore, this score takes both false positives and false negatives into account. So we can evaluate the model based on  the F1 score.\n\n(from wikipedia)\nModel Selection\nTrain, Test and Validation Datasets\n\nTraining Dataset: The sample of data used to fit the parameters of model. (60%)\nValidation Dataset: The sample of data used to provide an unbiased evaluation of a model fit on the training dataset while tuning model hyperparameters. The evaluation becomes more biased as skill on the validation dataset is incorporated into the model configuration. (20%)\nTest Dataset: The sample of data that has not been used prior, either for training the model or tuning the model parameters and only used to provide an unbiased evaluation of the skill of the final tuned model when comparing or selecting between final models. (20%)\n\nLearning curve\nWhen we test our simple model on validation dataset, we can plot a learning curve with different hyperparameters to help us to gain guidance as to choose the right and effective solution to improve its performance.\nFor example: the size of training set.\n1) Experiencing high bias:\n\nLow training set size: causes $ J_ {train}(\\Theta)$ to be low and $ J_ {CV}(\\Theta)$ to be high.\nLarge training set size: causes both $ J_ {CV}(\\Theta)$ and $ J_ {train}(\\Theta)$ to be high with $ J_ {CV}(\\Theta) ≈ J_ {train}(\\Theta) $\nIf a learning algorithm is suffering from high bias, getting more training data will not help much.\n2) Experiencing high variance:\n\nLow training set size: $ J_ {train}(\\Theta)$ will be low and $ J_ {CV}(\\Theta)$ will be high.\nLarge training set size: $ J_ {train}(\\Theta)$ increases with training set size and $ J_ {CV}(\\Theta)$ continues to decrease without leveling off. Also,$ J_ {train}(\\Theta) &lt;  J_ {CV}(\\Theta)$ but the difference between them remains significant.\nIf a learning algorithm is suffering from high variance, getting more training data is likely to help.\nAfter ploting the learning curve, we can tune the model hyperparameters targetedly.\nFor example:\n\n\nGetting more training examples: Fixes high variance\n\n\nTrying smaller sets of features: Fixes high variance\n\n\nAdding features: Fixes high bias\n\n\nAdding polynomial features: Fixes high bias\n\n\nDecreasing λ: Fixes high bias\n\n\nIncreasing λ: Fixes high variance.\n\n\n","plink":"https://oreodu.github.io/2020/20200531-Model-Selection-and-Evaluation/"},{"title":"Neural Networks","date":"2020-05-16T07:45:00.000Z","date_formatted":{"ll":"May 16, 2020","L":"05/16/2020","MM-DD":"05-16"},"updated":"2020-10-03T18:15:23.838Z","content":"Neural Networks\nOverview\n(概略图)\n· materials:\n· Wikipedia\n· Machine Learning\nWhy Neural Networks?\n· Decision Boundary\nEvery Machine Learning algorithm learns the mapping from an input to output.\nIn the case of classification problems, a decision boundary helps us in determining whether a given data point belongs to a certain class. Traditional machine learning algoritms cannot learn decision boundaries for nonlinear data.  However, Neural Network is capable of learning any nonlinear function.\nAlso, those algorithms are not capable of learning all the functions.\n· Feature engineering\nIn machine learning, we have to do feature  extraction and feature selection before we train the model. Feature engineering is a key step in the model building process. However, in deep Learning, we can automate the process of feature engineering.\nFeed-Forward Neural network (Multilayer Perceptron)\n\nCost Function (regularized)\n· L = total number of layers in the network\n· $ s_l $ = number of units (not counting bias unit) in layer l\n· K = number of output units/classes\n$ J(\\Theta) = - \\frac{1}{m} \\sum_ {i=1}^m \\sum_ {k=1}^K \\left[y^{(i)}_ k \\log ((h_ \\Theta (x^{(i)}))_ k) + (1 - y^{(i)}_ k)\\log (1 - (h_ \\Theta(x^{(i)}))_ k)\\right] + \\frac{\\lambda}{2m}\\sum_ {l=1}^{L-1} \\sum_ {i=1}^{s_l} \\sum_ {j=1}^{s_ {l+1}} ( \\Theta_{j,i}^{(l)})^2 $\nBackpropagation Algorithm\n· Given training set $ { (x^{(1)}, y^{(1)}) … (x^{(m)}, y^{(m)})} $\n· Set $ \\Delta^{(l)}_{i,j} := 0$ for all (l,i,j)\n· For training example t =1 to m:\n​     1) $ a^{(1)} = x $\n​     2) Perform forward propagation to compute $a^{(l)}$ for l=2,3,…,L\n​           $ z^{(l)} = \\Theta^{(l-1)} a^{(l-1)} $\n​           $ a^{(l)} = g(z^{(l)}) $\n​     3) Using $y^{(t)}$, compute $\\delta^{(L)} = a^{(L)} - y^{(t)} $\n​     4) Compute $ \\delta^{(L-1)}, \\delta^{(L-2)},\\dots,\\delta^{(2)} $\nusing $\\delta^{(l)} = ((\\Theta^{(l)})^T \\delta^{(l+1)})  .* g^{′}(z^{(l)}) ),  ( g^{′}(z^{(l)})=a^{(l)} .* (1−a^{(l)}) ) $\n​     5) $\\Delta^{(l)}_ {i,j} := \\Delta^{(l)}_ {i,j} + a^{(l)}_ j \\delta^{(l+1)}_ j $ or with vectorization, $\\Delta^{(l)} := \\Delta^{(l)} + \\delta^{(l+1)} (a^{(l)})^T $\n​     Hence we update our new $\\Delta$ matrix. ($\\frac{∂J(\\Theta)}{∂\\Theta^{(l)}_ {i,j}} = D^{(l)}_ {i,j}$)\n​     $ D^{(l)}_ {i,j} =  \\frac{1}{m} \\Delta^{(l)}_ {i,j}, $ if j = 0\n​     $D^{(l)}_ {i,j} =  \\frac{1}{m}(\\Delta^{(l)}_ {i,j} + \\lambda \\Theta^{(l)}_ {i,j}),$ if j≠0\nIn the actual programming implementation, we can separate back propagation through layers.\nSee  more details\nGradient Checking\nGradient checking will assure that our backpropagation works as intended.\nWe can approximate the derivative of our cost function with: ($ ϵ =10^{−4} $)\n$ \\frac{∂J(\\Theta)}{∂\\Theta_ {j}} = \\frac{J(\\Theta_1 ,…, \\Theta_j + ϵ ,…, \\Theta_n) - J(\\Theta_1 ,…, \\Theta_j - ϵ ,…, \\Theta_n)}{2ϵ}  $\nActivation Function\nActivation functions introduce non-linearity to the model which allows it to learn complex functional mappings between the inputs and response variables. There are quite a few different activation functions like sigmoid, tanh, RelU, Leaky RelU, etc.\nSee  more details\nSigmoid Function:\n$ h_\\theta (x) = g(\\theta^T x) = \\dfrac{1}{1 + e^{- \\theta^T x}} $\nAvoid overflow:\n$  \\dfrac{1}{1 + e^{- \\theta^T x}} = \\frac{1}{2} (tan(\\frac{x}{2}) + 1)$\n$ tanx = \\frac{e^x - e^{-x}}{e^x + e^{-x}}  =  \\frac{e^{2x} - 1 }{e^{2x} + 1} = \\frac{1 - e^{-2x} }{1 + e^{-2x} }$\nReLU Function（Rectified Linear Unit）:\n$  h(x)= x ( x &gt; 0 )  or  0   ( x \\leq 0 )  $\nSoftmax Function:\n$ h(x)_ k = \\frac{exp(a_k)}{\\sum_ {i=1}^K exp(a_i)} $\nAvoid overflow: (c can be the - max(a))\n$ h(x)_ k = \\frac{exp(a_k + c)}{\\sum_ {i=1}^K exp(a_i + c)} $\nThe activation Function of the output layer depend on the specific problems.\nFor example: Binary classification — sigmoid function, Multiple Classification — softmax function, Regression — identity function\nOptimization Function\nSee  more details\nGradient Descent:\n$ \\Theta^{(l)}_ {i,j} = \\Theta^{(l)}_ {i,j} - \\eta \\frac{∂J(\\Theta)}{∂\\Theta^{(l)}_ {i,j}} $\nStandard Gradient descent updates the parameters only after each epoch.\nStochastic gradient descent updates the parameters for each observation which leads to more number of updates*.*\nMini-batch Gradient descent updates the parameters for a finite number of observations.\nMomentum-based Gradient Descent\n$ v^{(l)}_ {i,j}  =  \\alpha v^{(l)}_ {i,j}  - \\eta \\frac{∂J(\\Theta)}{∂\\Theta^{(l)}_ {i,j}} $\n$ \\Theta^{(l)}_ {i,j} = \\Theta^{(l)}_ {i,j} + v^{(l)}_ {i,j}  $\nMomentum-based gradient descent remembers the update $v$ at each iteration, and determines the next update as a linear combination of the gradient and the previous update. Unlike in stochastic gradient descent, it tends to keep traveling in the same direction, preventing oscillations.\n(Extension: Nesterov accelerated Gradient Descent)\nAdagrad\n$ h^{(l)}_ {i,j}  = h^{(l)}_ {i,j} +  ( \\frac{∂J(\\Theta)}{∂\\Theta^{(l)}_ {i,j}} )^2 $\n$ \\Theta^{(l)}_ {i,j} = \\Theta^{(l)}_ {i,j} + \\eta \\frac{1}{\\sqrt{h^{(l)}_ {i,j} } + \\epsilon}  \\frac{∂J(\\Theta)}{∂\\Theta^{(l)}_ {i,j}} $\nIt adopts the learning rate(η) based on the sparsity of features. So the parameters with small updates(sparse features) have high learning rate whereas the parameters with large  updates(dense features) have low learning rate. Therefore adagrad uses a different learning rate for each parameter.\n(Extension: RMSProp)\nAdam(Adaptive Moment Estimation)\nAdam algorithm introduces the concept of adaptive momentum along with adaptive learning rate. Adam is a combined form of Momentum-based GD and RMSProp.\n\nInitialize the weights\nSee  more details\nZero initialization and Random initialization\nIn general practice biases are initialized with 0 and weights are initialized with random numbers.\nUsually, we can not initialize weight with the same values, high values or very low values. Otherwize, weight uniformity will happen or the gradients may vanish or explode quickly.\nXavier initialization\nIt is mostly used for tanh() or sigmoid() activation function.\n\n\nHe initialization\nIt is mostly used for ReLU() activation function.\n\nBatch Normalization\nApart from the input layer, we can also normalize the hiden layer by adjusting and scaling the input. Batch normalization reduces the amount by what the hidden unit values shift around (covariance shift) and allows each layer of a network to learn by itself a little bit more independently of other layers. Also, it reduces overfitting because it has a slight regularization effects. Similar to dropout, it adds some noise to each hidden layer’s activations.\nSee  more details here and here\n\nDropout\nMore details from here.\nIn order to prevent over-fitting, we can use dropout to ignore units (i.e. neurons) during the training phase of certain set of neurons which is chosen at random so we can reduce interdependent learning amongst the neurons.\n\n(from the paper”Dropout: a simple way to prevent neural networks from overfitting”, JMLR 2014)\nMain Steps\nFirst, pick a network architecture.\n​    · Number of input units = dimension of features $x^{(i)}$\n​    · Number of output units = number of classes\n​    · Number of hidden units per layer = usually more the better (must balance with cost of computation as it increases with more hidden units)\nNext, training a Neural Network.\n​    · Randomly initialize the weights\n​    · Implement forward propagation to get $ h_\\Theta(x^{(i)}) $ for any $ x^{(i)} $\n​    · Implement the cost function\n​    · Implement backpropagation to compute partial derivatives\n​    · Use gradient checking to confirm that your backpropagation works. Then disable gradient checking.\n​    · Use gradient descent or a built-in optimization function to minimize the cost function with the weights in theta.\n","plink":"https://oreodu.github.io/2020/20200516-Neural-Networks/"},{"title":"Basis & Regression & Classification","date":"2020-05-01T07:45:00.000Z","date_formatted":{"ll":"May 1, 2020","L":"05/01/2020","MM-DD":"05-01"},"updated":"2020-10-03T18:15:18.345Z","content":"Basis &amp; Regression &amp; Classification\nOverview\n(概略图)\n· materials:\n· Wikipedia\n· Machine Learning\n1. Intro\nTom Mitchell provides a more modern definition: “A computer program is said to learn from experience E with respect to some class of tasks T and performance measure P, if its performance at tasks in T, as measured by P, improves with experience E.”\n· Supervised Learning\nIn supervised learning, we are given a data set and already know what our correct output should look like, having the idea that there is a relationship between the input and the output.\nSupervised learning problems are categorized into “regression” and **“classification” ** problems. In a regression problem, we are trying to predict results within a continuous output, meaning that we are trying to map input variables to some continuous function. In a classification problem, we are instead trying to predict results in a discrete output. In other words, we are trying to map input variables into discrete categories.\n· Unsupervised Learning\nUnsupervised learning allows us to approach problems with little or no idea what our results should look like. We can derive structure from data where we don’t necessarily know the effect of the variables.\nWe can derive this structure by clustering the data based on relationships among the variables in the data.\nWith unsupervised learning there is no feedback based on the prediction results.\n· Model\nTo describe the supervised learning problem slightly more formally, our goal is, given a training set, to learn the hypothesis function h : X → Y so that h(x) is a “good” predictor for the corresponding value of y.\nInout : X\nOutput: Y\nHypothesis function: h\nCost function : J\nObjective function: minimize (J)\n2. Regression\nLinear Regression\n$ h_\\theta (x) =  \\theta_1 x + \\theta_0 $\nCost Function\nWe can measure the accuracy of our hypothesis function by using a cost function.\nMean Squared Error\n$  J(\\theta_0, \\theta_1) =  \\frac{1}{2m} \\sum^{m}_ {i=1} {( h_ \\theta(x^{(i)}) - y^{(i)} )^2} $\n$ J(\\theta_0, \\theta_1) $ can be ploted by a contour figure.\nGradient descent (minizining the cost function J)\n$ \\theta_j := \\theta_j - \\alpha \\frac{1}{m} \\sum\\limits_{i=1}^{m} (h_\\theta(x^{(i)}) - y^{(i)}) \\cdot x_j^{(i)} $\n(Update $\\theta_j$ simultaneously)\nlearning rate: α\nwe should adjust our parameter α to ensure that the gradient descent algorithm converges in a reasonable time. Failure to converge or too much time to obtain the minimum value imply that our step size is wrong.\nThe method looks at every example in the entire training set on every step, and is called batch gradient descent\nWhy does gradient descent work?\nMultivariate Linear Regression\nLinear regression with multiple variables.\n$ h_\\theta (x) = \\theta_0 + \\theta_1 x_1 + \\theta_2 x_2 + \\theta_3 x_3 + \\cdots + \\theta_n x_n $\n$ h_\\theta(x) =\\begin{bmatrix}\\theta_0 \\hspace{2em} \\theta_1 \\hspace{2em} … \\hspace{2em} \\theta_n\\end{bmatrix}\\begin{bmatrix}x_0 \\newline x_1 \\newline \\vdots \\newline x_n\\end{bmatrix}= \\theta^T X $\n$ x_{0}^{(i)} =1 \\text{ for } (i\\in { 1,\\dots, m } ) $\n$  J(\\theta) =  \\frac{1}{2m} \\sum^{m}_ {i=1} {( h_ \\theta(x^{(i)}) - y^{(i)} )^2} $\nFeature Scaling\nWe can speed up gradient descent by having each of our input values in roughly the same range. This is because θ will descend quickly on small ranges and slowly on large ranges, and so will oscillate inefficiently down to the optimum when the variables are very uneven.\nTwo techniques to help with this are feature scaling and mean normalization.\nfeature scaling : $ x_i = \\frac{x_i}{s_i} $\nmean normalization : $ x_i = \\frac{x_i - \\mu_i}{s_i} $\n($ s_i $:  standard deviation , $ \\mu_i $: average)\nGradient descent\n$ \\theta_j := \\theta_j - \\alpha \\frac{1}{m} \\sum\\limits_{i=1}^{m} (h_\\theta(x^{(i)}) - y^{(i)}) \\cdot x_j^{(i)} $\nDebugging gradient descent.\nMake a plot with number of iterations and cost function J(θ).  It has been proven that if learning rate α is sufficiently small, then J(θ) will decrease on every iteration.\nIf α is too small: slow convergence.\nIf α is too large: may not decrease on every iteration and thus may not converge.\n(Try like this: … 0.001 … 0.01 … 0.1 … 1)\nNormal Equation\nNormal Equation is a second way of minimizing J.\nIn the “Normal Equation” method, we will minimize J by explicitly taking its derivatives with respect to the θj ’s, and setting them to zero. This allows us to find the optimum theta without iteration.\n$ \\theta =( X_T  X)^{-1}X_TY  $\n\n\nGradient Descent\nNormal Equation\n\n\n\n\nNeed to choose alpha\nNo need to choose alpha\n\n\nNeeds many iterations\nNo need to iterate\n\n\n$ O(kn^2)$\n$ O(n^3)$, need to calculate inverse of $ X^TX $\n\n\nWorks well when n is large\nSlow if n is very large\n\n\nIf $ X^TX $ is noninvertible, the common causes might be having :\n· Redundant features, where two features are very closely related (i.e. they are linearly dependent)\n· Too many features (e.g. m ≤ n). In this case, delete some features or use “regularization”.\nPolynomial Regression\nWe can change the behavior or curve of our hypothesis function by making it a quadratic, cubic or square root function (or any other form).\ne.g.  $ h_\\theta (x) = \\theta_0 + \\theta_1 x + \\theta_2 x^2 + \\theta_3 x^3 $\n( if you choose your features this way then feature scaling becomes very important. $ 10^3 = 1000 $)\nFeature choosing: We can combine multiple features into one.\n3. Classification(Logistic regression)\nBinary classification\nActiviation Fuction\nThe activation Function of the output layer depend on the specific problems.\nFor example: Binary classification — sigmoid function, Multiple Classification — softmax function, Regression — identity function\n· Sigmoid Function (maps any real number to the (0, 1) interval)\n$ h_\\theta (x) = g(\\theta^T x) = \\dfrac{1}{1 + e^{- \\theta^T x}} $\n$ h_\\theta(x) = P(y=1 | x ; \\theta) = 1 - P(y=0 | x ; \\theta) $\nDecision Boundary (The property of the Hypothesis function)\n$ h_\\theta(x) = g(\\theta^T x) \\geq 0.5     when \\theta^T x \\geq 0 $\nNon-linear decision boundary : $ \\theta^T x = \\theta_0 + \\theta_1 x + \\theta_2 x^2 + \\theta_3 x^3 $\nCost function\nWe cannot use the same cost function that we use for linear regression because the Logistic Function will not be a convex function, causing many local optima.\nCross Entropy Error\n$ J(\\theta) = \\dfrac{1}{m} \\sum_ {i=1}^m \\mathrm{Cost}(h_\\theta(x^{(i)}),y^{(i)}) $\n$ Cost (h_ \\theta(x^{(i)}),y^{(i)}) = -y^{(i)} \\log(h_ \\theta(x^{(i)}))  - (1- y^{(i)}) \\log(1-h_ \\theta(x^{(i)}))  $\n$ \\mathrm{Cost}(h_\\theta(x),y) = 0 \\text{ ,if } h_\\theta(x) = y $\n$ \\mathrm{Cost}(h_ \\theta(x),y) \\rightarrow \\infty \\text{ ,if } y=0 \\mathrm{and}  h_\\theta(x) \\rightarrow 1 $\n$ \\mathrm{Cost}(h_ \\theta(x),y) \\rightarrow \\infty \\text{ ,if } y=1  \\mathrm{and}  h_\\theta(x) \\rightarrow 0 $\nWhen $ h_ \\theta(x^{(i)}) $ become so small, the value of log will become negative infinity. So in order to avoid such situation, we can add a small value to the $ h_ \\theta(x^{(i)}) $, usually it can be 1e-7.\nGradient descent\n$ \\theta_j := \\theta_j - \\frac{\\alpha}{m} \\sum_{i=1}^m (h_\\theta(x^{(i)}) - y^{(i)}) x_j^{(i)} $\nAdvanced Optimization\n“Conjugate gradient”, “BFGS”, and “L-BFGS” are more sophisticated, faster ways to optimize θ and also no need to manually pick $ \\alpha $ which can be used instead of gradient descent.\nMultiple Classification\nOne-vs-all\n$ h_\\theta^{(i)}(x) = P(y = i | x ; \\theta)   y \\in \\lbrace0, 1 … n\\rbrace$\n$ \\mathrm{prediction} = \\max_i( h_\\theta ^{(i)}(x) ) $\n","plink":"https://oreodu.github.io/2020/20200501-Machine-Learning-Basis/"},{"title":"Linear List","date":"2020-04-25T07:45:00.000Z","date_formatted":{"ll":"Apr 25, 2020","L":"04/25/2020","MM-DD":"04-25"},"updated":"2020-11-24T08:48:41.819Z","content":"Linear List\nOverview\n(概略图)\nmaterials:\n· Wikipedia\n· CS61B Spring 2019 at UCB\n· Algorithms, Part I,Ⅱ by Princeton University\n· You can see the implementations of those linear list here.\nA list or sequence is an abstract data type that represents a countable number of ordered values, where the same value may occur more than once. Lists are typically implemented either as linked lists (either singly or doubly linked) or as arrays, static arrays or dynamic arrays(variable length).\nIf we limit the operations of sequence, then we can get stack or queue.\n\n\n\nLinked list\nArray\nDynamic array\n\n\n\n\nIndexing\nΘ(n)\nΘ(1)\nΘ(1)\n\n\nInsert/delete at beginning\nΘ(1)\nN/A\nΘ(n)\n\n\nInsert/delete at end\nΘ(1) (known); Θ(n) (unknown)\nN/A\nΘ(1) amortized\n\n\nInsert/delete in middle\nsearch time + Θ(1)\nN/A\nΘ(n)\n\n\nWasted space (average)\nΘ(n)\n0\nΘ(n)\n\n\nPart.1 Array\nArray consists of a linear collection of values or variables store in contiguous space that can be selected by one or more indices. Arrays are used to implement other data structures, such as lists, heaps, hash tables, deques, queues, stacks, strings, and VLists.\n\n123// Arrays in Java. Declaration, instantiation, assignmentint[] a = new int[]&#123;0,2,4,7,9&#125;char[] b = &#123;&#x27;a&#x27;,&#x27;b&#x27;,&#x27;f&#x27;&#125;\nThe array data type in java is static array. Static arrays have a size that is fixed when they are created and consequently do not allow elements to be inserted or removed. However, by allocating a new array and copying the contents of the old array to it, it is possible to effectively implement a dynamic version of an array.\n1234# Array in Python is list data type. List is mutable.list0 = list()list1 = [1,3,5,7,100]  list2 = [&#x27;Hello&#x27;]*3 \nEfficiency\nRandom access is available. However, modification(add or remove elements) with reallocation or reorganization of the entire structure have poor space and time complexity because the data items need not be stored contiguously in memory or on disk, while restructuring an array at run-time is a expensive operation.\nArrays take linear (O(n)) space in the number of elements n that they hold. Array-based implementations of other data structures are frequently simple and space-efficient, requiring little space overhead.\nIn an array with element size k and on a machine with a cache line size of B bytes, iterating through an array of n elements requires the minimum of ceiling(nk/B) cache misses, because its elements occupy contiguous memory locations. Arrays have better cache locality compared to linked lists.\n1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950public class AList&lt;T&gt; &#123;    private int size = 0;    private T[] items;    static final int REFACTOR = 2;    public AList() &#123;        items = (T[]) new Object[2];    &#125;    private void resize(int capacity) &#123;        T[] newArray = (T[]) new Object[capacity];        System.arraycopy(items, 0, newArray, 0, size);        items = newArray;    &#125;    public int size() &#123; return size;&#125;    public T get(int i) &#123;        return items[i];    &#125;    public void addLast(T x)&#123;        if (size == items.length) resize(size * REFACTOR);        items[size++] = x;    &#125;    public T removeLast() &#123;        if (size == 0) &#123;            System.out.println(&quot;The list is empty.&quot;);            return null;        &#125; else &#123;            double r = (double) size / items.length;            if (r &lt; 0.25) resize(items.length / 2);            T returnValue = items[size - 1];            // avoid loitering            items[--size] = null;            return returnValue;        &#125;    &#125;    public void printAList() &#123;        if (size == 0) System.out.println(&quot;The array is empty.&quot;);        System.out.print(&quot;[&quot;);        for (int i = 0; i&lt;size; i++) &#123;            System.out.print(items[i] + &quot;,&quot;);        &#125;        System.out.print(&quot;]&quot;);    &#125;&#125;\nSpecial Arrays\nDynamic arrays or growable arrays are similar to arrays but add the ability to insert and delete elements; adding and deleting at the end is particularly efficient. However, they reserve linear (Θ(n)) additional storage, whereas arrays do not reserve additional storage.\nAssociative arrays provide a mechanism for array-like functionality without huge storage overheads when the index values are sparse. Specialized associative arrays with integer keys include Patricia tries, Judy arrays, and van Emde Boas trees.\nPart.2 Linked List\nA linked list is a linear collection of nodes( data and reference) which together represent a sequence and whose order is not given by their physical placement in memory. Instead,  the reference of each node points to the next. They can be used to implement several other common abstract data types, including lists, stacks, queues, associative arrays, and S-expressions.\n\nEfficiency\nThis structure allows for efficient insertion or removal of elements from any position in the sequence during iteration. A drawback of linked lists is that access time is linear (and difficult to pipeline). Faster access, such as random access, is not feasible and reverse traversing is difficult because linked lists are inherently sequential access. Also\nLinked list are dynamic, so the length of list can increase or decrease as necessary. Each node does not necessarily follow the previous one physically in the memory. But they use more memory than arrays because of the storage used by their pointers.\nNodes are stored noncontiguously, greatly increasing the time periods required to access individual elements within the list, especially with a CPU cache.\nⅠ. Singly linked list\n\n1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768public class SLList&lt;T&gt; &#123;    private static class Node&lt;T&gt; &#123;        public T item;        public Node&lt;T&gt; next;        public Node(T i, Node&lt;T&gt; n) &#123;            item = i;            next = n;        &#125;    &#125;    // Invariant: Sentinel (be guaranteed to be true during code execution.)    private Node&lt;T&gt; sentinel;    // Cache: size (put aside data to speed up retrieval)    private int size = 0;    public SLList() &#123;        sentinel = new Node&lt;&gt;(null,null);    &#125;    public SLList(T x) &#123;        Node&lt;T&gt; first = new Node&lt;&gt;(x,null);        sentinel = new Node&lt;&gt;(null,first);        size++;    &#125;    private int size() &#123; return size; &#125;    public void addFirst(T x) &#123;        Node&lt;T&gt; n = new Node&lt;&gt;(x,sentinel.next);        sentinel.next = n;        size++;    &#125;    public T getFirst() &#123;        if(sentinel.next == null) return null;        return sentinel.next.item;    &#125;    public T removeFirst() &#123;        if(size == 0) &#123;            System.out.println(&quot;The List is empty&quot;);            return null;        &#125;else &#123;            Node&lt;T&gt; re = sentinel.next;            sentinel.next = sentinel.next.next;            size--;            return re.item;        &#125;    &#125;    public void addLast(T x) &#123;        Node&lt;T&gt; p = sentinel;        while(p.next != null) p = p.next;        p.next = new Node&lt;&gt;(x,null);        size++;    &#125;    public void printSLList() &#123;        Node&lt;T&gt; p = sentinel.next;        while(p!= null) &#123;            System.out.print(p.item + &quot;--&gt;&quot;);            p = p.next;        &#125;        System.out.println(&quot;End of the List.&quot;);    &#125;&#125;\nⅡ. Doubly Linked List\n\n1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192public class DLList&lt;T&gt; &#123;    private static class Node&lt;T&gt; &#123;        public T item;        public Node&lt;T&gt; next;        public Node&lt;T&gt; pre;        public Node(Node&lt;T&gt; pre, T item, Node&lt;T&gt; next) &#123;            this.item = item;            this.next = next;            this.pre = pre;        &#125;    &#125;    private int size= 0;    private Node&lt;T&gt; sentinel;    public DLList() &#123;        sentinel = new Node&lt;&gt;(null, null, null);        sentinel.pre = sentinel;        sentinel.next = sentinel;    &#125;    public DLList(T x) &#123;        sentinel = new Node&lt;&gt;(null,null,null);        Node&lt;T&gt; first = new Node&lt;&gt;(sentinel,x,sentinel);        sentinel.pre = first;        sentinel.next = first;        size++;    &#125;    public int size() &#123;        return size;    &#125;    public void addFirst(T x) &#123;        Node&lt;T&gt; n = new Node&lt;&gt;(sentinel, x, sentinel.next);        sentinel.next = n;        n.next.pre = n;        size++;    &#125;    public T getFirst() &#123;        return sentinel.next.item;    &#125;    public T removeFirst() &#123;        if (size == 0) &#123;            System.out.println(&quot;The list is empty.&quot;);            return null;        &#125;else &#123;            Node&lt;T&gt; re  = sentinel.next;            sentinel.next = sentinel.next.next;            re.next.pre = sentinel;            size--;            return re.item;        &#125;    &#125;    public T getLast() &#123;        return sentinel.pre.item;    &#125;    public void addLast(T x) &#123;        Node&lt;T&gt; n = new Node&lt;&gt;(sentinel.pre,x,sentinel);        sentinel.pre.next = n;        sentinel.pre = n;        size++;    &#125;    public T removeLast() &#123;        if(size == 0) &#123;            System.out.println(&quot;The list is empty&quot;);            return null;        &#125;else &#123;            Node&lt;T&gt; re = sentinel.pre;            sentinel.pre = re.pre;            re.pre.next = sentinel;            size--;            return re.item;        &#125;    &#125;    public void printDLList() &#123;        Node&lt;T&gt; p = sentinel.next;        while(p != sentinel) &#123;            System.out.print(p.item + &quot;-&gt;&quot;);            p = p.next;        &#125;        System.out.println(&quot;The end of the list&quot;);    &#125;&#125;\nⅢ. Two pointers  used  in the linked lists\n\nSame speed pointer\n\nProblem: Change the links in the list.\nUsually we use previous, current and next  to store the nodes avoiding losing the references and at the same time manipulation the nodes during the iteration.\nProblem: Find the nth last node from the singly linked list.\nWe can traverse the list at first to get the length of the list, then traverse the list again and count from 0 until it reach length - n.\nThe key of this problem is to get the length-n so that we can traverse the list only one time. One way to get the information during iteration is to set two pointers. We set both p and q pointer in the head. Firstly, q moves few steps to reach the nth node and p stay at the original place, then p and q move together until q reach the end of the list. Now p is pointing at the nth last node.\n\nSlow and fast pointer\n\nProblem: Discover the dichotomous point of the singly linked list.\nTraverse the linked list to get the length of the linked list, and then count to get the intermediate node.\nOr we can use two pointers(slow and fast). Both of which initially point to the head of the table. Slow moves forward one node at a time, fast moves forward two nodes at a time. When fast moves to the end of the linked list, slow points to the middle node of the linked list.\nProblem: Detect circle: How to check whether a singly linked list has a cycle? If there is a cycle, how to determine the starting point and length of the ring?\nStore the nodes that we have visited in a set. Once we found one node that is already in the set, it means that cycle exists in list and that position is the entrance of the cycle.\nOr we can use slow and fast pointers. See more details here.\nPart.3 Stack\nA stack is an abstract data type that serves as a collection of elements, with two main principal operations:\n\npush, which adds an element to the collection, and\npop, which removes the most recently added element that was not yet removed. LIFO (last in, first out)\n\n\n​                                                                                  (from here)\nⅠ.  SLListStack\nEvery operation takes constant time in the worst case but uses extra time and space to deal with the link.\n12345678910111213141516171819202122232425262728293031323334353637383940414243444546public class SLListStack&lt;T&gt; &#123;    private static class Node&lt;T&gt; &#123;        public T item;        public Node&lt;T&gt; next;        private Node&lt;T&gt; sentinel;        public Node(T item, Node&lt;T&gt; next) &#123;            this.item = item;            this.next = next;        &#125;    &#125;    private int size = 0;    private Node&lt;T&gt; sentinel;    public SLListStack() &#123;        sentinel = new Node&lt;&gt;(null,null);    &#125;    public boolean isEmpty() &#123;        return size == 0;    &#125;    public void push(T x) &#123;        Node&lt;T&gt; n = new Node&lt;&gt;(x,sentinel.next);        sentinel.next = n;        size++;    &#125;    public T pop() &#123;        if (size == 0) &#123;            System.out.println(&quot;There is no element in the stack&quot;);            return null;        &#125;else &#123;            Node&lt;T&gt; re = sentinel.next;            sentinel.next = re.next;            size--;            return re.item;        &#125;    &#125;    public int size() &#123;        return size;    &#125;&#125;\nⅡ. AListStack\nEvery operation takes constant amortized time but less wasted space.\t`\n123456789101112131415161718192021222324252627282930313233343536373839public class AListStack&lt;T&gt; &#123;    private int size = 0;    static final int REFACTOR = 2;    private T[] items;    public AListStack()&#123;        items =(T[]) new Object[10];    &#125;    private void resize(int capacity) &#123;        T[] n =(T[]) new Object[capacity];        System.arraycopy(items,0,n,0,size);        items = n;    &#125;    public boolean isEmpty() &#123;        return size == 0;    &#125;    public int size() &#123; return size;&#125;    public void push(T x)&#123;        if (items.length == size) resize(size*REFACTOR);        items[size++] = x;    &#125;    public T pop() &#123;        if (size == 0) &#123;            System.out.println(&quot;The stack is empty.&quot;);            return null;        &#125; else &#123;            double r = (double) size / items.length;            if (r &lt; 0.25) resize(items.length / 2);            T returnValue = items[size - 1];            items[--size] = null;            return returnValue;        &#125;    &#125;&#125;\nⅢ. Applications\n\nParsing in a computer.\nJava virtual machine.\nUndo  in a word processor.\nBack button in a web browser.\nImplementing function calls in  a compiler.\n\nFunction call: push local environment and return address.\nReturn: pop return address and local environment.\n\n\nArithmetic expression evaluation.\n\n12345678910111213141516171819202122public class EvaluationStack &#123;    public static void main(String[] args) &#123;        // Or we can use the java.util.Stack.        AListStack&lt;Integer&gt; numQueue = new AListStack&lt;&gt;();        AListStack&lt;Character&gt; opeQueue = new AListStack&lt;&gt;();        for (char c: args[0].toCharArray()) &#123;            if (c == &#x27;(&#x27;) continue;            else if (Character.isDigit(c)) numQueue.push(Character.getNumericValue(c));            else if (c == &#x27;*&#x27; || c == &#x27;+&#x27; || c == &#x27;/&#x27; || c == &#x27;-&#x27;) opeQueue.push(c);            else if (c == &#x27;)&#x27;) &#123;                char ope = opeQueue.pop();                int num0 = numQueue.pop();                int num1 = numQueue.pop();                if (ope == &#x27;*&#x27;) numQueue.push(num1 * num0);                else if (ope == &#x27;/&#x27;) numQueue.push(num1 / num0);                else if (ope == &#x27;+&#x27;) numQueue.push(num1 + num0);                else if (ope == &#x27;-&#x27;) numQueue.push(num1 - num0);            &#125;        &#125;        System.out.println(&quot;The result of the expression is: &quot; + numQueue.pop());    &#125;&#125;\nPart.4 Queue\nA queue is an abstract data type that serves as a collection of elements, with two main principal operations:\n\nenqueue, which adds an element to the collection, and\ndequeue, which removes the least recently added element that was not yet removed. FIFO (first in, first out)\n\n\nⅠ. DLListQueue\n1234567891011121314151617181920212223242526272829303132333435363738394041424344454647public class DLListQueue&lt;T&gt; &#123;    private static class Node&lt;T&gt;&#123;        public T item;        public Node&lt;T&gt; next;        public Node&lt;T&gt; pre;        public Node(Node&lt;T&gt; pre, T item, Node&lt;T&gt; next) &#123;            this.pre  = pre;            this.next = next;            this.item = item;        &#125;    &#125;    private int size = 0;    private Node&lt;T&gt; sentinel;    public DLListQueue() &#123;        sentinel = new Node&lt;&gt;(null, null, null);    &#125;    public int size() &#123;return size;&#125;    public boolean isEmpty() &#123;        return size == 0;    &#125;    public void enqueue(T x) &#123;        Node&lt;T&gt; n = new Node&lt;&gt;(sentinel, x, sentinel.next);        sentinel.next = n;        n.next.pre = n;        size++;    &#125;    public T dequeue() &#123;        if (size == 0) &#123;            System.out.println(&quot;The queue is empty!&quot;);            return null;        &#125;else &#123;            Node&lt;T&gt; returnValue = sentinel.pre;            returnValue.pre.next = sentinel;            sentinel.pre = returnValue.pre;            size--;            return returnValue.item;        &#125;    &#125;&#125;\nⅡ. AListQueue\n12345678910111213141516171819202122232425262728293031323334353637383940414243public class AListQueue&lt;T&gt; &#123;    private int head;    private int tail;    static final int REFACTOR = 2;    private T[] items;    public AListQueue() &#123;        items = (T[]) new Object[10];        head = 0;        tail = 0;    &#125;    private void resize(int capacity) &#123;        T[] n = (T[]) new Object[capacity];        int size = tail-head;        System.arraycopy(items,0,n,0,size);        items = n;        head = 0;        tail = size;    &#125;    public int size() &#123;return tail - head;&#125;    public boolean isEmpty() &#123;return tail == head;&#125;    public void enqueue(T x) &#123;        if (tail == items.length) resize((tail - head)*REFACTOR);        items[tail++] = x;    &#125;    public T dequeue() &#123;        if (tail == head) &#123;            System.out.println(&quot;The queue is empty.&quot;);            return null;        &#125; else &#123;            double r = (double) (tail - head) / items.length;            if (r &lt; 0.25) resize(items.length / 2);            T returnValue = items[tail];            items[tail++] = null;            return returnValue;        &#125;    &#125;&#125;\nPart.5 Java collections Library\njava.util.List : is API for an sequence of items.\njava.util.ArrayList : implements java.util.List and uses resizing array.\njava.util.LinkedList : implements java.util.List and uses linked list.\njava.util.Stack : extends java.util.Vector and implements java.util.List.\njava.util.Queue : An interface.\nSee more obout collections here.\n","plink":"https://oreodu.github.io/2020/20200425-Linear-List/"},{"title":"Sorting","date":"2020-01-02T01:29:25.000Z","date_formatted":{"ll":"Jan 2, 2020","L":"01/02/2020","MM-DD":"01-02"},"updated":"2020-12-11T05:58:14.057Z","content":"Sorting\nOverview\n(概略图)\n· materials:\n· Algorithms  by Dasgupta, C. H. Papadimitriou, U. V. Vazirani\n· Efficient Algorithms and Intractable Problems  (CS170 2018 Fall at UCB)\n· Algorithm Design by John Kleinberg, Eva Tardos\n· CS61B Spring 2019 at UCB\n· Algorithms, Part I,Ⅱ by Princeton University\n· Wikipedia\n· You can see the implementations of those sort algorithms here.\nMany sorting algorithms to choose from:\nInternal sorts.\n・Insertion sort, selection sort,  bubble sort,  shaker sort.\n・Quick sort,  merge sort,  heap sort,  samplesort, shellsort.\n・Solitaire sort, red-black sort, splaysort, Yaroslavskiy sort, psort, …\nExternal sorts.\nPoly-phase mergesort, cascade-merge, oscillating sort.\nString/radix sorts.\nDistribution, MSD, LSD, 3-way string quicksort.\nParallel sorts.\n・Bitonic sort, Batcher even-odd sort.\n・Smooth sort, cube sort, column sort.\n・GPUsort.\n\n\nName\nWorst\nAverage\nBest\nIn-place\nStability\n\n\n\n\nBubble Sort\n\n \\frac{N^2}{2} \n\n\n\n\n\n\n\n\n \n \n\n \n\n\n\n\n \\frac{N^2}{2} \n\n\n\n\n\n\n\n\n \n \n\n \n\n\n\n\n N \n\n\n\n\n \n\n\nIn-place\nStable\n\n\nSelection Sort\n\n \\frac{N^2}{2} \n\n\n\n\n\n\n\n\n \n \n\n \n\n\n\n\n \\frac{N^2}{2} \n\n\n\n\n\n\n\n\n \n \n\n \n\n\n\n\n \\frac{N^2}{2} \n\n\n\n\n\n\n\n\n \n \n\n \n\n\n\nIn-place\nNo\n\n\nInsertion Sort\n\n \\frac{N^2}{2} \n\n\n\n\n\n\n\n\n \n \n\n \n\n\n\n\n \\frac{N^2}{4} \n\n\n\n\n\n\n\n\n\n \n \n\n \n\n\n\n\n N \n\n\n\n\n \n\n\nIn-place\nStable\n\n\nShell Sort\ndepend on the increment sequence\n-\n\n N \n\n\n\n\n \n\n\nIn-place\nNo\n\n\nMerge Sort\n\n N lg N \n\n\n\n\n\n\n \n \n \n \n\n\n\n N lg N \n\n\n\n\n\n\n \n \n \n \n\n\n\n N lg N \n\n\n\n\n\n\n \n \n \n \n\n\nOut-place\nStable\n\n\nQuick Sort\n\n \\frac{N^2}{2} \n\n\n\n\n\n\n\n\n \n \n\n \n\n\n\n\n 2N lg N \n\n\n\n\n\n\n\n \n \n \n \n \n\n\n\n N lg N \n\n\n\n\n\n\n \n \n \n \n\n\nIn-place\nNo\n\n\n3-way quick\n\n \\frac{N^2}{2} \n\n\n\n\n\n\n\n\n \n \n\n \n\n\n\n\n 2N lg N \n\n\n\n\n\n\n\n \n \n \n \n \n\n\nN\nIn-place\nNo\n\n\nHeap Sort\n\n2NlgN\n\n\n\n\n\n\n\n \n \n \n \n \n\n\n\n2NlgN\n\n\n\n\n\n\n\n \n \n \n \n \n\n\n\nNlgN\n\n\n\n\n\n\n \n \n \n \n\n\nIn-place\nNo\n\n\nStability: long-distance exchange might move an item past some equal item.\nPart.1 Elementary Sort\nⅠ.  Selection Sort &amp;  Bubble Sort\nUnlike the basic sort method inserting elements into the sorted subarray, we can select the i-th largest element  and put the value into the a[i]. We can select the element from the front portion and put it in the back or  we can select the element from the back portion and put it in the front.\nThere are two ways to select element. The first method is bubble sort. It operates by repeatedly swapping the adjacent elements if they are in the wrong order which result in that the i-th largest element is moved to a[i].\n\n1234567private static void sort(int[] a) &#123;    int n = a.length;    for(int i = 0; i &lt; n - 1; i++) &#123;        for(int j = 0; j &lt; n-i-1; j++)            if (a[j] &gt; a[j+1]) exch(a, j, j+1);    &#125;&#125;\nThe second method called selection sort. It sorts an array by repeatedly finding the index min of smallest remaining element from the unsorted part and swap a[i] and a[min].\n\n12345678910private static void sort(int[] a) &#123;    int n = a.length;    int min;    for(int i = 0; i &lt; n - 1; i++) &#123;        min = i;        for(int j = i + 1; j &lt; n; j++)            if (a[j] &lt; a[min]) min = j;        exch(a, i, min);    &#125;&#125;\nSelection sort is more efficient and faster than the bubble sort because of less exchanges.\nⅡ.  Insertion Sort\nFind the proper position for a[i] in 0-th ~  (i-1)-th sorted subarray by swapping a[i] with each larger element to its left.\n\n123456789public static void sort(int[] a) &#123;    int N = a.length;    for(int i = 0; i &lt; N; i++) &#123;        for(int j = i; j &gt; 0; j--) &#123;            if (a[j] &lt; a[j-1]) exch(a, j, j-1);            else break;          &#125;    &#125;&#125;\nⅢ. Shell Sort\nShell Sort is mainly a variation of Insertion Sort. In insertion sort, we move elements only one position ahead. The idea of Shell Sort is to allow exchange of far items.\nIn Shell Sort, we make the array h-sorted for a large value of h. We keep reducing the value of h until it becomes 1. An array is said to be h-sorted if all sub-lists of every h-th element is sorted.\nAfter the previous h-sort, the array is partially sorted so the insertion will be fast (a g-sorted array remains g-sorted after h-sorting. See  the proof below or here).\n\nIncrement sequence that we can use:\nPower of two minus one: 1,3,7,…\n3x+1: 1,4,13,40,…\nSedgewick: 1,5,19,41,109,…\n12345678910private static void sort(int[] a) &#123;    int n = a.length;    // while (h &lt; n/3) h = h*3 + 1;    for (int h = n/3; h &gt;= 1; h = h/3 ) &#123;        for (int i = h; i &lt; n ; i++) &#123;            for (int j = i; j &gt;= h &amp;&amp; a[j] &lt; a[j-h]; j -= h)                exch(a,j,j-h);        &#125;    &#125;&#125;\nPart.2 Advanced Sort\nⅠ. Marge sort\nJava sort for objects.\nBasic idea:\ndivide array into two halves, recursively sort each half and merge two halves.\n\nRunning Time\nProposition: Merge sort uses at most \nNlgN\n\n\n\n\n\n\n \n \n \n \n\n compares and \n6NlgN\n\n\n\n\n\n\n\n \n \n \n \n \n\n array accesses to sort any array of size N.\n\n\n\n D(N) = 2D(\\frac{N}{2}) + N \n\n\n\n\n\n\n\n\n\n\n \n \n \n \n \n \n \n \n\n\n\n \n \n\n\n \n \n \n\n\n\n \\frac{D(N)}{N} = \\frac{D(\\frac{N}{2})}{\\frac{N}{2}} + 1 = \\frac{D(\\frac{N}{4})}{\\frac{N}{4}} + 1 + 1= ... = \\frac{D(\\frac{N}{N})}{\\frac{N}{N}} + 1...+ 1 = lg N\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n \n \n \n\n \n\n \n\n\n\n\n \n \n\n\n\n \n \n\n\n \n\n\n\n\n \n \n\n\n\n\n \n \n \n\n\n\n\n \n \n\n\n\n \n \n\n\n \n\n\n\n\n \n \n\n\n\n\n \n \n \n \n \n \n \n \n \n\n\n\n\n \n \n\n\n\n \n \n\n\n \n\n\n\n\n \n \n\n\n\n\n \n\n \n \n \n \n\n \n \n \n \n \n \n\n\nMemory\nProposition: Merge sort uses extra space proportional to N.\nA sorting algorithm is in-place if it uses &lt;= clogN extra memory. (Insertion sort, selection sort, shell sort) ---- In-place merge sort.\n123456789101112131415161718192021222324252627282930313233343536// divide and conquer prototype// Solve a problem by bividing it into two halves, sovling the two halves, // and then putting the solutions together to get the appropriate answer.public class Merge &#123;  private static void merge(Comparable[] a, Comparable[] aux, int lo, int mid, int hi) &#123;  \tassert isSorted(a, lo, mid);  \tassert isSorted(a, mid + 1, hi); \t // copy \t for (int k = 0; k &lt;= hi; k++) &#123;  \t  aux[k] = a[k];  \t&#125;  \t// merge \t int i = lo, j = mid + 1; \t for (int k = lo; k &lt;= hi; k++) &#123;  \t  if (i &gt; mid) a[k] = aux[j++];  \t  else if (j &gt; hi) a[k] = aux[i++];  \t  else if (less(aux[j], aux[i])) a[k] = aux[j++];  \t  else a[k] = aux[i++];  \t&#125; \t assert isSorted(a,lo,hi);\t&#125;    public static void sort(Comparable[] a, Comparable[] aux, int lo, int mid, int hi) &#123;    if (hi &lt;= lo) return;        int mid = (lo + hi) / 2;    sort(a, aux, lo, mid);    sort(a, aux, mid + 1, hi);    merge(a, aux, lo, mid, hi);  &#125;    public static void sort(Comparable[] a) &#123;    Comparable[] aux = new Comparable[a.length];    sort(a, aux, 0, a.length - 1);  &#125;&#125;\nImprovement\n\nBecause merge sort has too much overhead for tiny subarrays so we use insertion sort for small subarrays. Cutoff to insertion sort for ≈ 7items.\n\n1234567891011private static void sort(Comparable[] a, Comparable[] aux, int lo, int hi) &#123;  if (hi &lt;= lo) return;  if (hi &lt;= lo + CUTOFF -1) &#123;    Insertion.sort(a, lo, hi);    return;  &#125;  int mid = (lo + hi) / 2;  sort(a, aux, lo, mid);  sort(a, aux, mid + 1, hi);  merge(a, aux, lo, mid, hi);&#125;\n\nIf the biggest item in the first half &lt;= smallest item in the second half, we can just stop and move forward.\n\n123456789101112private static void sort(Comparable[] a, Comparable[] aux, int lo, int hi) &#123;  if (hi &lt;= lo) return;  if (hi &lt;= lo + CUTOFF -1) &#123;    Insertion.sort(a, lo, hi);    return;  &#125;  int mid = (lo + hi) / 2;  sort(a, aux, lo, mid);  sort(a, aux, mid + 1, hi);  if(!less(a[mid + 1],a[mid])) return;  merge(a, aux, lo, mid, hi);&#125;\n\nIn the previous code, we have to copy the merge part in the a[] into aux[] and then merge (copy the merge result from the aux[] to a[]). So in order to save time and eliminate the copy, we can switch the role of the input and auxiliary array in each recursive call.\n\n12345678910111213141516171819202122232425262728293031323334public class Merge &#123;  private static void merge(Comparable[] a, Comparable[] aux, int lo, int mid, int hi) &#123;    assert isSorted(a, lo, mid);  \tassert isSorted(a, mid + 1, hi);     \t \tint i = lo, j = mid + 1; \t \tfor (int k = lo; k &lt;= hi; k++) &#123;  \t  \tif (i &gt; mid) aux[k] = a[j++];  \t  \telse if (j &gt; hi) aux[k] = a[i++];  \t  \telse if (less(a[j], a[i])) aux[k] = a[j++];  \t \t \telse aux[k] = a[i++];  \t\t&#125; \t \tassert isSorted(a,lo,hi);\t&#125;  \tprivate static void sort(Comparable[] a, Comparable[] aux, int lo, int hi) &#123;  \tif (hi &lt;= lo) return;  \tif (hi &lt;= lo + CUTOFF -1) &#123;    \tInsertion.sort(a, lo, hi);   \t \treturn;  \t&#125;  \tint mid = (lo + hi) / 2; \t\tsort(aux, a, lo, mid);  \tsort(aux, a, mid + 1, hi);  \tif(!less(a[mid + 1],a[mid])) return;  \tmerge(a, aux, lo, mid, hi);\t&#125;      public static void sort(Comparable[] a) &#123;      Comparable[] aux = new Comparable[a.length];      for (int i = 0; i &lt; a.length; i++) aux[i] = a[i];    \tsort(a, aux, 0, a.length - 1);  &#125;&#125;\n\nBottom-up merge sort\n\nBasic idea: pass through array and merge the subarrays of size 2, 4, 8, 16 …\n\n1234567891011121314151617181920212223242526272829public class MergeBU &#123;  private static Comparable[] aux;    private static void merge(Comparable[] a, Comparable[] aux, int lo, int mid, int hi) &#123;  \tassert isSorted(a, lo, mid);  \tassert isSorted(a, mid + 1, hi); \t // copy \t for (int k = 0; k &lt;= hi; k++) &#123;  \t  aux[k] = a[k];  \t&#125;  \t// merge \t int i = lo, j = mid + 1; \t for (int k = lo; k &lt;= hi; k++) &#123;  \t  if (i &gt; mid) a[k] = aux[j++];  \t  else if (j &gt; hi) a[k] = aux[i++];  \t  else if (less(a[j], a[i])) a[k] = aux[j++];  \t  else a[k] = aux[i++];  \t&#125; \t assert isSorted(a,lo,hi);\t&#125;  \tpublic static void sort(Comparable[] a) &#123;    int N = a.length; \t\tComparable[] aux = new Comparable[N]; \t\tfor (int sz = 1; sz &lt; N; sz = sz + sz) \t\t\tfor (int lo = 0; lo &lt; N - sz; lo += sz + sz)        merge(a, aux, lo, lo + sz - 1, Math.min(lo + sz + sz - 1, N - 1));  &#125;&#125;\nⅡ.Quick Sort\nJava sort for primitive types.\nBasic idea:\n・Shuffle the array.\n・Partition so that, for some k . Entry k is in place, no larger element to the left of k, no smaller entry to the right of k.\n​    Repeat until i and j pointers cross.\n・Scan i from left to right so long as (a[i] &lt; a[lo]).\n・Scan j from right to left so long as (a[j] &gt; a[lo]).\n・Exchange a[i] with a[j]. (a[i] &gt;=  a[lo] and a[j] &lt;= a[lo])\n​    When pointers cross.\n・Exchange a[j] with a[lo].\n・Sort each piece recursively.\n\n\n1234567891011121314151617181920212223242526public class QuickSort &#123;  private static int partition(Comparable[] a, int lo, int hi) &#123;    int i = lo, j = hi + 1;    while(true) &#123;      while (less(a[++i], a[lo])) if (i == hi) break;      while (less(a[lo], a[--j])) if (j == lo) break;      if (i &gt;= j) break;      exch(a, i, j);    &#125;    exch(a, lo, j);    return j;  &#125;    public static void sort(Comparable[] a) &#123;    // shuffling is needed for performance guarantee    StdRandom.shuffle(a);    sort(a, 0 , a.length - 1);  &#125;    private static void sort(Comparable[] a, int lo, int hi) &#123;    if (hi &lt;= lo) return;    int j = partition(a, lo, hi);    sort(a, lo, j-1);    sort(a, j+1, hi);  &#125;&#125;\nAverage-case analysis\nProposition. The average number of compares \n C_N \n\n\n\n\n\n \n \n\n to quick sort an array of N distinct keys is ~ \n 2N lnN\n\n\n\n\n\n\n\n \n \n \n \n \n\n (and the number of exchanges is ~ ⅓ \n N ln N\n\n\n\n\n\n\n \n \n \n \n\n)\n\n C_N = (N + 1) + (\\frac{C_0 + C_{N-1}}{N}) + (\\frac{C_1 + C_{N-2}}{N}) + ... + (\\frac{C_{N-1} + C_{0}}{N})\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n \n \n \n \n \n \n \n \n \n\n\n\n\n \n \n \n\n \n\n \n \n \n\n\n\n \n\n\n \n \n \n\n\n\n\n \n \n \n\n \n\n \n \n \n\n\n\n \n\n\n \n \n \n \n \n \n \n\n\n\n\n \n\n \n \n \n\n \n\n \n \n\n\n \n\n\n \n\n\n\n \\frac{1}{N} \n\n\n\n\n\n\n\n \n \n\n\n is the partitioning probability. There are \n N + 1 \n\n\n\n\n\n\n \n \n \n\n compares during the partition. \n C_0 = C_1 = 0, N&gt;1 \n\n\n\n\n\n\n\n\n\n\n \n \n \n\n \n \n\n \n \n \n \n \n \n\n\n\n NC_N = N(N+1) + 2(C_0 + C_1 +...+ C_{N-1}) \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n\n \n \n\n \n \n \n \n \n \n \n \n \n \n\n \n \n\n \n\n \n \n\n \n \n \n \n \n\n \n\n \n \n \n\n\n \n\n\n\n (N-1)C_{N-1} = N(N-1) + 2(C_0 + C_1 +...+ C_{N-2}) \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n \n \n \n \n\n \n\n \n \n \n\n\n \n \n \n \n \n \n \n \n \n \n\n \n \n\n \n\n \n \n\n \n \n \n \n \n\n \n\n \n \n \n\n\n \n\n\nSubtract the above two equation:\n\n NC_N - (N-1)C_{N-1} = 2N + 2C_{N-1} \n\n\n\n\n\n\n\n\n\n\n\n\n \n\n \n \n\n \n \n \n \n \n \n\n \n\n \n \n \n\n\n \n \n \n \n \n\n \n\n \n \n \n\n\n\n\nRearrange terms and divide by \n N (N + 1)\n\n\n\n\n\n\n\n\n \n \n \n \n \n \n\n:\n\n \\frac{C_N}{N+1} = \\frac{C_{N-1}}{N} + \\frac{2}{N+1}  = \\frac{C_{N-2}}{N-1} + \\frac{2}{N} + \\frac{2}{N+1} = \\frac{2}{3} + \\frac{2}{4} + \\frac{2}{5} + ... + \\frac{2}{N + 1} \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n \n\n\n \n \n \n\n\n \n\n\n\n\n \n\n \n \n \n\n\n \n\n\n \n\n\n\n \n\n \n \n \n\n\n\n \n\n\n\n\n \n\n \n \n \n\n\n\n \n \n \n\n\n\n \n\n\n\n \n \n\n\n \n\n\n\n \n\n \n \n \n\n\n\n \n\n\n\n \n \n\n\n \n\n\n\n \n \n\n\n \n\n\n\n \n \n\n\n \n \n \n \n \n\n\n\n \n\n \n \n \n\n\n\n\n\n\n C_N = 2(N+1)(\\frac{1}{3} + \\frac{1}{4} + \\frac{1}{5} + ... + \\frac{1}{N+1}) \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n \n \n \n \n \n \n \n \n \n\n\n\n \n \n\n\n \n\n\n\n \n \n\n\n \n\n\n\n \n \n\n\n \n \n \n \n \n\n\n\n \n\n \n \n \n\n\n\n \n\n\n~ \n \\int^{N+1}_{3}{\\frac{1}{x}dx} \n\n\n\n\n\n\n\n\n\n\n \n\n \n \n \n\n \n\n\n\n \n \n\n \n \n\n\n   ~   \n 2(N+1)ln N  ≈ 1.39N lg N \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n \n \n \n \n \n \n \n \n \n\n \n \n \n \n\n \n \n \n \n\n\nSummary of performance characteristics\nWorst case. Number of compares is quadratic. \n N + (N-1) + (N-2) + ... + 1 \n\n\n\n\n\n\n\n\n\n\n\n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n\n ~ \n \\frac{1}{2}N^2 \n\n\n\n\n\n\n\n\n \n \n\n\n \n \n\n\n\nAverage case. Number of compares is ~ 1.39 N lg N. (Faster than merge sort because of less data movement)\nMemory. Quicksort is an in-place sorting algorithm\n· Partitioning: constant extra space.\n· Depth of recursion: logarithmic extra space (with high probability).\nQuick sort is not stable.\nPractical improvements\n\nLike merge sort, quick sort also has too much overhead for tiny subarrays so we can cutoff to insertion sort for ≈ 10 items.\n\n123456789private static void sort(Comparable[] a, int lo, int hi) &#123;  if (hi &lt;= lo + CUTOFF - 1) &#123;    Insertion.sort(a, lo, hi);    return;  &#125;  int j = partition(a, lo, hi);  sort(a, lo, j-1);  sort(a, j+1, hi);&#125;\n\nMedian of sample\n・Best choice of pivot item = median.\n・Estimate true median by taking median of sample(a[lo], a[mid], a[hi]).\n・Median of 3 random items.\nSee more details here.\n\n1234567891011121314151617private static int medianOf3(Comparable[] a, int lo, int mid, int hi) &#123;  if (less(a[hi],a[lo])) exch(a, lo, hi);  if (less(a[mid],a[lo])) exch(a, mid, lo);  if (less(a[hi],a[mid])) exch(a, mid, hi);  return mid;&#125;private static void sort(Comparable[] a, int lo, int hi) &#123;   if (hi &lt;= lo) return;      int m = medianOf3(a, lo, (lo + hi)/2, hi);   swap(a, lo, m);      int j = partition(a, lo, hi);   sort(a, lo, j-1);   sort(a, j+1, hi); &#125;\nQuick-Select\nGoal. Given an array of N items, find a kth smallest item.\nOnce we got the top k, then Min (k = 0), max (k = N - 1), median (k = N/ 2).\n1234567891011public static Comparable select(Comparable[] a, int k) &#123;  StdRandom.shuffle(a);  int lo = 0, hi = a.length - 1;  while (hi &gt; lo) &#123;    int j = partition(a, lo, hi);    if (j &lt; k) lo = j + 1;    else if (j &gt; k) hi = j - 1;    else return a[k];  &#125;  return a[k];&#125;\nQuick-select takes linear time on average.\nIntuitively, each partitioning step splits array approximately in half:\n\n N + \\frac{N}{2} + \\frac{N}{4} + ... + 1 \n\n\n\n\n\n\n\n\n\n \n \n\n\n\n \n \n\n\n \n\n\n\n \n \n\n\n \n \n \n \n \n \n\n ~ \n 2N \n\n\n\n\n\n \n \n\n compares.\nFormal analysis: \n C_N = 2N + 2k ln(\\frac{N}{k}) +2(N-k)ln(\\frac{N}{N-k}) \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n \n \n \n \n \n \n \n \n \n \n\n\n\n \n \n\n\n \n \n \n \n \n \n \n \n \n \n \n\n\n\n \n\n \n \n \n\n\n\n \n\n  (if k = \n \\frac{N}{2} \n\n\n\n\n\n\n\n \n \n\n\n , \n C_N = (2 + 2ln)N \n\n\n\n\n\n\n\n\n\n\n\n\n \n \n \n \n \n \n \n \n \n \n \n\n)\nQuick-select uses ~ \n \\frac{1}{2}N^2 \n\n\n\n\n\n\n\n\n \n \n\n\n \n \n\n\n compares in the worst case.\nDuplicate keys – Dijkstra 3-way\nGoal. Partition array into 3 parts so that:\n・Entries between lt and gt equal to partition item v.\n・No larger entries to left of lt.\n・No smaller entries to right of gt.\n\n・Let v be partitioning item a[lo].\n・Scan i from left to right.\n・(a[i] &lt; v): exchange a[lt] with a[i]; increment both lt and i .\n・(a[i] &gt; v): exchange a[gt] with a[i]; decrement gt .\n・(a[i] == v): increment i.\n\n1234567891011121314private static void sort(Comparable[] a, int lo, int hi) &#123;  if (hi &lt;= lo) return;  int lt = lo, gt = hi, i = lo;  Comparable v = a[lo];    while(i &lt;= gt) &#123;    int cmp = a[i].compareTo(v);    if (cmp &lt; 0) exch(a, lt++, i++);    else if (cmp &gt; 0) exch(a, i, gt--);    else i++;  &#125;  sort(a, lo, lt - 1);  sort(a, gt + 1, hi);&#125;\nSorting lower bound: If there are n distinct keys and the \ni^{th}\n\n\n\n\n\n\n \n\n \n \n\n\n one occurs \nx_i\n\n\n\n\n\n \n \n\n times, any compare-based sorting algorithm must use at least \n lg(\\frac{N!}{x_1! x_2!...x_n!}) \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n \n \n\n\n\n\n \n \n\n\n \n \n \n\n \n \n\n \n \n \n \n\n \n \n\n \n\n\n\n \n\n   ~  \n \\sum^{n}_{i = 1}{x_i lg\\frac{x_i}{N}} \n\n\n\n\n\n\n\n\n\n\n\n\n \n\n \n \n \n\n \n\n \n \n \n \n\n\n\n\n \n \n\n \n\n\n\n\n (\n NlgN \n\n\n\n\n\n\n \n \n \n \n\n when all distinct, linear when only a constant number of distinct keys) compares in the worst case.\nQuick sort with 3-way partitioning is entropy-optimal.  [Sedgewick-Bentley, 1997]\n(whatever the distribution of equal keys in there, this thing is going to use number of compares that’s proportional to the best that you could possibly do)\nⅢ. Heap Sort\nWe can see the implementations of binary heap and more details here. Based on the binary heap we can sort the array in an efficient way.\n**・**Create max-heap with all N keys.\n**・**Repeatedly remove the maximum key.\n\n12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849public class HeapSort &#123;    public static void sort(Comparable[] a) &#123;        int N = a.length;        for (int k = N / 2; k &gt; 1; k--) &#123;            sink(a, k , N);        &#125;        while(N &gt; 1) &#123;            exch(a, 1, N);            sink(a, 1, --N);        &#125;    &#125;    private static void sink(Comparable[] a, int k, int N) &#123;        while (2 * k &lt;= N) &#123;            int j = 2 * k;            if (j &lt; N &amp;&amp; less(a, j, j + 1)) j++;            if (!less(a, k, j)) break;            exch(a, k, j);            k = j;        &#125;    &#125;    // convert from 1-based indexing to 0-base indexing    private static void exch(Comparable[] a, int i, int j) &#123;        Comparable tmp = a[i - 1];        a[i - 1] = a[j - 1];        a[j - 1] = tmp;    &#125;    //  convert from 1-based indexing to 0-base indexing    private static boolean less(Comparable[] a, int i, int j) &#123;        return a[i - 1].compareTo(a[j - 1]) &lt; 0;    &#125;    private static void printArray(Comparable[] a) &#123;        System.out.print(&quot;[&quot;);        for (int i = 0; i &lt; a.length; i++) &#123;            System.out.print(a[i] + &quot; &quot;);        &#125;        System.out.print(&quot;]&quot;);    &#125;    public static void main(String[] args) &#123;        Comparable[] a = &#123;5,2,1,3,7,9&#125;;        sort(a);        printArray(a);    &#125;&#125;\nProposition.\nHeap construction uses ≤ 2 N compares and exchanges.\nHeap-sort uses ≤ 2 N lg N compares and exchanges.\nHeap-sort is an in-place sorting algorithm with \nNlogN\n\n\n\n\n\n\n\n \n \n \n \n \n\n worst-case so it is optimal both time and space, but its inner loop is longer than quick-sort’s and it makes poor use of cache memory. It is also not stable.\nⅣ.  Bucket sort\nⅤ. Radix sort\nPart.3 Sorting Complexity\n(Framework to study efficiency of algorithms for solving a particular problem X)\nModel of computation\n(allowable operations): Decision tree.\nProposition: Any compare-based sorting algorithm must use at least lg ( N ! ) ~ N lg N compares in the worst-case.\nAssume array consists of N distinct values \na_1\n\n\n\n\n\n \n \n\n through \na_N\n\n\n\n\n\n \n \n\n and there are N! different orderings. As for the worst case, there will be h(the height of the decision tree) compares.\nBinary tree of height h  ⇒ at most \n2^k\n\n\n\n\n\n \n \n\n leaves.\nN! Different orderings  ⇒ at least N! leaves.\n\n2^h ≥ leaves ≥ N! ⇒ h ≥ lg (N!) ~ NlgN (Stirling's approximation) \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n\n \n \n\n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n\n\n\nCost model (operation counts):\ncompares.\nUpper bound\n(Cost guarantee provided by some algorithm for X): ~ N lg N from merge sort.\nLower bound\n(Proven limit on cost guarantee of all algorithms for X): ~ N lg N\nLower bound may not hold if the algorithm has information about:\n・The initial order of the input.  (partially-ordered arrays)\n・The distribution of key values. (duplicate keys)\n・The representation of the keys.\n(Digital properties of keys:  We can use digit/character compares instead of key compares for numbers and strings.)\nOptimal algorithm\n(Algorithm with best possible cost guarantee for X): merge sort. (But it is not optimal with respect to space usage)\nPart.4 Sort in Java\nIf we want to sort any type of data,we can use interface to simplify the process.\nComparable interface\nSort using a type’s natural order.\n123456789101112131415161718192021222324252627282930313233343536// Comparable interface (Built in java)public interface Comparable&lt;Item&gt;&#123;    public int compareTo(Item i);&#125;// Object Implementationpublic class X implements Comparable&lt;X&gt; &#123;    //...    @Overide    private int compareTo(X x) &#123;        //...        return -1;        //...        return 1;        //...        return 0;    &#125;&#125;// Sort Implementaionpublic static void sort(Comparable[] x) &#123;  int N = x.length();  for(int i = 0; i&lt;N; i++) &#123;    for(int j = i; j&gt;0; j--) &#123;      if (x[j].compareTo(x[j-1])&lt;0) exch(x, j, j-1);      else break;     &#125;  &#125;&#125;// Clientpublic class XXXSorter&#123;    public static void main(String[] args) &#123;        X[] x = &#123;x1,x2,x3&#125;;        x.sort();    &#125;&#125;\nComparator interface\nSort using an alternate order. Required property: Must be a total order.\n123public interface Comparator&lt;Key&gt; &#123;  int compare(Key v, Key w);&#125;\n\nusing with our sorting libraries\n\n・Use Object instead of Comparable.\n・Pass Comparator to sort() and less() and use it in less().\n12345678910111213141516public static void sort(Object[] a, Comparator comparator) &#123; int N = a.length; for (int i = 0; i &lt; N; i++)   for (int j = i; j &gt; 0 &amp;&amp; less(comparator, a[j], a[j-1]); j--)     exch(a, j, j-1);&#125;private static boolean less(Comparator c, Object v, Object w) &#123;   return c.compare(v, w) &lt; 0; &#125;private static void exch(Object[] a, int i, int j) &#123;  Object swap = a[i];   a[i] = a[j];   a[j] = swap;&#125;\n\nsystem sort\n\n・Create Comparator object.\n・Pass as second argument to Arrays.sort().\nDecouples the definition of the data type from the definition of what it means to compare two objects of that type.\n1234567String[] a;// use natural orderArrays.sort(a);// Uses alternate order defined by Comparator&lt;String&gt; object.Arrays.sort(a, String.CASE_INSENSITIVE_ORDER);Arrays.sort(a, Collator.getInstance(new Locale(&quot;es&quot;)));Arrays.sort(a, new BritishPhoneBookOrder());\nTo implement a comparator:\n・Define a (nested) class that implements the Comparator interface.\n・Implement the compare() method.\n123456789101112131415161718public class Student &#123;  public static final Comparator&lt;Student&gt; BY_NAME = new ByName(); \tpublic static final Comparator&lt;Student&gt; BY_SECTION = new BySection(); \tprivate final String name; \tprivate final int section; /* ... */ \tprivate static class ByName implements Comparator&lt;Student&gt; &#123;    public int compare(Student v, Student w) &#123;      return v.name.compareTo(w.name);    &#125;  &#125;   \tprivate static class BySection implements Comparator&lt;Student&gt; &#123;   \tpublic int compare(Student v, Student w) &#123;      \treturn v.section - w.section;   \t&#125; \t&#125;&#125;\n123456789101112131415161718192021222324252627// polar orderpublic class Point2D &#123;  public final Comparator&lt;Point2D&gt; POLAR_ORDER = new PolarOrder(); \tprivate final double x, y;  /* ... */ \tprivate static int ccw(Point2D a, Point2D b, Point2D c) &#123;    double area2 = (b.x-a.x)*(c.y-a.y) - (b.y-a.y)*(c.x-a.x);    if (area2 &lt; 0) return -1; // clockwise    else if (area2 &gt; 0) return +1; // counter-clockwise    else return 0; // collinear  &#125;   \tprivate class PolarOrder implements Comparator&lt;Point2D&gt; &#123;    public int compare(Point2D q1, Point2D q2) &#123;      double dy1 = q1.y - y; \t\t\tdouble dy2 = q2.y - y;      // p, q1, q2 are horizontal \t\t\tif (dy1 == 0 &amp;&amp; dy2 == 0) &#123; /*...*/ &#125;      // q1 above, q2 below \t\t\telse if (dy1 &gt;= 0 &amp;&amp; dy2 &lt; 0) return -1;      // q2 above, q1 below \t\t\telse if (dy2 &gt;= 0 &amp;&amp; dy1 &lt; 0) return +1;      // both above or below \t\t\telse return -ccw(Point2D.this, q1, q2);    &#125;  &#125;&#125;\n12345678910111213141516171819202122232425262728293031323334353637// slope orderpublic class Point implements Comparable&lt;Point&gt; &#123;    private final int x;     // x-coordinate of this point    private final int y;     // y-coordinate of this point    public Point(int x, int y) &#123;        this.x = x;        this.y = y;    &#125;      public double slopeTo(Point that) &#123;        int x0 = this.x, y0 = this.y;        int x1 = that.x, y1 = that.y;        if (x0 == x1) &#123;            if (y0 == y1) return Double.NEGATIVE_INFINITY;            else return Double.POSITIVE_INFINITY;        &#125;else if (y0 == y1) return +0.0;        else &#123;            return 1.0 * (y1 - y0) / (x1 - x0);        &#125;    &#125;    public Comparator&lt;Point&gt; slopeOrder() &#123;        return new BySlopeOrder();    &#125;    private class BySlopeOrder implements Comparator&lt;Point&gt; &#123;        public int compare(Point a, Point b) &#123;            double aSlope = slopeTo(a);            double bSlope = slopeTo(b);            if (aSlope &gt; bSlope) return 1;            else if (aSlope &lt; bSlope) return -1;            else return 0;        &#125;    &#125;&#125;\nSystem sorts\nArrays.sort()\nHas different method for each primitive type and datatypes that implement Comparable.\nUses tuned quick sort for primitive types and tuned merge sort for objects.\nengineering a system sort\nBasic algorithm = quicksort.\n・Cutoff to insertion sort for small subarrays.\n・Partitioning scheme: Bentley-McIlroy 3-way partitioning.\n・Partitioning item.\n– small arrays: middle entry\n– medium arrays: median of 3\n– large arrays: Tukey’s ninther\nTukey’s ninther :\nMedian of the median of 3 samples, each of 3 entries.\n・Approximates the median of 9.\n・Uses at most 12 compares.\nBetter partitioning than random shuffle and less costly.\n\nPart.5 Applications\nSorting algorithms are essential in a broad variety of applications:\n(obvious applications)\n・Sort a list of names.\n・Organize an MP3 library.\n・Display Google PageRank results.\n・List RSS feed in reverse chronological order.\n(problems become easy once items are in sorted order)\n・Find the median.\n・Identify statistical outliers.\n・Binary search in a database.\n・Find duplicates in a mailing list.\n(non-obvious applications)\n・Data compression.\n・Computer graphics.\n・Computational biology.\n・Load balancing on a parallel computer.\n. . .\nⅠ. Shuffle\nGoal: rearrange array so that result is uniformly random permutation.\n\nGenerate a random real number (uniformly at random) for each array entry and sort the array based on it.\nKnuth Shuffle: In iteration i, pick integer r between 0 and i uniformly at random and swap a[i] and a[r].\n\nⅡ. Convex hull\nConvex hull: a set of N points which is the smallest perimeter fence enclosing the points.\nOutput: Sequence of vertices in counterclockwise order.\n\nGeometric properties:\n\n\nCan traverse the convex hull by making only counterclockwise turns\nThe vertices of convex hull appear in increasing order of polar angle with respect to point p with lowest y-coordinate.\n\nGraham scan:\n\nChoose point p with smallest y-coordinate.\nSort points by polar angle with p.\nConsider points in order; discard unless it create a counterclockwise turn.\n\nImplement of determine whether it’s a counterclockwise turn:\n\n 2 x Area(a,b,c) = (b_x - a_x)(c_y - a_y) - (b_y -  a_y)(c_x - a_x) \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n\n \n \n\n \n\n \n \n\n \n \n\n \n \n\n \n\n \n \n\n \n \n \n\n \n \n\n \n\n \n \n\n \n \n\n \n \n\n \n\n \n \n\n \n\n\n(Based on: the area of a parallelogram is equal to the cross product of two vectors)\n(v1: (\nb_x - a_x\n\n\n\n\n\n\n\n \n \n \n\n \n \n\n\n, \nb_y -  a_y\n\n\n\n\n\n\n\n \n \n \n\n \n \n\n\n), v2:(\nc_x - a_x\n\n\n\n\n\n\n\n \n \n \n\n \n \n\n\n,\nc_y - a_y\n\n\n\n\n\n\n\n \n \n \n\n \n \n\n\n))\n\nSee more here.\nApplication:\n\nRobot motion planning.\nFind shortest path in the plane from s to t that avoids a polygonal obstacle.\nShortest path is either straight line from s to t or it is one of two polygonal chains of convex hull.\nFarthest pair problem\nGiven N points in the plane, find a pair of points with the largest Euclidean distance between them.\nFarthest pair of points are extreme points on convex hull.\n\n","plink":"https://oreodu.github.io/2020/20200102-Sorting/"},{"title":"Algorithm Basics","date":"2019-10-13T04:43:00.000Z","date_formatted":{"ll":"Oct 13, 2019","L":"10/13/2019","MM-DD":"10-13"},"updated":"2020-11-23T12:13:33.308Z","content":"Algorithm Basics\nOverview\n(概略图)\n· materials:\n· Algorithms  by Dasgupta, C. H. Papadimitriou, U. V. Vazirani\n· Efficient Algorithms and Intractable Problems  (CS170 2018 Fall at UCB)\n· Algorithm Design by John Kleinberg, Eva Tardos\n· Algorithms, Part I,Ⅱ by Princeton University\n· Wikipedia\nPart.1 What is Algorithm?\nThe program is designed to solve certain problems and it mainly contains algorithms and data structures.\n\nAn algorithm is a sequence of instructions. (from Algorithm Wikipedia)\n\nAs usual, the algorithm use control structures (sequential, conditional, recurrent) and operators to make the instructions. A effective algorithms must have several characteristics as follows:\n1.Correctness: For each legal input, the algorithms must produce the expected output after a few precise and feasible instructions. (End within finite time.)\n2.Robustness: The algorithms must can apply in all possible circumstances that could arise and have the ability of tolerating perturbations and unexcepted exceptions.\n3.High efficiency and low storage requirement\nPart.2 How to design a proper algorithm?\nTypical steps in the development of algorithms:\n1.Problem definition\n2.Development of a model\n3.Specification of the algorithm\n4.Designing an algorithm\n5.Checking the correctness of the algorithm\n6.Analysis of algorithm\n7.Implementation of algorithm\n8.Program testing\n9.Documentation preparation\n(from Algorithm Wikipedia)\nWhen we finished design the algorithm, we should keep asking ourselves three questions as follows in order to make it more efficient.\n\n1.Is it correct (produce the expected output) ?  (Check)\n2.How much time and storage does it take?  (Analyze)\n3.Can we do better (higher efficiency and lower storage) ?  (optimize)\n(from Algorithms  by Dasgupta, C. H. Papadimitriou, U. V. Vazirani)\n\nPart.3 Classification\nThere are various ways to classify algorithms.\nBy design paradigm:\n· Brute-force or exhaustive search (try every possible solution)\n· Search and enumeration\n· Back tracking\n· Divide and conquer (repeatedly reduces an instance of a problem to one or more smaller instances  until the instances are small enough to solve easily)\n· Randomized algorithm (make some choices randomly (or pseudo-randomly))\n· Reduction of complexity (transform the difficult problem into a better-known problem that we have asymptotically optimal algorithms.)\nBy implementation:\n· Recursion ( invokes itself repeatedly)\n· Logical (logic + control)\n· Serial (execute one algorithm at a time), parallel or distributed (several processors work on a problem at the same time)\n· Deterministic (exact decision at every step of the algorithm) or non-deterministic (guess through the use of heuristics)\n· Exact (reach an exact solution) or approximate (closer to the true solution)\n· Quantum algorithm\nOptimization problems\n· Linear programming (the constraints of the problem can be used directly in producing the optimal solutions.)\n· Dynamic programming (the optimal solution to a problem can be constructed from optimal solutions to subproblems and overlapping subproblems)\n· The greedy method (start with some given or modified solutions)\n· The heuristic method (find a solution close to the optimal solution)\nPart.4 How to analyze an algorithm?\nIt is frequently important to know how much of a particular resource (such as time or storage) is theoretically required for a given algorithm.  (from Algorithm Wikipedia). By analyzing the time complexity and space complexity we are able to improve the algorithm in a clearer direction.\nⅠ. Time complexity\nIn theory, we quantify the time through counting the number of elementary operations performed by the algorithm and multiply it by the time spent on each operation, where an elementary operation takes a fixed amount of time. Thus the amount of time taken by the same algorithm differ by a constant factor which is depended on the performance of different computers.\nIn most cases, in order to analyze the algorithms in a more efficient way we should simplify the way we estimate the time complexity. Because only the number of the operations depends on algorithms and input data, so we can ignore the constant time spent on each elementary operation and express the running time by counting the number of the operations, as a function of the size of the input. Further, as the input size goes to infinity, we can use the basic operation as a proxy for the running time and ignore the lower order terms.\nSo it is commonly expressed using the asymptotic notation, which lets us only focus on the big pictures. Asymptotic notation characterizes functions according to their growth rates: different functions with the same growth rate may be represented using the same notation.\nSince an algorithm’s performance time may vary with different inputs of  the same size, we commonly use the worst-case time complexity, denoted as $T(n)$, which is defined as the maximum amount of time taken on any input of size n.\nAsymptotic notation:\nLet f(n) and g(n) be functions from positive integers to positive reals and think of them as the running time of two algorithms on inputs of size n.\n1.$ f = O(g) $, if there is a constant $ c&gt;0 $ and $ n_0 $, such that $ |f(n)| \\leq c · g(n) $ for all $n&gt;n_0$\nBig O notation provides an upper bound on the growth rate of the function.  f grows no faster than g.\n2.$ g = Ω(f) $ ( f grows no faster than g ) if there is a constant $c &gt; 0$, such that $g(n) \\geq c · f(n)$\n3.$f = Θ(g)$( g grows the same as f ) if there is a constant $c &gt; 0$, such that $g(n) = c · f(n)$\nIf the function f can be written as a finite sum of other functions, then the fastest growing one determines the order of $f(n)$. Here are some rules that can simplify f to O(g) by omitting coefficients and lower order terms.\n· Multiplicative constants can be omitted.\n· log a dominates log b, $n^a$ dominates $n^b$ and $a^n$ dominates $b^n$ if $a&gt;b$\n· Any exponential dominates any polynomial\n· Any polynomial dominates any logarithm\n· $f_1= O(g_1)$ and $f_2 = O(g_2)$, $f_1· f_2 = O(g_1· g_2))$\n· $f_1 = O(g_1)$ and $f_2 = O(g_2)$, $f_1 + f_2 = O(max(g_1, g_2))$\n· Orders of common functions:\n$O(1)$, $O(\\log(\\log(n)))$, $O(\\log(n))$, $O((\\log(n))^c)  (c&gt;1)$,\n$O(n^c)  (0&lt;c&lt;1)$, $O(n)$, $O(n\\log (n)) = O(\\log(n!))$,\n$O(n^2)$, $O(n^c)$, $O(c^n)  (c&gt;1)$, $O(n!)$\n\nUpper bound: a specific algorithms.\nLower bound: proof that no algorithm can do better.\nOptimal algorithm: Lower bound equals upper bound to within a constant factor.\nWhen we design an algorithm,we usually focus on lower the upper bound(discover a new algorithm) and raise the lower bound.\nⅡ. Space complexity\nThe space complexity of an algorithm is the amount of the memory required by an algorithm to execute a program and produce output as a function of the size of the input. Similar to time complexity, Space complexity is often expressed asymptotically. such as $O(1)$,$O(n)$, $O(n\\log(n))$, $O(n^\\alpha)$, $O(2^n)$, etc., where n is the input size in units of bits needed to represent the input.\nPart.5 Computational Theory\n","plink":"https://oreodu.github.io/2019/20191013-Algorithm-Basics/"},{"title":"Python Basics 01","date":"2019-10-09T23:07:00.000Z","date_formatted":{"ll":"Oct 10, 2019","L":"10/10/2019","MM-DD":"10-10"},"updated":"2020-10-05T03:07:48.331Z","content":"Python Basics 01\nOverview\nProgramming is a method that we use computers to do the complicated calculations and repetitive tasks which human are not very good at in order to solve the difficult problem.\n\nPython is a high-level language intended to be relatively straightforward for humans to read and write and for computers to read and process.  (from Python for Everybody)\n\n\n· materials:\n· Python for Everybody (Exploring Data Using Python 3)  by Charles R. Severance\n· Learn Python 3 the Hard Way by Zed A. Shaw\n· Python-100-Days by jackfrued\n· Python Tutorial\n· Google Python Style Guide\nPart.1 Installing Python 3 On Windows 10\nDownload and install Python 3.x.x from here. (When you’re installing Python you should make sure that you have chosen “Add Python 3.x.x  to PATH” or you can do this by yourself later.)\nDownload and install the text editor. (I installed Atom.)\nTwo ways that you run your code：\n· Write the script  in the text editor and execute it in the command window or type commands into the Python interpreter.\n  1python xxx.py arg1 arg2 arg3\n· Write and run the code in a interactive programming tool (such as IPython).\nPart.2 How do the programs work inside the computer?\nFirst, let’s have a quick look at the simplified computer structure.\n\n(from Python for Everybody)\nWhen we finish our code and store it in the secondary memory, the Python interpreter(CPython、IPython、Jython、PyPy ) will parses the source code and interprets the instructions and the complier will translate the high-level source code into machine language and put the resulting machine language into a file for later execution.\nThen when we execute the program, it will be stored in the main memory temporarily. The computer will retrieve the data form the input devices or the network, get the instructions form the main memory and do the computations in the center processing unit(CPU) with a high speed(billion times per second). In the end, the computer will send the results to the output devices.\nPart.3 Language element\nA language must have its own vocabulary and grammar. In the vocabulary of Python, basically, we have Reserved words (keywords), variable, constant and operators.\nⅠ. Reserved words (keywords):\nSpecial identifiers with specific meanings and functions in python that can’t be used by programmer.\n\n(from Python for Everybody)\nⅡ. Variable:\nIn python, variables don’t have types(only the objects have types) and they are all bind a reference of an object (a pointer) to the variable names. The size of the pointer’s memory space has nothing to do with the type, and its memory space just saves the memory address of the pointed data. You can use id() to view the address value of the current variable.\n· Types  :\n\nnumbers:\n\ninteger (can use different radixes: 0b100,0o100,100,0x100)\nfloat (sometimes use scientific notation: 1.234e2)\ncomplex number (ex: 3+2j)\n\n\nBoolean: True, False\nText Sequence: string (be enclosed in single or double quotation marks)\nBuilt-in data structures: list, tuple, set, dictionary\n\n· Immutable and mutable\n1.Immutable objects: numbers, bool, strings, tuples. (value type)\nThe value at the address referenced by the variable cannot be changed. The re-assignment of a variable which point to an immutable object is equivalent to creating a new object in memory instead of the previous object. The advantage of the immutable data type is that no matter how many references there are in the memory, the same object only occupies a piece of memory and all the references will point to it.\n2.Mutable objects: list, set, dictionary. (reference type)\nWhen operating on mutable objects, their values are mutable and the change of the value will not create  new objects, that is, the address will not change, but the content in the address has changed or the address has been expanded. Different from immutable objects, for mutable objects, multiple objects with the same value are stored in memory with different address values.\nWe can use type() function to get the type of the variables.\n12a = 1.234e6print(type(a)) #&lt;class &#x27;float&#x27;&gt;\nThe type of the objects can be converted using functions built in Python.\n\n\n· int(): Convert a number or string to an integer and specify a radix.\n\n\n· float(): Convert a number or strings to a floating point number.\n\n\n· str(): Convert the specified object to a string and specifies the encoding.\n\n\n· chr(): Convert the corresponding encoding (integer) to the string (a character).\n\n\n· ord(): Convert a string (a character) to the corresponding encoding (integer).\n\n\n·  …\n\n\n· Name rules : (usually use a mnemonic name)\n1.Combination of numbers, letters, underscore (can not start with a number)\n2.Case sensitive\n3.Can not use reserved words\n4.PEP 8 ( Style Guide for Python Code )\n· How do we use variables?\n1.Use variables to save data and perform arithmetic operations\n12345678a = 1.234b = 2.345print(a+b) # 3.579fruit = &#x27;banana&#x27;letter = fruit[1] # extracts the character at index position 1 from the fruit variableletter1 = fruit[-1]print(letter,letter1) # r t\n2.The use of backslash \\\nWe can use \\ in a string to indicate escaping, which means that the character after \\ is no longer its original meaning.\n\\n means a new line\n\\t means tab\n\\141(octal) or \\x61(hexadecimal )  means  lowercase letter a\n\\u9a86(Unicode ) means ‘骆’ in Chinese\nIf we do not want to escape characters after the \\ or you want to print \\ , you can use r before the string.\n123s1 =  r&#x27; \\&#x27; hello, world! \\&#x27; &#x27;  # print: \\&#x27; hello, world! \\&#x27;s2 = &#x27; \\&#x27;hello, world!\\\\ \\n &#x27; # print: &#x27;hello, world!\\print (s1, s2, end = &#x27; &#x27; )\n3.The object string has some built-in methods to process itself.\nWe can use dir function to show the available methods. (more methods)\n1234567891011121314151617181920212223242526272829303132333435str1 = &#x27;hello,World!&#x27; # calculate the lengthprint (len (str1)) # 13# obtain capitalized string copy print (str1.capitalize ()) #Hello, world! # obtain the first character of each word capitalized copy print (str1.title()) # Hello, World! # obtain an each character capitalized copy  print (str1.upper ()) # HELLO, WORLD! #replace the specific substring with another oneprint(str1.replace(&#x27;o&#x27;,&#x27;e&#x27;)) # helle,werld#Find the location of the substringprint (str1.find(&#x27;o&#x27;,5 )) # 7 print (str1.find(&#x27;shit &#x27;)) # -1 # check whether the string starts with the specified stringprint (str1.startswith (&#x27;He&#x27;)) # False # checks whether the string ends with the specified string print (str1.endswith (&#x27;!&#x27;)) # True # Center the string at the specified width and fill with the specified characters print(str1.center( 50 ,&#x27;*&#x27; ))print (str1.rjust( 50 ,&#x27; &#x27;))str2 =  &#x27; abc123456 &#x27; # check whether the character string configured by numbersprint (str2.isdigit())   # False # check whether the character string configured by lettersprint (str2.isalpha())   # False # check whether the character string configured by numbers and lettersprint (str2.isalnum())   # True #print without space print (str2.strip())print(str1.translate(str1.maketrans(&#x27;,!&#x27;,&#x27;  &#x27;))) # hello World \nⅢ. Operators:\nThe values the operators is applied to are called operands and an expression is a combination of operands and operators.\n· For number and Boolean\n\n\nOperator\ndescription\n\n\n\n\n+ -\nunary plus and minus\n\n\n** * / % // + -\npower, multiply, division, mold, integer division(round down), add, subtract,\n\n\n&gt;&gt; &lt;&lt;\nshift right, left shift\n\n\n~ &amp;  ^\nbitwise negation, bitwise and, bitwise XOR\n\n\n&lt;= &lt; &gt; &gt;=\nLess than or equal to, less than, greater than, greater than or equal to\n\n\n== !=\nEqual to, not equal to\n\n\n= %= /= //= *=\n**= += -= &amp;= ^= &gt;&gt;= &lt;&lt;=\n\n\n:=\nwalrus operator\n\n\nis is not\nIdentity operator\n\n\nin not in\nMember operator\n\n\nnot or and\nLogical Operators\n\n\n1.The priority of the operators:\n**, ~ + -, * / % //, + -, &gt;&gt; &lt;&lt;, &amp;, ^ |, &lt;= &lt; &gt; &gt;=, == !=, = %= /= //= -= += *= **=\nParentheses () have the highest precedence and can be used to force an expression to evaluate in the order we want.\n1234a = 10b = 3a *= b + 2 # equivalent to: a=a*(b+2)=50print(a)\n12345flag1 = 3 &lt; 2flag2 = 2 != 1flag3 = flag1 and flag2print(flag3 is not False) #Falseprint(flag2 is True) #True\n2.Short-circuit evaluation of logical expressions:\nThe evaluation stops when the overall value is already know. y!=0 acts as a guard to insure that we only execute (x/y) if y is non-zero.\n1x &gt;= 2 and y!= 0 and (x/y) &gt; 2\n3.Built-in functions\nadd(num1,num2); max(num1,num2); abs(num)…\nEvaluate the operator subexpression, evaluate each operand subexpression, apply the value of the operator subexpression to the values of the operand subexpression.\nFor more details\n· For strings\n+ : connect the strings\n* : repeat the contents of a string\nin not in : determine whether a string contains another character\n[]and [:] : get some substrings from the string (including the first but excluding the last)\n1234567891011121314s1 =  &#x27; hello&#x27;  *  3 print (s1) # hello hello helloprint (&#x27;o&#x27; in s1) # Trues2 =  &#x27; world &#x27; s1 += s2print (s1) # hello hello hello world str1 = &#x27;hello,world&#x27;print (str1[2]) #lprint (str1[2:4]) #llprint (str1[2::2]) #lowrdprint (str1[::-1]) #dlrow,ollehprint (str1[-4:-2]) #orprint(str1[-1:-4:-1]) #dlr\nⅣ. Constant:\nThere are some built-in constants in python.\nPart.4  Built-in Data Structures\n\nAllow us to store related values together\n\nCan process the values one-by-one or in aggregate\nAllows us to form compound values through data abstraction\n\n\nGive rise to a number of ways of storing values\n\nLists store values in order, associated with an index\nDictionaries have no order but associate values with any sort of key\nTrees allow for a hierarchical representation of data\n\n\n\nⅠ. Sequence Type\n· list\nNumeric types(int  float …) are scalar types, which means that objects have no internal structure to access. However, string type is a structured, non-scalar type, so it has a range of properties and methods. List is the same as the string. However, list is mutable.\nList is an ordered sequence of values, each of which can be identified by an index, placed in the [] and separated by ,. The values can be any type.\n123456789101112131415161718192021222324252627282930313233# create a listlist0 = list()list0 = [1,3,5,7,100]  list1 = [&#x27;Hello&#x27;]*3 # or [&lt;expr&gt; for &lt;name&gt; in &lt;seq&gt; if &lt;cond&gt;]list2 = [i for i in range(4)]  print (list1,list2) # [&#x27;Hello&#x27;,&#x27;Hello&#x27;,&#x27;Hello&#x27;] [0,1,2,3]print (len(list0)) #5 print (list0[0]) # 1 print (list0[-3]) # 5 # split and joinlist3 = &#x27;list&#x27;print(list(list3)) # [&#x27;l&#x27;,&#x27;i&#x27;,&#x27;s&#x27;,&#x27;t&#x27;]list4 = &#x27;here-it-is&#x27;delimiter = &#x27;-&#x27;# split the string based on the delimiter. The string will be split based on the space when there is no argument. t = list4.split(delimiter)print(t) # [&#x27;here&#x27;,&#x27;it&#x27;,&#x27;is&#x27;]delimiter = &#x27; &#x27;print(delimiter.join(t)) # here it is# Traverse element in the listfor index in range(len(list1)):     print(list1[index])for elem in list1:     print(elem)for index,elem in enumerate (list1):     print(index, elem)for key,value in zip(list2,list3):    print(key,value)for i in reversed(range(1, 10, 2)):    print(i)\n123456789101112131415161718192021# Add and remove elements# append,insert,extend,remove and pop only change the original list.# Slicing,Shallow copying,Concatenating,List constructor create a new list.list0.append(200)# insert 400 at index 1.list0.insert(1,400)list0.extend([1000])list0 += [2000]print(list0) # [1, 400, 3, 5, 7, 100, 200, 1000, 2000] print(sum([[1],[2],[3]],[])) # [1]+[2]+[3]+[] = [1,2,3]if  3  in list0:\tlist0.remove( 3 )# delete and return the 0th elementlist0.pop (0)# delete and return the last elementl = list0.pop()del list0[0:3]print (list1,l) # [100, 200, 1000] 2000list1.clear()\n123456789101112# Slice the listfruits = [&#x27;grape&#x27;,&#x27;apple&#x27;,&#x27;strawberry&#x27;,&#x27;waxberry&#x27;]print(fruits[1:3]) # [&#x27;apple&#x27;, &#x27;strawberry&#x27;]print(fruits[::-1]) # [&#x27;waxberry&#x27;, &#x27;strawberry&#x27;, &#x27;apple&#x27;, &#x27;grape&#x27;]# Sort the listlist1 = [&#x27;orange&#x27;,&#x27;apple&#x27;,&#x27;zoo&#x27;,&#x27;blueberry&#x27;]print(sorted (list1)) # [&#x27;apple&#x27;, &#x27;blueberry&#x27;, &#x27;orange&#x27;, &#x27;zoo&#x27;]print(sorted (list1,reverse=True)) # [&#x27;zoo&#x27;, &#x27;orange&#x27;, &#x27;blueberry&#x27;, &#x27;apple&#x27;]print(sorted(list1,key = len )) # [&#x27;zoo&#x27;, &#x27;apple&#x27;, &#x27;orange&#x27;, &#x27;blueberry&#x27;]list1.sort( reverse = True )print(list1) # [&#x27;zoo&#x27;, &#x27;orange&#x27;, &#x27;blueberry&#x27;, &#x27;apple&#x27;]\n1234567# Generator f = [x + y for x in &#x27;ABC&#x27; for y in &#x27;12&#x27;]print (f) # [&#x27;A1&#x27;, &#x27;A2&#x27;, &#x27;B1&#x27;, &#x27;B2&#x27;, &#x27;C1&#x27;, &#x27;C2&#x27;]# Generator objects don&#x27;t take extra space to store data f1 = (x**2 for x in range (1,10))print(sys.getsizeof(f1)) #120print(f1) # &lt;generator object &lt;genexpr&gt; at 0x000001C05E2952C8&gt;\n12345678910111213# objects and valuesa = &#x27;banana&#x27;b = &#x27;banana&#x27;# identicalprint(a is b) # Truea = [1,2,3]b = [1,2,3]# equivalent but not identicalprint(a is b) # Falsea = [1,2,3]b = a# aliased but refer to the same objectprint(a is b) # True\nIt is important to keep track of when variables are identical versus just equal, since mutating one variable will mutate all other identical variables.\nThe methods and operators that lists share with other sequences (like strings) are documented here.\nList is mutable so we can change the elements inside the list. The methods and operators that only apply to mutable sequences are documented here.\n· Tuple\nTuple in Python is similar to the list and most list operator also work on tuples, however, it can not be modified and it is comparable and hashable.\n123456789101112131415161718192021222324t = (&#x27;tuple&#x27;, 100, 12.1 ,True)w,x,y,z = t # (w,x,y,z) = tprint (t[0]) # tupleprint(w,x,y,z) # &#x27;tuple&#x27;  100  12.1  Truew,x = x,wprint(w,x) # 100 &#x27;tuple&#x27;# To creat a single element, you have to include the final comma.t1 = (&#x27;single&#x27;,)t2 = tuple(&#x27;single&#x27;) # (&#x27;s&#x27;,&#x27;i&#x27;,&#x27;n&#x27;,&#x27;g&#x27;,&#x27;l&#x27;,&#x27;e&#x27;)#Traverse elements in the listfor element in t:     print(element)        # t[0] = &#x27;change&#x27; # TypeError # It can not be modified.# The variable t refers to a new tuple and the old one is recycled.t = (&#x27;change&#x27;, 100, 12.1 ,True)# convert the tuple into a list l = list(t)l[0] = &#x27;tuple&#x27;print(l) # tuple 100 12.1 True# convert the list into a tuplet = tuple(l)\n12345678910111213#Comparing tuplestxt = &#x27;but soft what light in yonder window breaks&#x27; words = txt.split() t = list() for word in words:    t.append((len(word), word))t.sort(reverse=True)print(t)# [(6, &#x27;yonder&#x27;), (6, &#x27;window&#x27;), (6, &#x27;breaks&#x27;), (5, &#x27;light&#x27;), (4, &#x27;what&#x27;), (4, &#x27;soft&#x27;), (3, &#x27;but&#x27;), (2, &#x27;in&#x27;)]# be used in dictionaryd = &#123;&#x27;a&#x27;:3,&#x27;b&#x27;:2,&#x27;c&#x27;:6&#125;print(sorted([(v,k) for k,v in d.items()])) #[(6,&#x27;c&#x27;),(3,&#x27;a&#x27;),(2,&#x27;b&#x27;)]\n1.There are two main advantages of the tuple listed as follows, meanwhile, they are also the reasons why we sometimes use tuple rather than list.\n\nIn fact, we may prefer to use the invariant objects in the project, especially in the multi-threaded environment because a constant object is much easier to maintain than a variable object and also can be easily shared and accessed.  So if we don’t need to add, delete, or modify elements, we can consider using tuples.\nTuples are better than lists in both creation time and occupied space.\nThere are a few cases where you might prefer tuples:\n· in a return statement\n· use a sequence as a dictionary key\n· pass a sequence as an argument to a function\n\n2.Sequence Aggregation\nsum(iterable[, start]) -&gt; value, max(iterable[, key=func]) -&gt; value OR max(a, b, c, ...[, key=func]) -&gt; value, bool(any_value) -&gt; bool, all(iterable) -&gt; bool, any(iterable) -&gt; bool\nⅡ. Set Type\nThe set in python is consistent with the mathematical set. It can not contain repetitive element.\n1234set1 = &#123;1, 2, 3, 3, 3, 2&#125; # &#123;1, 2, 3&#125;set2 = set(range(1, 10)) # &#123;1, 2, 3, 4, 5, 6, 7, 8, 9&#125;set3 = set((1, 2, 3, 3, 2, 1)) #&#123;1, 2, 3&#125;set4 = &#123;num for num in range(1, 100) if num % 3 == 0 or num % 5 == 0&#125;\n12345678set1 = &#123;1, 2, 3, 3, 3, 2&#125;set1.add(4)set1.update([11, 12]) # &#123;1, 2, 3, 4, 11, 12&#125;set1.discard(1)if 4 in set1:    set1.remove(4) # &#123;2, 3, 11, 12&#125;# delete and return the first elementset1.pop() # &#123;3, 11, 12&#125; # It&#x27;s different from the list.\n1234567891011121314set1 = &#123;1,2,3,4&#125;set2 = &#123;3,4,5,6&#125;print(set1 &amp; set2) # &#123;3, 4&#125;# print(set1.intersection(set2))print(set1 | set2) # &#123;1, 2, 3, 4, 5, 6&#125;# print(set1.union(set2))print(set1 - set2) # &#123;1, 2&#125;# print(set1.difference(set2))print(set1 ^ set2) # &#123;1, 2, 5, 6&#125;# print(set1.symmetric_difference(set2))print(set2 &lt;= set1) # False# print(set2.issubset(set1))print(set1 &gt;= set2) # False# print(set1.issuperset(set2))\nⅢ. Mapping Type:  dictionary\nA mapping object maps hashtable values to arbitrary objects. Mappings are mutable objects. But the key of the dictionary must be immutable variable.\n1234567891011121314151617181920212223# create the dictionarysscores = &#123;&#x27;Alice&#x27;: 95, &#x27;Peter&#x27;: 78, &#x27;Oreo&#x27;: 82&#125;items1 = dict(one=1, two=2, three=3, four=4)items2 = dict(zip([&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;], &#x27;123&#x27;))items3 = &#123;num: num ** 2 for num in range(1, 10)&#125;scores[&#x27;Peter&#x27;] = 89scores.update(John=67, Marry=85)for key in scores: # scores.keys() scores.values() scores.items()     print(f&#x27;&#123;key&#125;: &#123;scores[key]&#125;&#x27;)if &#x27;John&#x27; in scores:    print(scores[&#x27;John&#x27;])    print(scores.get(&#x27;Oreo&#x27;)) # 82print(scores.get(&#x27;Jonny&#x27;, 60)) # 60print(scores.popitem()) # (&#x27;Marry&#x27;, 85)print(scores.pop(&#x27;Alice&#x27;, 100)) # 95vals = list(scores)print(vals) # [&#x27;Peter&#x27;, &#x27;Oreo&#x27;, &#x27;John&#x27;]print(scores.values(),scores.keys(),scores,items) # dict_values([89, 82, 67]) dict_keys([&#x27;Peter&#x27;, &#x27;Oreo&#x27;, &#x27;John&#x27;]) dict_items([(&#x27;Peter&#x27;, 89), (&#x27;Oreo&#x27;, 82), (&#x27;John&#x27;, 67)])scores.clear()\nPart. 5 Language structure\nWe put these language elements together to form different expressions (primitive expression: numbers 2, strings'hello',  names add, x...; arithmetic expression: 15//3; call expression: max(add(2,3),6) ) .\nAnd different expressions form statements or instructions so that computers can get orders and do the certain operations. The way we organize the statements can be divided into different types of structures in order to make our program more effective. Generally, there are three types: sequential structure, conditional structure and iteration.\nPython uses indentation to set the hierarchy of different compound statements instead of using&#123;&#125;.  If the continuous statements maintains the same indentation then they belong to the same code block, which is equivalent to one specific function.\nⅠ. Conditional structure\nSometimes, we have to separate our solutions into different branches and change the actions of the program according to some conditions. In python, we use if statement(use the keywords if, else, elif) to implement it.\n123456if &lt;conditional expression&gt;:\t&lt;suite of statements&gt;elif &lt;conditional expression&gt;:\t&lt;suite of statements&gt;else:\t&lt;suite of statements&gt;\n· Chained conditionals : (two branches or more)\n12345678910111213# calculate the paymenttry:    fh = float(input(&#x27;Enter the hour: &#x27;))    fr = float(input(&#x27;Enter the rate: &#x27;))    if fh&lt;0 :        print(&#x27;Pleae enter the right number&#x27;)    elif fh&gt;=40 :        pay = (fh-40)*fr*1.5+40*fr    else :        pay = fh*fr    print(&#x27;Pay: &#x27;, pay)except:    print(&#x27;Pease enter numeric input!&#x27;)\nelif: one of the conditions, else: catch the exceptions\n(If more than one condition is true, only the first true branch executes.)\n· Nested conditionals :\n123456if fh&lt;0 :    print(&#x27;Pleae enter the right number&#x27;)else : if fh&gt;=40 :           pay = (fh-40)*fr*1.5+40*fr       else :           pay = fh*fr\nUsually, we use chained conditionals rather than nested conditionals or simplify it with operators. “Flat is better than nested”. Because the nested structure will have a serious impact on the readability of code.\nIn the if  statement, we have to execute the subsequent steps through the result of the if conditional expression (usually is a boolean expression: True or False). True and False are specific attributes of each object in python. Examples of True and False values of objects in python:\n12345678&quot;spam&quot;   # True&quot;&quot;       # False[]       # False&#123;&#125;       # False1        # True-1       # False0.0      # False None     # False\nAnd also the result of some logical expressions.\n12341 &gt;= 2      # Falsea == b   # Truea is b   # Falseele in list1 # True\nⅡ. Iteration\nRepetitive tasks are the main work for computers. Python provides the while statement and for statement  to  let  the computers do the tasks in a more efficient way.\n· while statement   (indefinite loops):\n1234567891011121314151617# output the max and minsmallest = Nonelargest = Nonewhile True:    num = input(&#x27;Enter the num: &#x27;)    if num == &#x27;Done&#x27;:        break    try:        num = int(num)    except:        print(&#x27;Invalid input!&#x27;)        continue    if smallest is None or num&lt;smallest:        smallest = num    if largest is None or num&gt;largest:        largest = numprint(&#x27;The smallest:&#x27;,smallest,&#x27;The largest:&#x27;,largest)\nbreak:  If the condition is met, the program will jump out of the loop.\ncontinue:  Skip to the next iteration without finishing the body of the loop for the current iteration.\n·  for statement  (definite loops)\nWhen we want to loop through a set of words, the lines in a file, a list of numbers and so on, we can construct a definite loop using a for statement.\n12345# Multiplication tablefor i in range(1, 10):    for j in range(1, i + 1):        print(&#x27;%d*%d=%d&#x27; % (i, j, i * j), end=&#x27;\\t&#x27;)    print()\nrange(&lt;start&gt;, &lt;end&gt;, &lt;skip&gt;): Creates a range object from &lt;start&gt; (inclusive) to &lt;end&gt; (exclusive), skipping every &lt;skip&gt; element.\nrange(1, 100, 2)An odd sequence of 1 to 99 can be generated and 2 is the the increment of the sequence of values (step size).\n123friends = [&#x27;oreo&#x27;, &#x27;sermantha&#x27;, &#x27;Damon&#x27;]for friend in friends:    print(&#x27;Happy New Year!&#x27;,friend)\nⅢ. Function, Module and Package\n· Function\nIn order to  write high-quality code, we should eliminate the repetitive code which is doing the same type of  operations. We can encapsulate those repetitive codes into a function module called “function”  so that we “call” the “function” when we need it.\nGenerally, function is a named (bind the name to the function value in current scope) and reusable sequence of statements that takes arguments as input, performs a computation and maps arguments  to a return value. (The naming rules of function are consistent with the naming rules of variables. )\nA function that does not explicitly return a value will return None.\nA side effect is anything that happens as a consequence of calling a function.\nProcedure for calling/applying user-defined functions:\n\nBind the function’s parameters to its arguments in the new scope .\nExecute the body of the function in the new scope.\n\nOnly call expressions create new local scope and every call expression have their own scope no matter it is the same function that was called again. The parent scope is where the function is defined.\n1234567# define a function# A def statement creates a function object with certain parameters and a body and binds it to a name in the current scope. def factorial(num):    result =  1     for n in range (1,num+1):        result *= n    return result\n1.Arguements\nIn Python, function parameters can have default values and also support for variable parameters which is quite different from other languages.\nWhen the arguments passed by a function is an object of an immutable or mutable type, what is passed is not the actual value but a reference to the object.\n123456789101112131415161718192021from random import randintdef roll_dice(n=2): # The default value is 2.    Total =  0     for _ in range(n):        Total += randint(1,6)    return Total# &#x27;*&#x27; and &#x27;**&#x27; indicate that args is a variable parameter. # tu_args will be passed to the function as a tuple and dic_args will be  a dictionary.def add(*tu_args,**dic_args):     Total =  0     for key,value in dic_args.items():        print(key,value)    for val in tu_args:        Total += val    return Totalprint(roll_dice())              # 8print(roll_dice(6))             # 24print(add(2,45,a=23,b=44))      # a 24 b 44 47\nPython looks for a variable in the order of “local scope”, “nested scope” or the parent scope, “global scope” and “built-in scope”.\nSome identifiers like input,print and int  are built  inside the python which belong to built-in scope. The local variables can only be used inside the function it belongs to, but we can access the global variables anywhere we want to.\nHowever, if we want to modify the value of the global variables inside a specific function, we should add global  before the variables. Or we want to modify variables in an enclosing scope( the first non-local frame of the current environment), we can add nonlocal before the variable as a nonlocal assignment. Names listed in a nonlocal statement must refer to pre-existing bindings in an enclosing scope and also must not collide with pre-existing bindings in the local scope. Nonlocal allows you to modify a binding in a parent frame, instead of just looking it up.\nMutable values can be changed without a nonlocal statement.\n1234567891011121314def foo(d):    b =  &#x27;Hello&#x27; # b belongs to nested scope    global a    a =  200     def bar ():        nonlocal d        c =  &#x27;You&#x27; # c belongs to local scope as a local variable        return d.upper() + b + c    return bar()    if  __name__  ==  &#x27; __main__ &#x27; :    a =  100  # a belongs to global scope as a global variable    foo(&#x27;hey&#x27;)    print (a) # 200\nPython pre-computes which frame contains each name before executing the body of a function. Within the body of a function, all instances of a name must refer to the same frame.\nIn the actual development process, we should reduce the use of global variables due to its wide scope.  Unexpected modifications may occur and also the memory occupied by variables are unable to be recycled.\n2.Docstring\nWe can write documentation strings (or docstrings) to provide a convenient way of associating documentation with Python modules, functions, classes, and methods. The docstring should describe what the function does, not how.\nThe rules of writing docstrings:\n\n· The doc string line should begin with a capital letter and end with a period.\n· The first line should be a short description.\n· If there are more lines in the documentation string, the second line should be blank, visually separating the summary from the rest of the description.\n· The following lines should be one or more paragraphs describing the object’s calling conventions, its side effects, etc.\n\nThe way of declaring docstrings:\nUsing ”’triple single quotes”’  just below the class, method or function declaration.\nThe way of accessing docstrings:\nUsing the  _doc_ method of the object or using the help function.\n123456789101112def my_function(): \t&#x27;&#x27;&#x27;Demonstrates triple double quotes \t\tdocstrings and does nothing really.&#x27;&#x27;&#x27;\treturn Noneprint(&quot;Using __doc__:&quot;) print(my_function.__doc__) print(&quot;Using help:&quot;) help(my_function) \n123456789Using __doc__:Demonstrates triple double quotes    docstrings and does nothing really.Using help:Help on function my_function in module __main__:my_function()    Demonstrates triple double quotes    docstrings and does nothing really.\n3.Built-in functions\nActually, factorial function is a built-in function in python, we can use such kind of functions directly without defining them. More built-in functions in python.\n4.Anonymous functions\nPython uses lambda to create anonymous functions. The so-called anonymous means that a function is no longer defined in a standard form such as the def statement.\n1lambda [arg1 [,arg2,.....argn]]:expression\nThe body of the function is an expression, which can only encapsulate limited logic in it. And the lambda function has its own namespace and cannot access parameters outside of its parameter list or in the global namespace.\n5.Higher Order Function: a function that either takes in functions as an argument and/or returns a function as a return value.\nUsually we can give each function exactly one job, but make it apply to many related situations. We can generalize patterns with arguments and computational processs to make the function applied to a series of situations.\n123456789101112131415def identity(x):    return xdef cube(x):    pow(x,3)    def summation(n,term):    total,k =0,1    while k&lt;= n:        total,k = total+term(k), k+1    return totaldef sum_naturals(n):    return summation(n,identity)def sum_cubes(n):    return summation(n,cube)\n1234567891011121314def make_adder(n):    def adder(k):        return k + n    return adderdef square(x):    return x*xdef compose(f,g):    def h(x):        return f(g(x))    return h    print(compose(square,make_adder(3))(3))  # Equal to square(make_adder(3)(3))\n1234567def print_sums(n):    print(n)    def next_sum(k):        return print_sums(n + k)    return next_sumprint_sums(1)(3)(5)\nNested functions can access variables in outer function (adder) as well as the outer function itself (print_sums).\nDon’t conflate: function name vs. function call.\n· Module\nIf you quit from the Python interpreter and enter it again, the definitions you have made (functions and variables) are lost. Or sometimes, you are faced with naming conflicts of different functions in one file. Or as your program gets longer, you may want to split it into several files for easier maintenance. Or you may also want to use a handy function that you’ve written in several programs without copying its definition into each program. At such moments, python has a way to put definitions in a file and use them in a script or in an interactive instance of the interpreter. In Python, every file represents a module.\nWe can use the import  to import the specified module to distinguish different functions.\nThe variable sys.path is a list of strings that determines the interpreter’s search path for modules. It is initialized to a default path taken from the environment variable PYTHONPATH, or from a built-in default if PYTHONPATH is not set. You can modify it using standard list operations: sys.path.append(‘/lib/python’).\nmodule1.py \n12def foo():     print (&#x27;hello, world!&#x27; )\nmodule2.py \n12def foo():     print (&#x27;goodbye, world!&#x27;)\ntest.py\n1234import module1 as m1import module2 as m2m1.foo() #hello, world!m2.foo() #goodbye, world!\nEach module has its own private symbol table, which is used as the global symbol table by all functions defined in the module.\nHowever, besides the functions defined in the module we import, if there are some other executable codes, it’d be better to put those codes into the condition shown below so that the python interpreter will only execute them when the module is run directly and will not execute them when we import the module into other files.\n123456def foo():    print (&#x27;goodbye, world!&#x27;)# __name__ is an implicit variable in Python that represents the name of the module.if  __name__ == &#x27; __main__ &#x27; :    print (&#x27;hello, world!&#x27;)    foo()\n· Package\nSometimes you may need to create and maintain a growing collection of modules for dealing with difficult problems in an actual project. Packages are a way to achieve this and also structure Python’s module namespace by using “dotted module names”.\n1234567891011121314sound&#x2F;                          Top-level package      __init__.py               Initialize the sound package      formats&#x2F;                  Subpackage for file format conversions              __init__.py              wavread.py              ...      effects&#x2F;                  Subpackage for sound effects              __init__.py              echo.py              ...      filters&#x2F;                  Subpackage for filters              __init__.py              equalizer.py              ...\nWhen importing the package, Python searches through the directories on sys.path looking for the package subdirectory. The __init__.py files are required to make Python treat directories containing the file as packages.\nWe can use leading dots to indicate the current and parent packages involved in the relative import.\n12345import sound.effects.echofrom . import echofrom .. import formatsfrom ..filters import equalizer\nPart. Exercise\nEx.1: Enter the year to determine if it is a leap year.\n1234year = int(input(&#x27; Please enter the year: &#x27;))is_leap = (year % 4 == 0 and year % 100 != 0) or \\          year % 400 == 0print(is_leap)\nEx.2: Enter two positive integers and calculate their greatest common divisor and least common multiple.\n12345678910x =  int ( input ( &#x27; x = &#x27; ))y =  int ( input ( &#x27; y = &#x27; )) if x &gt; y:     # swap the values of x and y    x , y = y, xfor factor in  range (x, 0 , - 1 ):     if x % factor == 0 and y % factor == 0 :         print (&#x27;The greatest common divisor of %d and %d  is %d&#x27; % (x, y, factor))         print (&#x27;The least common multiple of %d and %d is %d&#x27; % (x, y, x * y // factor))         break\nEx.3:  Look for the Narcissistic number.\n123456for num in  range ( 100 , 1000 ):    low = num %  10     mid = num // 10 % 10     high = num // 100     if num == low ** 3  + mid ** 3  + high ** 3 :         print (num)\nEx.4:  Generate the first 20 numbers of the Fibonacci sequence\n12345a = 0b = 1for _ in range(20):    a, b = b, a + b    print(a, end=&#x27; &#x27;)\nEx.5:   Find the perfect number within 10,000\n1234567891011import mathfor num in range(1, 10000):    result = 0    for factor in range(1, int(math.sqrt(num)) + 1):        if num % factor == 0:            result += factor            if factor &gt; 1 and num // factor != factor:                result += num // factor    if result == num:        print(num)\nEx.6:   Output all prime numbers within 100\n12345678910import mathfor num in range(2, 100):    is_prime = True    for factor in range(2, int(math.sqrt(num)) + 1):        if num % factor == 0:            is_prime = False            break    if is_prime:        print(num, end=&#x27; &#x27;)\nEx.7: Write a program to find all the palindrome prime within 10000.\n12345678910111213141516171819202122232425import mathdef prime(arg):    is_prime = True    for i in range(2,int(math.sqrt(arg))+1):        if arg % i == 0 :            is_prime = False            break    return is_primedef palindrome(arg):    result = 0    number = arg    while arg &gt; 0:        result = arg % 10 + result*10        arg //= 10    return result == numberexist = Falsefor num in range(10, 10000):    if prime(num) and palindrome(num):        print(&#x27;%d is a palindrome prime!&#x27; % (num))        exist = Trueif exist is False :    print(&#x27;There is no palindrome prime!&#x27;)\nEx.8: Make a histogram of  the domain name in a mail log and find  the name  that appears the most.\n123456789101112131415161718192021name = input(&quot;Enter file:&quot;)fd = open(name)count  = dict()for line in fd:    line = line.rstrip()    words = line.split()    if len(words) == 0 or len(words) &lt; 2: continue    if words[0] == &#x27;From&#x27;:        word = words[1]        pos = word.find(&#x27;@&#x27;)        word = word[pos+1:]        count[word] = count.get(word,0)+1print(count)bigkey = Nonebigvalue = Nonefor key,val in count.items():    if bigvalue is None or bigvalue &lt; val:        bigkey = key        bigvalue = valprint(bigkey,bigvalue)\nThe file is here.\n","plink":"https://oreodu.github.io/2019/20191010-Python-Basics-01/"},{"title":"","date":"2020-12-19T08:27:18.557Z","date_formatted":{"ll":"Dec 19, 2020","L":"12/19/2020","MM-DD":"12-19"},"updated":"2020-12-19T08:27:18.551Z","content":"Introduction\nSelf Introduction\nI am a student who just graduated form Dalian Maritime University in June(2019) in China and will continue to study in Tokyo University next year in April to get my master degree. My major is Artificial Intelligence and my desired research direction is machine learning and combinatorial optimism. Because I haven’t enrolled in school yet, the specific research topic hasn’t been decided -.-.\nThere are several reasons for starting to write this Blog that I want to share with you and this may also help you have a quick look at the main contents of this Blog.\n\nI want to keep track of my learning process and share those materials, notes and experience with you. I do believe that only when I can explain to others what I have learned, I can master the knowledge.\nI want to systematize my professional knowledge and organize them into a big framework so that whenever I learn something new I won’t feel confused again.\nI want to improve my writing skill in English and Japanese so all the articles in this Blog will be written in English or Japanese. Because I am not a native speaker so there must be some mistakes that I ignored and some weird expressions that may confuse you in my articles and I’d appreciate it if you could point out them in the comment section or contact me.\n\nBlog Contents\nI will keep updating this content.\nPart. 1\n\n\nData Structure\n\nLinear List\n\nArray, Linked List\nStack, Queue\n\n\nSet\nHash Tables\nSymbol Tables (associative arrays, map, dictionary)\nTree\n\nSearch tree\n\nBinary search tree\nRed-black tree\nB-tree\n\n\nHeap\n\nBinary heap\nPriority Queue\n\n\nTries\nUnion Find (Disjoint-set)\n\n\n\n\n\nAlgorithms\n\nAlgorithm Basics\nBasic Algorithm Ideas\n\nGreedy Algorithms\nSearch and enumeration\nDivide and Conquer\nRecursion\nBack Tracking\nDynamic Programing\n\n\nSearching\n\nBinary search\nSearch Tree\nHash Table\nSymbol Tables\nDFS, BFS\n\n\nSorting\n\nBubble Sort, Selection Sort\nInsertion Sort\nShell Sort\nMerge sort\nQuick Sort, 3-way quick\nHeapSort\n\n\nGraphs\nStrings\nOther Algorithms\n\nSliding window\n\n\n\n\n\nAdvanced Algorithms\n\nNetwork Flow\nNP\nLocal Search\nApproximation Algorithms\nRandomized Algorithms\nQuantum Algorithms\nCombinatorial Optimism\n\n\n\nLeetcode\nThe code is almost here.\n\n\nMachine learning\n\n\nDeep learning\n\n\nPart. 2\n\nProgramming\n\nBasic knowledge\nUtils\n\nGit ：Using Git  (Materials from CS61B in UC Berkeley)\nShell Command\nDocker\n\n\nSQL\n\nBasis\n\n\nScheme\n\nBasis\n\n\nJava\n\nBasis 01,02,03\n\n\nPython\n\nBasis 01,02,03\nWeb Development\nCrawler\nOperation and Maintenance of Automation\nData Mining\n\n\nOctave\n\nLanguage Basis\n\n\n\n\n\nPart. 3\n\nDatabase\nOperating System\nComputer System\nComputer Network\n\nPart.4\n\nCalculus\nProbability and Statistics\nLinear Algebra\n\nHope you enjoy this journey!\n","plink":"https://oreodu.github.io/about/"},{"title":"Leetcode","date":"2020-10-03T23:07:00.000Z","date_formatted":{"ll":"Oct 4, 2020","L":"10/04/2020","MM-DD":"10-04"},"updated":"2020-11-11T07:54:11.542Z","content":"LEETCODE\nProblems from Leetcode.\nData Structure\nMap\n\n\nProblems Number\nName\nContext\n\n\n\n\n\n001\nTwo Sum\n\nEasy\n\n\n350\nIntersection of Two Arrays Ⅱ\nSet, Two Pointers\nEasy\n\n\nSet\n\n\nProblems Number\nName\nContext\n\n\n\n\n\n349\nIntersection of Two Arrays\nSet, Two Pointers, Binary Search\nEasy\n\n\nLinked list\n\n\nProblems Number\nName\nContext\n\n\n\n\n\n002\nAdd Two Numbers\n\nMedium\n\n\n206\nReverse Linked List\nRecursive, Iterative, Two pointers\nEasy\n\n\n092\nReverse Linked List Ⅱ\nRecursive, Iterative, Two pointers\nMedium\n\n\n024\nSwap Nodes in Pairs\nRecursive, Iterative,Two pointers\nMedium\n\n\n025\nReverse Nodes in k-Group\nRecursive, Iterative,Two pointers\nHard\n\n\n142\nLinked List Cycle\nHashSet, Floyd Cycle Dectctipn, Two pointers\nMedium\n\n\nStack\n\n\nProblems Number\nName\nContext\n\n\n\n\n\n020\nValid Parentheses\nStack\nEasy\n\n\n232\nImplement Queue using Stacks\nStack\nEasy\n\n\n225\nImplement Stack using Queues\nQueue\nEasy\n\n\n155\nMin Stack\nStack\nEasy\n\n\n716\nMax Stack\nStack\nEasy\n\n\nSearch\n\n\nProblems Number\nName\nContext\n\n\n\n\n\n004\nMedian of two sorted arrays\nBinary search in two arrays\nHard\n\n\n029\nDivide Two Integers\n\n\n\n\nSort\nGreedy Algorithm\nDivide and Conquer\nRecursion\nBacktracking\nDynamic Programing\nGraph\nString\nOther\nTwo Pointers\n\n\nProblems Number\nName\nContext\n\n\n\n\n\n167\nTwo Sum Ⅱ\n\n\n\n\n\n\n\n\n\n\nSliding window\n\n\nProblems Number\nName\nContext\n\n\n\n\n\n003\nLongest substring without repeating\n\nMedium\n\n\n\n\n\n\n\n\nUnion Find\n\n\nProblems Number\nName\nContext\n\n\n\n\n\n200\nNumber of Islands\nDFS, BFS, UnionFind\nMedium\n\n\n547\nFriend Circles\nDFS, BFS, UnionFind\nMedium\n\n\n\n\n\n\n\n\nWeekly Contest\n\n\nProblems Number\nName\nContext\n\n\n\n\n\n185-1\n\n\n\n\n\n185-2\n\n\n\n\n\n185-3\n\n\n\n\n\n185-4\n\n\n\n\n\n186-1(5392)\nMaximum Score After Splitting a String\n\nEasy\n\n\n186-2(5393)\nMaximum Points You Can Obtain from Cards\n\nMedium\n\n\n186-3(5394)\nDiagonal Traverse II\n\n\n\n\n186-4(5180)\nConstrained Subset Sum\n\n\n\n\n","plink":"https://oreodu.github.io/leetcode/"},{"title":"","date":"2020-10-23T12:00:51.250Z","date_formatted":{"ll":"Oct 23, 2020","L":"10/23/2020","MM-DD":"10-23"},"updated":"2020-10-11T02:18:48.171Z","content":"Data Structure\nUnion Find\n1234567891011121314151617181920212223242526272829303132333435363738394041424344454647package Other.UnionFind;public class UnionFind &#123;    private int[] roots;    private int[] size;    public int rootsNumber;    public UnionFind(int N)&#123;        rootsNumber = N;        roots = new int[N];        size = new int[N];        for (int i = 0; i&lt;N; i++) &#123;            roots[i] = i;            size[i] = 1;        &#125;    &#125;    public boolean connected(int i, int j)&#123;        return root(i) == root(j);    &#125;    public int root(int i)&#123;        int node = i;        while(roots[i]!=i) i = roots[i];        while(node!= roots[node]) &#123;            int temp = roots[node];            roots[node] = i;            node = temp;        &#125;        return i;    &#125;    public void union(int i, int j) &#123;        int ri = roots[i];        int rj = roots[j];        if (size[ri]&lt;size[rj]) &#123;            roots[ri] = rj;            size[rj] += size[ri];        &#125;        else &#123;            roots[rj] = ri;            size[ri] = size[rj];        &#125;        // Once a connection is formed, the number of the roots will decrease one.        rootsNumber--;    &#125;&#125;\nAlgorithms\nRecursion\n1234567891011121314public void &lt;T&gt; recursion (int level, T param1, T param2) &#123;    // recursion terminator    if (level &gt; MAX_LEVEL) &#123;        // print result        return ;    &#125;        // processlogic in current level        // drill down    recursion(level + 1, p1,p2);        // reverse the current level status if needed&#125;\nBFS\n123456789101112131415161718192021222324private void bfs(int i, int j, char[][] grid, int[][] visited,int[][] index) &#123;    int m = grid[0].length;    Queue&lt;Integer&gt; q = new LinkedList&lt;&gt;();    visited[i][j] = 1;    q.add(i * m + j);    while (!q.isEmpty()) &#123;        int node = q.poll();        int row = node / m;        int col = node % m;        for (int a = 0; a &lt; index[0].length; a++) &#123;            int tempx = row + index[0][a];            int tempy = col + index[1][a];            if (isValid(tempx, tempy, grid, visited)) &#123;               // After being put in the queue, it must be marked as visited immediately.               // If mark it when it is moved out the queue, it will cause many duplicate nodes to enter the queue.                visited[tempx][tempy] = 1;                q.add(tempx * m + tempy);            &#125;        &#125;    &#125;&#125;\nDFS\n123456789101112private void dfs(int i, int j, char[][] grid,int[][] index,int[][] visited) &#123;    if (grid[i][j] == &#x27;0&#x27; || visited[i][j] == 1) return;    visited[i][j] = 1;    for (int a = 0; a &lt; index[0].length; a++) &#123;        int tempx = i + index[0][a];        int tempy = j + index[1][a];        if (tempx &gt;= 0 &amp;&amp; tempx &lt; grid.length &amp;&amp; tempy &gt;= 0 &amp;&amp; tempy &lt; grid[0].length)            dfs(tempx, tempy, grid, index, visited);    &#125;&#125; \n","plink":"https://oreodu.github.io/cheatsheet/"}]