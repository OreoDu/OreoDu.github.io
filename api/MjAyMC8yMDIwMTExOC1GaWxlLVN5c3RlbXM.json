{"title":"File Systems","date":"2020-11-17T17:42:00.000Z","date_formatted":{"ll":"Nov 18, 2020","L":"11/18/2020","MM-DD":"11-18"},"link":"2020/20201118-File-Systems","comments":true,"tags":["File Systems","Linux","Operating System"],"categories":["Linux","Operating System"],"updated":"2020-12-17T13:08:31.856Z","content":"<h1 id=\"file-systems\">File Systems<a title=\"#file-systems\" href=\"#file-systems\"></a></h1>\n<p>Abstracting Files â€“ Virtual File Systems (VFS)</p>\n<h2 id=\"part.1-general-presentation\">Part.1 General Presentation<a title=\"#part.1-general-presentation\" href=\"#part.1-general-presentation\"></a></h2>\n<h3 id=\"the-virtual-file-system(vfs)\">The virtual File System(VFS)<a title=\"#the-virtual-file-system(vfs)\" href=\"#the-virtual-file-system(vfs)\"></a></h3>\n<p>Abstract all the filesystems models supported by Linux and allow them to coexitst and cooperate.</p>\n<img src=\"https://tva1.sinaimg.cn/large/0081Kckwgy1gkwj9zjaq2j30lk0aedhi.jpg\" alt=\"Screen Shot 2020-11-21 at 09.24.08\" style=\"zoom:50%;\">\n<h3 id=\"common-filesystem-interface\">Common filesystem interface<a title=\"#common-filesystem-interface\" href=\"#common-filesystem-interface\"></a></h3>\n<p>VFS allows user-space to access files independently of the concrete filesystem they are stored on, with a common interface. Interface can work transparently between filesystems.</p>\n<h3 id=\"filesystem-abstraction-layer\">Filesystem abstraction layer<a title=\"#filesystem-abstraction-layer\" href=\"#filesystem-abstraction-layer\"></a></h3>\n<p>VFS redirect user-space requests to the corresponding concrete filesystem. Developing a new filesystem for Linux means conforming with the bottom interface.</p>\n<img src=\"https://tva1.sinaimg.cn/large/0081Kckwgy1gkwjybnua2j30tq086wgd.jpg\" alt=\"Screen Shot 2020-11-21 at 09.47.36\" style=\"zoom: 50%;\">\n<h3 id=\"unix-filesystems\">Unix filesystems<a title=\"#unix-filesystems\" href=\"#unix-filesystems\"></a></h3>\n<p>Filesystem can refer to a filesystem type or a partition. Hierarchical tree of files organized into directories.</p>\n<img src=\"https://tva1.sinaimg.cn/large/0081Kckwgy1gkwk64e3hdj30qq0cw76o.jpg\" alt=\"Screen Shot 2020-11-21 at 09.55.06\" style=\"zoom:50%;\">\n<p>File: ordered string bytes from file address @0 to address @file_size-1. The associated metadata (name, assess permissions, modification date, etc) is separated from the file data into specific objects(<code>inodes</code>, <code>dentries)</code>.</p>\n<p>Directory: Folder containing files or other directories(sub-directories). Sub-directories can be nested to create path.</p>\n<h2 id=\"part.2-vfs-data-structures\">Part.2 VFS data structures<a title=\"#part.2-vfs-data-structures\" href=\"#part.2-vfs-data-structures\"></a></h2>\n<h3 id=\"generalities\">Generalities<a title=\"#generalities\" href=\"#generalities\"></a></h3>\n<img src=\"https://tva1.sinaimg.cn/large/0081Kckwgy1gkwkksu6qtj310w0ju79j.jpg\" alt=\"Screen Shot 2020-11-21 at 10.09.12\" style=\"zoom: 33%;\">\n<p><code>dentry</code>: it is associated with a file or a directory and store the file/directory name and its location in the directory tree. It performs directory specific operations and constructed on the fly as files and directories are accessed: generally no on-disk representation.</p>\n<h4 id=\"dentry-states\">Dentry states<a title=\"#dentry-states\" href=\"#dentry-states\"></a></h4>\n<p>A dentry can be used , unused or negative.<br>\nUsed: corresponds to a valid inode(pointed by d_inode) with one or more users(d_count)<br>\nUnused: valid inode, but no current users.(kept in RAM for caching, can be discarded)<br>\nNegative: does not point to a valid inode.(kept around for caching and can be discarded)</p>\n<h4 id=\"the-dentry-cache\">The dentry cache<a title=\"#the-dentry-cache\" href=\"#the-dentry-cache\"></a></h4>\n<p>Dentries are constructed on demand and kept in RAM for quick future pathname lookups.<br>\nThere are three parts:</p>\n<ol>\n<li>Linked list of used dentries linked by the <code>i_dentry</code> field of their inode. (One inode can have multiple links, thus multiple dentries)</li>\n<li>Linked list of LRU sorted unused and negative dentries.(LRU: quick reclamation from the tail of the list.)</li>\n<li>Hash table + hash function to quickly resolve a path into the corresponding dentry present in the dcache.<br>\nHash table:  <code>dentry_hashtable</code> array, each element is a pointer to a list of dentries hashing to the same value.<br>\nHashing function: <code>d_hash()</code>, filesystem can provide its own hshing function.<br>\nDentry lookup in the dcache: <code>d_lookup()</code>, returns dentry on success, NULL on failure.<br>\nInodes are similarly cached in RAM, in the inode cache, dentries in the dcache are pining inodes in the node cache.</li>\n</ol>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* defined in `include/linux/dcache.h` */</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">dentry</span> &#123;</span></span><br><span class=\"line\">  <span class=\"keyword\">atmoic_t</span> d_conut; <span class=\"comment\">/* usage count */</span></span><br><span class=\"line\">  <span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> d_flags; <span class=\"comment\">/* dentry flags */</span></span><br><span class=\"line\">  <span class=\"keyword\">spinlock_t</span> d_lock; <span class=\"comment\">/* per-dentry lock */</span></span><br><span class=\"line\">  <span class=\"keyword\">int</span> d_mounted; <span class=\"comment\">/* indicated if it is a mount point */</span></span><br><span class=\"line\">  <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">inode</span> *<span class=\"title\">d_inode</span>;</span> <span class=\"comment\">/* assoociated inode */</span></span><br><span class=\"line\">  <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">hlist_node</span> <span class=\"title\">d_dash</span>;</span> <span class=\"comment\">/* list of hash table entries */</span></span><br><span class=\"line\">  <span class=\"comment\">/* ... */</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* defined in `inculde/linux/dcache.h` */</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">dentry_operations</span> &#123;</span></span><br><span class=\"line\">  <span class=\"comment\">/* determine if an entry to use from the dcache is valid, generally set to NULL */</span></span><br><span class=\"line\">  <span class=\"keyword\">int</span> (*d_revalidate)(struct dentry*, <span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span>);</span><br><span class=\"line\">  <span class=\"keyword\">int</span> (*d_weak_revalidate)(struct dentry *, unsighned <span class=\"keyword\">int</span>);</span><br><span class=\"line\">  <span class=\"comment\">/* Create a hash value for entry to insert in the dcache */</span></span><br><span class=\"line\">  <span class=\"keyword\">int</span> (*d_hash)(<span class=\"keyword\">const</span> struct dentry *, struct qstr *);</span><br><span class=\"line\">  <span class=\"comment\">/* compare two filenames, requires `dcache_lock` */</span></span><br><span class=\"line\">  <span class=\"keyword\">int</span> (*d_compare)(<span class=\"keyword\">const</span> struct dentry *,</span><br><span class=\"line\">               , <span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span>, <span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *, <span class=\"keyword\">const</span> struct qstr *);</span><br><span class=\"line\">  <span class=\"comment\">/* called by VFS when `d_count` reaches zero, requires `dcache_lock` and `d_lock` */</span></span><br><span class=\"line\">  <span class=\"keyword\">int</span> (*d_delete)(<span class=\"keyword\">const</span> struct dentry);</span><br><span class=\"line\">  <span class=\"keyword\">int</span> (*d_init)(struct dentry *);</span><br><span class=\"line\">  <span class=\"comment\">/* called when the dentry is going to be freed */</span></span><br><span class=\"line\">  <span class=\"keyword\">void</span> (*d_release)(struct dentry *);</span><br><span class=\"line\">  <span class=\"keyword\">void</span> (*d_prune)(struct dentry *);</span><br><span class=\"line\">  <span class=\"comment\">/* called when the dentry looses its inode and calls `input()` */</span></span><br><span class=\"line\">\t<span class=\"keyword\">void</span> (*d_iput)(struct dentry *, struct inode *);</span><br><span class=\"line\">\t<span class=\"keyword\">char</span> *(*d_dname)(struct dentry *, <span class=\"keyword\">char</span> *, <span class=\"keyword\">int</span>);</span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">vfsmount</span> *(*<span class=\"title\">d_automount</span>)(<span class=\"keyword\">struct</span> <span class=\"title\">path</span> *);</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> (*d_manage)(<span class=\"keyword\">const</span> struct path *, <span class=\"keyword\">bool</span>);</span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">dentry</span> *(*<span class=\"title\">d_real</span>)(<span class=\"keyword\">struct</span> <span class=\"title\">dentry</span> *</span></span><br><span class=\"line\"><span class=\"class\">                           , <span class=\"title\">const</span> <span class=\"keyword\">struct</span> <span class=\"title\">inode</span> *, <span class=\"title\">unsigned</span> <span class=\"title\">int</span>);</span></span><br><span class=\"line\">&#125;__cacheline_aligned;</span><br></pre></td></tr></table></figure>\n<p><code>inode</code>: it is related to file or directory and contains metadata(file size, owner id/group, etc) plus information about how to manipulate the file/directory. It must be produced by the filesystem on-demand when a file/directory is accessed.</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* defined in `inculde/linux/fs.h` */</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">inode</span> &#123;</span></span><br><span class=\"line\">  <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">hlist_node</span> <span class=\"title\">i_hash</span>;</span> <span class=\"comment\">/* hash list */</span></span><br><span class=\"line\">  <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">list_head</span> <span class=\"title\">i_list</span>;</span> <span class=\"comment\">/* list of nodes */</span></span><br><span class=\"line\">  <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">list_head</span> <span class=\"title\">i_sb_list</span>;</span> <span class=\"comment\">/* list of superblock */</span></span><br><span class=\"line\">  <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">list_head</span> <span class=\"title\">i_dentry</span>;</span> <span class=\"comment\">/* list of dentries */</span></span><br><span class=\"line\">  unsighned <span class=\"keyword\">long</span> i_ino; <span class=\"comment\">/* inode number */</span></span><br><span class=\"line\">  <span class=\"keyword\">atomic_t</span> i_count; <span class=\"comment\">/* reference counter */</span></span><br><span class=\"line\">  <span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> i_nlink; <span class=\"comment\">/* number of hard links */</span></span><br><span class=\"line\">  <span class=\"keyword\">uid_t</span> i_uid; <span class=\"comment\">/* uer id of owner */</span></span><br><span class=\"line\">  <span class=\"comment\">/* ... */</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* defined in `include/linux/fs.h` */</span></span><br><span class=\"line\"><span class=\"comment\">/* invoke on an innode object */</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">inode_operations</span> &#123;</span></span><br><span class=\"line\">  <span class=\"comment\">/* create a new node with access mode `mode` */</span></span><br><span class=\"line\">  <span class=\"comment\">/* call from `creat()` and `open()` syscalls */</span></span><br><span class=\"line\">  <span class=\"keyword\">int</span> (*creat) (struct inode *, struct dentry *, <span class=\"keyword\">umode_t</span>, <span class=\"keyword\">bool</span>);</span><br><span class=\"line\">  <span class=\"comment\">/* create a hard link with name `dentry` in the directory `dir`, pointing to old_dentry */</span></span><br><span class=\"line\">  <span class=\"keyword\">int</span> (*link) (struct dentry *, struct inode *, struct dentry *);</span><br><span class=\"line\">  <span class=\"comment\">/* remove an inode from the directory `dir` */</span></span><br><span class=\"line\">  <span class=\"keyword\">int</span> (*unlink) (struct inode *, struct dentry);</span><br><span class=\"line\">  <span class=\"comment\">/* creates a symbolic link named `symname`, to the file `dentry` in directory `dir` */</span></span><br><span class=\"line\">  <span class=\"keyword\">int</span> (*symlink) (struct inode *, struct dentry *, <span class=\"keyword\">const</span> <span class=\"keyword\">char</span>*);</span><br><span class=\"line\">  <span class=\"comment\">/* create a directory inside `dir` with name `dentry` */</span></span><br><span class=\"line\">  <span class=\"keyword\">int</span> (*mkdir) (struct inode *, struct dentry *, <span class=\"keyword\">umode_t</span>);</span><br><span class=\"line\">  <span class=\"comment\">/* ... */</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p><code>superblock</code>: it contains global information about the filesystem(partition) and created by filesystem and given to VFS at mount time. Disk-based filesystem store it in a special location and other filesystems have a way to generate it at mount time.</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* defined in `include/linux/fs.h` */</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">super_block</span> &#123;</span></span><br><span class=\"line\">  <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">list_head</span> <span class=\"title\">s_list</span>;</span>    <span class=\"comment\">/* list of all superblocks */</span></span><br><span class=\"line\">  <span class=\"keyword\">dev_t</span> s_dev;                <span class=\"comment\">/* identifier */</span></span><br><span class=\"line\">  <span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> s_blocksize; <span class=\"comment\">/* block size (bytes) */</span></span><br><span class=\"line\">  <span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> s_blocksize_bits <span class=\"comment\">/* block size (bits) */</span></span><br><span class=\"line\">  <span class=\"keyword\">loff_t</span> s_maxbytes; <span class=\"comment\">/* max file size */</span></span><br><span class=\"line\">  <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">file_system_type</span> *<span class=\"title\">s_type</span>;</span> <span class=\"comment\">/* filesystem type */</span></span><br><span class=\"line\">  <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">super_operations</span> *<span class=\"title\">s_op</span>;</span> <span class=\"comment\">/* superblock operations */</span></span><br><span class=\"line\">  <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">dquot_operations</span> *<span class=\"title\">dq_op</span>;</span> <span class=\"comment\">/* quota methods */</span></span><br><span class=\"line\">  <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">dquot_operations</span> *<span class=\"title\">s_qcop</span>;</span> <span class=\"comment\">/* quota control methods */</span></span><br><span class=\"line\">  <span class=\"comment\">/* ... */</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* defined in `include/linux/fs.h` */</span></span><br><span class=\"line\"><span class=\"comment\">/* each field is a function pointer operating on a struct super_block */</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">super_operations</span> &#123;</span></span><br><span class=\"line\">  <span class=\"comment\">/* creats and initialize a new inode */</span></span><br><span class=\"line\">  <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">inode</span> *(*<span class=\"title\">alloc_inode</span>) (<span class=\"keyword\">struct</span> <span class=\"title\">super_block</span> *<span class=\"title\">sb</span>);</span></span><br><span class=\"line\">  <span class=\"comment\">/* deallocate an inode */</span></span><br><span class=\"line\">  <span class=\"keyword\">void</span> (*destory_inode) (struct inode *);</span><br><span class=\"line\">  <span class=\"comment\">/* marks an inode as dirty(ext filesystems) */</span></span><br><span class=\"line\">  <span class=\"keyword\">void</span> (*dirty_inode) (struct inode *, <span class=\"keyword\">int</span> flags);</span><br><span class=\"line\">  <span class=\"comment\">/* writes the inode to disk, wait specifies if the wirte should be synchronoous */</span></span><br><span class=\"line\">  <span class=\"keyword\">int</span> (*write_inode) (struct inode *, struct writeback_control *wbc);</span><br><span class=\"line\">  <span class=\"comment\">/* called by VFS when the last reference to the inode is dropped */</span></span><br><span class=\"line\">  <span class=\"keyword\">int</span> (*drop_inode) (struct inode *);</span><br><span class=\"line\">  <span class=\"keyword\">void</span> (*evict_inode) (struct inode*);</span><br><span class=\"line\">  <span class=\"comment\">/* called by VFS on unmoount(holding s lock) */</span></span><br><span class=\"line\">  <span class=\"keyword\">void</span> (*put_super) (struct super_block *);</span><br><span class=\"line\">  <span class=\"comment\">/* synchronize filesystem metadata with on-disk filesystem, wait specifies if the operation should be synchronous */</span></span><br><span class=\"line\">  <span class=\"keyword\">int</span> (*sync_fs) (struct super_block *sb, <span class=\"keyword\">int</span> wait);</span><br><span class=\"line\">  <span class=\"comment\">/* ... */</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p><code>file</code>: it contains information about a file opened by a process and is created on <code>open()</code> and destroyed on <code>close()</code>.<br>\nTwo processes opening the same file: Two file objects, pointing to the same unique dentry, that points itself on a unique inode.<br>\nNo corresponding on-disk data structure.</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* defined in inculde/linux/fs.h */</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">file</span> &#123;</span></span><br><span class=\"line\">  <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">path</span> <span class=\"title\">f_path</span>;</span> <span class=\"comment\">/* contains the dentry */</span></span><br><span class=\"line\">  <span class=\"keyword\">spinlock_t</span> f_lock; <span class=\"comment\">/* lock */</span></span><br><span class=\"line\">  <span class=\"keyword\">atomic_t</span> f_count; <span class=\"comment\">/* usage count */</span></span><br><span class=\"line\">  <span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> f_flags; <span class=\"comment\">/* open flags */</span></span><br><span class=\"line\">  <span class=\"keyword\">mode_t</span> f_mode; <span class=\"comment\">/* file access mode */</span></span><br><span class=\"line\">  <span class=\"keyword\">logg_t</span> f_pos; <span class=\"comment\">/* file offset */</span></span><br><span class=\"line\">  <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">fown_struct</span> <span class=\"title\">f_owner</span>;</span> <span class=\"comment\">/* owner data for signals */</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">cred</span> *<span class=\"title\">f_cred</span>;</span> <span class=\"comment\">/* file credentials */</span></span><br><span class=\"line\">  <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">file_ra_state</span> <span class=\"title\">f_ra</span>;</span> <span class=\"comment\">/* read-ahead state */</span></span><br><span class=\"line\">  u64 f_version; <span class=\"comment\">/* version number */</span></span><br><span class=\"line\">  <span class=\"keyword\">void</span> *private_data; <span class=\"comment\">/* private data */</span></span><br><span class=\"line\">  <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">list_head</span> <span class=\"title\">f_ep_link</span>;</span> <span class=\"comment\">/* list of epoll links */</span></span><br><span class=\"line\">  <span class=\"keyword\">spinlock_t</span> f_ep_lock; <span class=\"comment\">/* epoll lock */</span></span><br><span class=\"line\">  <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">address_space</span> *<span class=\"title\">f_mapping</span>;</span> <span class=\"comment\">/* page cache mapping */</span></span><br><span class=\"line\">  <span class=\"comment\">/* ... */</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">file_operations</span> &#123;</span></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">module</span> *<span class=\"title\">owner</span>;</span></span><br><span class=\"line\">  <span class=\"comment\">/* update file offset */</span></span><br><span class=\"line\">\t<span class=\"keyword\">loff_t</span> (*llseek) (struct file *, <span class=\"keyword\">loff_t</span>, <span class=\"keyword\">int</span>);</span><br><span class=\"line\">  <span class=\"comment\">/* read operation */</span></span><br><span class=\"line\">\t<span class=\"keyword\">ssize_t</span> (*read) (struct file *, <span class=\"keyword\">char</span> user *, <span class=\"keyword\">size_t</span>, <span class=\"keyword\">loff_t</span> *); </span><br><span class=\"line\">  <span class=\"comment\">/* write operation */</span></span><br><span class=\"line\">  <span class=\"keyword\">ssize_t</span> (*write) (struct file *, <span class=\"keyword\">const</span> <span class=\"keyword\">char</span> user *, <span class=\"keyword\">size_t</span>, <span class=\"keyword\">loff_t</span> *);</span><br><span class=\"line\">  <span class=\"keyword\">ssize_t</span> (*read_iter) (struct kiocb *, struct iov_iter *);</span><br><span class=\"line\">  <span class=\"keyword\">ssize_t</span> (*write_iter) (struct kiocb *, struct iov_iter *);</span><br><span class=\"line\">  <span class=\"keyword\">int</span> (*iterate) (struct file *, struct dir_context *);</span><br><span class=\"line\">  <span class=\"keyword\">int</span> (*iterate_shared) (struct file *, struct dir_context *);</span><br><span class=\"line\">  <span class=\"comment\">/* sleeps waiting for activity on a given file */</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">unsigned</span> <span class=\"title\">int</span> <span class=\"params\">(*poll)</span> <span class=\"params\">(struct file *, struct poll_table_struct *)</span></span>;</span><br><span class=\"line\">  <span class=\"comment\">/* ... */</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>VFS implemented in a manner very close to object-oriented programming.</p>\n<h2 id=\"part.3-filesystem-and-process-data-structures\">Part.3 Filesystem and process data structures<a title=\"#part.3-filesystem-and-process-data-structures\" href=\"#part.3-filesystem-and-process-data-structures\"></a></h2>\n<h3 id=\"filesystem-data-structures\">Filesystem data structures<a title=\"#filesystem-data-structures\" href=\"#filesystem-data-structures\"></a></h3>\n<p><code>struct file_system_type</code>: information about a specific concrete filesystem type.<br>\nOne per filesystem supported (chosen at compile time) independently of the mounted filesystem.</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* defined in `incule/linux/fs.h` */</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">file_system_type</span> &#123;</span></span><br><span class=\"line\">\t<span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *name; <span class=\"comment\">/* name */</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> fs_flags; <span class=\"comment\">/* flags */</span></span><br><span class=\"line\">\t<span class=\"comment\">/* mount a partition */</span></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">dentry</span> *(*<span class=\"title\">mount</span>) (<span class=\"keyword\">struct</span> <span class=\"title\">file_system_type</span> *</span></span><br><span class=\"line\"><span class=\"class\">                           , <span class=\"title\">int</span>, <span class=\"title\">const</span> <span class=\"title\">char</span> *, <span class=\"title\">void</span> *);</span></span><br><span class=\"line\">\t<span class=\"comment\">/* terminate access to the superblock */</span></span><br><span class=\"line\">\t<span class=\"keyword\">void</span> (*kill_sb) (struct super_block *); <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">module</span> *<span class=\"title\">owner</span>;</span></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">file_system_type</span> * <span class=\"title\">next</span>;</span></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">hlist_head</span> <span class=\"title\">fs_supers</span>;</span></span><br><span class=\"line\">\t<span class=\"comment\">/* runtime lock validation */</span></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">lock_class_key</span> <span class=\"title\">s_lock_key</span>;</span></span><br><span class=\"line\">\t<span class=\"comment\">/* module owning the fs */</span></span><br><span class=\"line\">\t<span class=\"comment\">/* linked list of fs types */</span></span><br><span class=\"line\">\t<span class=\"comment\">/* linked list of superblocks */</span></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">lock_class_key</span> <span class=\"title\">s_umount_key</span>;</span></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">lock_class_key</span> <span class=\"title\">s_vfs_rename_key</span>;</span></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">lock_class_key</span> <span class=\"title\">s_writers_key</span>[<span class=\"title\">SB_FREEZE_LEVELS</span>];</span></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">lock_class_key</span> <span class=\"title\">i_lock_key</span>;</span> </span><br><span class=\"line\">  <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">lock_class_key</span> <span class=\"title\">i_mutex_key</span>;</span></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">lock_class_key</span> <span class=\"title\">i_mutex_dir_key</span>;</span> </span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>When a filesystem is mounted, a <code>vfsmount</code> structure is created which represents a specific instance of the filesystem: a mount point.</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* defined in `include/linux/mount.h` */</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">vfsmount</span> &#123;</span></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">dentry</span> *<span class=\"title\">mnt_root</span>;</span> <span class=\"comment\">/* root of the mounted tree */</span></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">super_block</span> *<span class=\"title\">mnt_sb</span>;</span> <span class=\"comment\">/* pointer to superblock */</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> mnt_flags; </span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h3 id=\"process-data-structure\">Process data structure<a title=\"#process-data-structure\" href=\"#process-data-structure\"></a></h3>\n<p><code>struct_files_struct</code>: contains per-process information about opened files and file descriptors. ( defined in <code>include/linux/fdtable.h</code>)<br>\n<code>struct_fs_struct</code>: filesystem information related to a process.(defined in <code>include/linux/fs struct.h</code>)<br>\n<code>struct_mnt_namespace</code>: provide processes with unique views of a mounted filesystem.(defined in <code>fs/mount.h</code>)</p>\n","prev":{"title":"Priority Queue","link":"2020/20201202-Priority-Queues"},"next":{"title":"Interrupts","link":"2020/20201109-Interrupts"},"plink":"https://oreodu.github.io/2020/20201118-File-Systems/","toc":[{"id":"file-systems","title":"File Systems","index":"1","children":[{"id":"part.1-general-presentation","title":"Part.1 General Presentation","index":"1.1"},{"id":"part.2-vfs-data-structures","title":"Part.2 VFS data structures","index":"1.2"},{"id":"part.3-filesystem-and-process-data-structures","title":"Part.3 Filesystem and process data structures","index":"1.3"}]}],"reward":true,"copyright":{"author":"Oreo Du","link":"<a href=\"https://oreodu.github.io/2020/20201118-File-Systems/\" title=\"File Systems\">https://oreodu.github.io/2020/20201118-File-Systems/</a>","license":"Attribution-NonCommercial-NoDerivatives 4.0 International (<a href=\"https://creativecommons.org/licenses/by-nc-sa/4.0/\" rel=\"external nofollow noopener\" target=\"_blank\">CC BY-NC-ND 4.0</a>)"}}