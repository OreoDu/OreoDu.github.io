{"title":"Programs Basics 01","date":"2020-09-10T05:07:00.000Z","thumbnail":"https://i.loli.net/2020/09/09/hpqrHXILJGxeSbO.jpg","slug":"20200910-Programs-Basics-01","comments":true,"tags":["Basics"],"categories":["Programming"],"updated":"2020-10-01T12:52:57.564Z","content":"<h1 id=\"Programs-Basis-01\">Programs Basis 01<a href=\"post/20200910-Programs-Basics-01#Programs-Basis-01\"></a></h1><h3 id=\"Overview\">Overview<a href=\"post/20200910-Programs-Basics-01#Overview\"></a></h3><p>(概略图)</p>\n<p><strong>· materials:</strong><br>  · <i>Structure and Interpretation of Computer Programs</i> by Harold Abelson and Gerald Jay Sussman with Julie Sussman<br>  · <a href=\"https://inst.eecs.berkeley.edu/~cs61a/su19/\" target=\"_blank\" rel=\"noopener\"><u>CS61A Summer 2019 at UCB</u></a><br>  · Wikipedia</p>\n<p>Goals of Program Decomposition<br>1.Complexity Management<br>2.Reusability and abstraction</p>\n<h3 id=\"Part-1-Building-Abstractions-with-Procedures\">Part.1 Building Abstractions with Procedures<a href=\"post/20200910-Programs-Basics-01#Part-1-Building-Abstractions-with-Procedures\"></a></h3><p>A <strong>function</strong> should solve one problem.</p>\n<p>A function should have the <strong>smallest</strong> <strong>number of parameters</strong> possible to solve its problem.</p>\n<p>A repeated sequence should be put in its own function.<br>    Avoid repeating more than a couple lines of code. </p>\n<p>micro level - take one of those smaller functions and identify smaller problems within that that WONT necessarily identifying separate questions and reusing them</p>\n<h3 id=\"Part-2-Building-Abstractions-with-Data\">Part.2 Building Abstractions with Data<a href=\"post/20200910-Programs-Basics-01#Part-2-Building-Abstractions-with-Data\"></a></h3><p>Data abstraction lets us manipulate compound values as units.</p>\n<p>Isolate two parts of any program that uses data:<br>How data are represented (as parts)<br>How data are manipulated (as units)<br>Data abstraction: A methodology by which functions enforce an abstraction barrier between representation and use.</p>\n<p><strong>Abstraction Barriers:</strong></p>\n<pre class=\" language-python\"><code class=\"language-python\"><span class=\"token comment\" spellcheck=\"true\"># constructor rational(n,d)  returns a rational number </span>\n<span class=\"token comment\" spellcheck=\"true\"># Selector numerator(x),     returns the numerator of x</span>\n<span class=\"token comment\" spellcheck=\"true\">#          denominator(x)    returns the denominator of x</span>\n<span class=\"token keyword\">def</span> <span class=\"token function\">mul_rational</span><span class=\"token punctuation\">(</span>x<span class=\"token punctuation\">,</span> y<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n    <span class=\"token keyword\">return</span> rational<span class=\"token punctuation\">(</span>numer<span class=\"token punctuation\">(</span>x<span class=\"token punctuation\">)</span> <span class=\"token operator\">*</span> numer<span class=\"token punctuation\">(</span>y<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n                    denom<span class=\"token punctuation\">(</span>x<span class=\"token punctuation\">)</span> <span class=\"token operator\">*</span> denom<span class=\"token punctuation\">(</span>y<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n\n<span class=\"token keyword\">def</span> <span class=\"token function\">add_rational</span><span class=\"token punctuation\">(</span>x<span class=\"token punctuation\">,</span> y<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n    nx<span class=\"token punctuation\">,</span> dx <span class=\"token operator\">=</span> numer<span class=\"token punctuation\">(</span>x<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> denom<span class=\"token punctuation\">(</span>x<span class=\"token punctuation\">)</span>\n    ny<span class=\"token punctuation\">,</span> dy <span class=\"token operator\">=</span> numer<span class=\"token punctuation\">(</span>y<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> denom<span class=\"token punctuation\">(</span>y<span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">return</span> rational<span class=\"token punctuation\">(</span>nx <span class=\"token operator\">*</span> dy <span class=\"token operator\">+</span> ny <span class=\"token operator\">*</span> dx<span class=\"token punctuation\">,</span> dx <span class=\"token operator\">*</span> dy<span class=\"token punctuation\">)</span>\n\n<span class=\"token keyword\">def</span> <span class=\"token function\">print_rational</span><span class=\"token punctuation\">(</span>x<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n    <span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span>numer<span class=\"token punctuation\">(</span>x<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'/'</span><span class=\"token punctuation\">,</span> denom<span class=\"token punctuation\">(</span>x<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n\n<span class=\"token keyword\">def</span> <span class=\"token function\">rationals_are_equal</span><span class=\"token punctuation\">(</span>x<span class=\"token punctuation\">,</span> y<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n    <span class=\"token keyword\">return</span> numer<span class=\"token punctuation\">(</span>x<span class=\"token punctuation\">)</span> <span class=\"token operator\">*</span> denom<span class=\"token punctuation\">(</span>y<span class=\"token punctuation\">)</span> <span class=\"token operator\">==</span> numer<span class=\"token punctuation\">(</span>y<span class=\"token punctuation\">)</span> <span class=\"token operator\">*</span> denom<span class=\"token punctuation\">(</span>x<span class=\"token punctuation\">)</span></code></pre>\n<div class=\"article-bounded\"><div class=\"article-table\"><table>\n<thead>\n<tr>\n<th>Parts of the program that…</th>\n<th>Treat rationals as…</th>\n<th>Using…</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Use rational numbers to perform computation</td>\n<td>whole data values</td>\n<td>add_rational, mul_rational, rationals_are_equal, print_rational</td>\n</tr>\n<tr>\n<td>Create rationals or implement rational operations</td>\n<td>numerators and denominators</td>\n<td>rational, numer, denom</td>\n</tr>\n<tr>\n<td>Implement selectors and constructor for rationals</td>\n<td>two-element lists</td>\n<td>list literals and element selection</td>\n</tr>\n</tbody></table></div></div>\n<ul>\n<li><p>Decomposition</p>\n<p><strong>Program Decomposition</strong> is a process for breaking down large problems into logical sub-problems.</p>\n</li>\n</ul>\n<p>1.A well decomposed function is sometimes likened to a “black box”. The black box presents the simplest possible abstraction to describe what the output will be and hides the implementation. Its inner workings are not revealed. </p>\n<p>Data abstraction is an example of this. For constructors &amp; selectors, we don’t care about the body of the function. We only need to know what they take as input and their intended result.</p>\n<p>2.Decomposition is a divide and conquer strategy. （The process of breaking a large problem into more manageable sub-problems）</p>\n<p>From the outside, black boxes are simply defined in terms of their input and output, so they are easy to piece together.</p>\n<h3 id=\"Part-3-Program-Paradigms\">Part.3 Program Paradigms<a href=\"post/20200910-Programs-Basics-01#Part-3-Program-Paradigms\"></a></h3><p>Program is the way approach writing program and program’s relationship to how it’s executed by  the interpreter or complier.</p>\n<p><strong>Imperative program</strong> contain explicit instructions to tell the computer <strong>how</strong> to accomplish something. The interpreter(which is designed to execute as optimally as possible) then executes those instructions.</p>\n<p><strong>Declarative programming</strong>, where we can just tell the computer <strong>what</strong> we want, instead of how we want it done. The interpreter then figures out how to accomplish that.</p>\n<h3 id=\"Part-4-Interpreting-Computer-Programs\">Part.4 Interpreting Computer Programs<a href=\"post/20200910-Programs-Basics-01#Part-4-Interpreting-Computer-Programs\"></a></h3><p>*<em>Ⅰ. Interpreter *</em></p>\n<p>There are two languages involved:<br>    Implemented language: this is the language the user types in.<br>    Implementation language: this is the language that interpreter is implemented in.<br>    (Implemented Language is translated into the Implementation Language)</p>\n<p>The translation step in a couple forms:<br>Compiled (pre-translated) - translate all at once and run later. (C, C++…)<br>Interpreted (translated on-the-fly) - translate while the program is running. (Python, Java…)</p>\n<p>An interpreter does 3 things:<br>    Reads input from user in a specific programming language.<br>    Translates input to be computer readable and evaluates the result.<br>    Prints the result for the user.</p>\n<img src=\"https://i.loli.net/2020/09/15/jOYo8UFcEsZbHhB.png\" alt=\"12\" style=\"zoom:80%;\">\n\n<p>​                                                    (from CS61A Summer 2019 at UCB)</p>\n<p><strong>1.Read</strong></p>\n<p>1.Lexical Analysis (Lexer):<br>Turning the input into a collection of <em>tokens</em>. A token: single input of the input string, e.g. literals, names, keywords, delimiters.</p>\n<p>2.Syntactic Analysis (Parser):<br>Turning tokens into a representation of the expression in the implementing language.</p>\n<p><strong>2.Evaluate</strong></p>\n<p>Rules for evaluating an expression depends on the expression’s type.</p>\n<p><strong>· Frames and Environments</strong></p>\n<p>When evaluating expressions, the current environment consists of the current frame, its parent frame, and all its ancestor frames until the Global Frame.</p>\n<p>Frames are represented in our interpreter as instances of the <strong>Frame</strong> class. Each frame instance has two instance attributes:<br><strong>bindings</strong>: a dictionary that binds strings to values.<br><strong>parent</strong>: the parent frame, another <strong>Frame</strong> instance.</p>\n<p>The evaluator needs to know the current environment, given as a single <strong>Frame</strong> instance, in order to look up names in expressions.</p>\n<p><a href=\"https://oreodu.github.io/2020/09/15/20200915-Scheme-Language-Basis/\"><u>See the evaluating process of Scheme here</u></a></p>\n<h3 id=\"Part-3-Modularity-Objects-and-State\">Part.3 Modularity, Objects, and State<a href=\"post/20200910-Programs-Basics-01#Part-3-Modularity-Objects-and-State\"></a></h3><h3 id=\"Part-4-Meta-Linguistic-Abstraction\">Part.4 Meta-Linguistic Abstraction<a href=\"post/20200910-Programs-Basics-01#Part-4-Meta-Linguistic-Abstraction\"></a></h3><h3 id=\"Part-5-Register-Machine’-Model-of-Control\">Part.5 Register Machine’ Model of Control<a href=\"post/20200910-Programs-Basics-01#Part-5-Register-Machine’-Model-of-Control\"></a></h3>","prev":{"title":"Scheme Basics","slug":"20200915-Scheme-Basics"},"next":{"title":"Python Basis 03","slug":"20200908-Python-Basics-03"},"link":"https://oreodu.github.io/post/20200910-Programs-Basics-01/","toc":[{"title":"Programs Basis 01","id":"Programs-Basis-01","index":"1"}],"reward":true,"copyright":{"author":null,"link":"<a href=\"https://oreodu.github.io/post/20200910-Programs-Basics-01/\" title=\"Programs Basics 01\">https://oreodu.github.io/post/20200910-Programs-Basics-01/</a>","license":"Attribution-NonCommercial-NoDerivatives 4.0 International (<a href=\"https://creativecommons.org/licenses/by-nc-sa/4.0/\" rel=\"external nofollow noopener\" target=\"_blank\">CC BY-NC-ND 4.0</a>)"}}