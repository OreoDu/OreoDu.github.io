{"title":"Process Management","date":"2020-10-24T02:13:00.000Z","date_formatted":{"ll":"Oct 24, 2020","L":"10/24/2020","MM-DD":"10-24"},"link":"2020/20201024-Process-Management","comments":true,"tags":["Operating System"],"categories":["Linux","Operating System"],"updated":"2020-10-25T03:29:38.290Z","content":"<h1 id=\"process-management\">Process Management<a title=\"#process-management\" href=\"#process-management\"></a></h1>\n<h2 id=\"part.1-process\">Part.1 Process<a title=\"#part.1-process\" href=\"#part.1-process\"></a></h2>\n<p>Every application(program) comes into execution through means of process, <strong>process</strong> is a running instance of a program. Processes are created through different system calls, most popular are <strong>fork()</strong> and <strong>exec()</strong>.</p>\n<p>The fork() creates a new process by duplicating the calling process, The new process, referred to as child, is an exact duplicate of the calling process, referred to as parent.</p>\n<p>In computing, exec is a functionality of an operating system that runs an executable file in the context of an already existing process, replacing the previous executable.  As a new process is not created, the process identifier (PID) does not change, but the machine code, data, heap, and stack of the process are replaced by those of the new program.</p>\n<img src=\"https://tva1.sinaimg.cn/large/0081Kckwgy1gk082r4imbj30bq0kg40e.jpg\" alt=\"Screen Shot 2020-10-24 at 10.38.27\" style=\"zoom:33%;\">\n<p>Tutorial on [<code>fork()</code>](<a href=\"http://www.csl.mtu.edu/cs4411.ck/www/NOTES/\">http://www.csl.mtu.edu/cs4411.ck/www/NOTES/</a> process/fork/create.html) usage.<br>\nCombining <a href=\"https://ece.uwaterloo.ca/dwharder/icsrts/Tutorials/fork_exec/\" target=\"_blank\"> <code>fork()</code> and <code>exec()</code></a>. (execl(), execlp(), execle(), execv(), execvp(), execve())</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (fork() == <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">//child process</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">char</span> * execve_str[] = &#123;<span class=\"string\">&quot;env&quot;</span>,<span class=\"literal\">NULL</span>&#125;;</span><br><span class=\"line\">\t\t<span class=\"keyword\">char</span> * env[] = &#123;<span class=\"string\">&quot;PATH=/tmp&quot;</span>, <span class=\"string\">&quot;USER=lei&quot;</span>, <span class=\"string\">&quot;STATUS=testing&quot;</span>, <span class=\"literal\">NULL</span>&#125;;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (execve(<span class=\"string\">&quot;/usr/bin/env&quot;</span>,execve_str,env) &lt;<span class=\"number\">0</span> )&#123;</span><br><span class=\"line\">\t\t\tperror(<span class=\"string\">&quot;error on exec&quot;</span>);</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">exit</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">&#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">//parent process</span></span><br><span class=\"line\">\t\twait(&amp;childpid);</span><br><span class=\"line\">\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;execve done\\n\\n&quot;</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"part.2-the-process-descriptor\">Part.2 The process descriptor<a title=\"#part.2-the-process-descriptor\" href=\"#part.2-the-process-descriptor\"></a></h2>\n<p>See more details from <a href=\"https://elixir.bootlin.com/linux/latest/C/ident/task_struct\" target=\"_blank\">here</a> or <a href=\"http://www.science.smith.edu/~nhowe/262/oldlabs/sched.html\" target=\"_blank\">here</a>.</p>\n<p>In the Linux kernel, processes are defined as <code>task_struct</code> structures in <code>include/linux/sched.h</code>, line 281. This structure contains every relevant information about a process.</p>\n<p>List of processes implemented as a linked list of <code>task struct</code>. It is dynamically allocated (heap) through the slab allocator.</p>\n<p>Quick access to <code>task struct</code> of the task currently running on a core: arch/x86/include/asm/current.h.</p>\n<img src=\"https://tva1.sinaimg.cn/large/0081Kckwgy1gk0iv2pigvj30b60degmo.jpg\" alt=\"Screen Shot 2020-10-24 at 16.51.34\" style=\"zoom: 50%;\">\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* Full structure definition in linux/sched.h */</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">tastk_struct</span> &#123;</span> </span><br><span class=\"line\">\t<span class=\"keyword\">volatile</span> <span class=\"keyword\">long</span> state; </span><br><span class=\"line\">  <span class=\"keyword\">void</span> *<span class=\"built_in\">stack</span>;</span><br><span class=\"line\">\t<span class=\"comment\">/* ... */</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> prio; </span><br><span class=\"line\">  <span class=\"comment\">/* ... */</span></span><br><span class=\"line\">\t<span class=\"keyword\">cpumask_t</span> cpus_allowed;</span><br><span class=\"line\">\t<span class=\"comment\">/* ... */</span></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">list_head</span> <span class=\"title\">tasks</span>;</span> </span><br><span class=\"line\">  <span class=\"comment\">/* ... */</span></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">mm_struct</span> *<span class=\"title\">mm</span>;</span> </span><br><span class=\"line\">  <span class=\"comment\">/* ... */</span></span><br><span class=\"line\">\t<span class=\"keyword\">pid_t</span> pid;</span><br><span class=\"line\">\t<span class=\"comment\">/* ... */</span></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">task_struct</span> *<span class=\"title\">parent</span>;</span></span><br><span class=\"line\">  <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">list_head</span> <span class=\"title\">children</span>;</span></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">list_head</span> <span class=\"title\">sibling</span>;</span> </span><br><span class=\"line\">  <span class=\"comment\">/* ... */</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"process-states\">Process states<a title=\"#process-states\" href=\"#process-states\"></a></h3>\n<p>State field of the task struct:</p>\n<p>· <code>TASK_RUNNING</code>:<br>\nProcess is runnable (running or in a CPU run queue) In user or kernel space.</p>\n<p>· <code>TASK_INTERRUPTIBLE</code>:<br>\nProcess is sleeping waiting for some condition.<br>\nSwitched to TASK RUNNING on condition true or signal received.</p>\n<p>· <code>TASK_UNINTERRUPTIBLE</code>:<br>\nSame as TASK INTERRUPTIBLE but does not wake up on signal.</p>\n<p>· <code>TASK_TRACED</code>:<br>\nTraced by another process(ex:debugger)</p>\n<p>· <code>TASK_STOPPED</code>:<br>\nNot running nor waiting,result of the reception of some signals to pause the process.</p>\n<img src=\"https://tva1.sinaimg.cn/large/0081Kckwgy1gk0jhtmibbj319m0o0gv2.jpg\" alt=\"Screen Shot 2020-10-24 at 17.12.52\" style=\"zoom: 33%;\">\n<h3 id=\"process-hierarchy\">Process hierarchy<a title=\"#process-hierarchy\" href=\"#process-hierarchy\"></a></h3>\n<p>· Root: init, PID 1<br>\nLaunched by the kernel as the last step of the boot process.<br>\n· fork-based process creation:<br>\nEach process has aparent: parent pointer in the <code>task_struct</code>.<br>\n· Processes may have children: children field(list head).<br>\n· Processes may have siblings: siblings field.<br>\n· List of all tasks: tasks field.<br>\nEasy manipulation through <code>next task(t)</code> and <code>for eachprocess(t)</code>.</p>\n<h2 id=\"part.3-process-creation\">Part.3 Process creation<a title=\"#part.3-process-creation\" href=\"#part.3-process-creation\"></a></h2>\n<p>Linux does not implements creating a tasks from nothing.</p>\n<p><code>fork()</code> &amp; <code>exec()</code></p>\n<p>· <code>fork()</code> creates a child, copy of the parent process. Only PID, PPID and some resources/stats differ. Linux duplicates the parent page tables and creates a new process descriptor.</p>\n<p>Page table access bits: read-only.<br>\nCopy-On-Write (COW): memory pages are copied only when they are referenced for write operations.</p>\n<p>· <code>exec()</code> loads into a process address space a new executable.</p>\n<h3 id=\"forking-:-fork()-and-vfork()\">Forking : <code>fork()</code> and <code>vfork()</code><a title=\"#forking-:-fork()-and-vfork()\" href=\"#forking-:-fork()-and-vfork()\"></a></h3>\n<p><code>fork()</code> is implemented by the <code>clone()</code> system call. <code>sys_clone()</code> calls <code>do_fork()</code>, which calls <code>copy_process()</code> and starts the new task.</p>\n<p><code>copy_process()</code>:</p>\n<ol>\n<li>Calls <code>dup_tasks_truct()</code>. Duplicates kernel stack, <code>task_struct</code> and <code>thread_info</code>.</li>\n<li>Checks that we do not overflow the processes number limit.</li>\n<li>Small amount of values are modified in the <code>task_struct</code>.</li>\n<li>Calls <code>sched_fork()</code> to set the child <code>state</code> set to <code>TASK_NEW</code> .</li>\n<li>Copies parent info: files, signal handlers, etc.</li>\n<li>Gets a new PID through <code>alloc_pid()</code>.</li>\n<li>Returns a pointer to the created child <code>task_struct</code>.</li>\n</ol>\n<p>Finally, <code>do_fork()</code> calls wake up <code>new_task()</code>. State becomes <code>TASK_RUNNING</code></p>\n<p><code>vfork()</code>: alternative without copy of the address space.</p>\n<h2 id=\"part.4-threads\">Part.4 Threads<a title=\"#part.4-threads\" href=\"#part.4-threads\"></a></h2>\n<p>Threads are concurrent flows of execution belonging to the same program sharing the same address space.</p>\n<img src=\"https://tva1.sinaimg.cn/large/0081Kckwgy1gk0qkit41ej30f20eggnv.jpg\" alt=\"Screen Shot 2020-10-24 at 21.18.20\" style=\"zoom:50%;\">\n<p>In Linux there is no concept of a thread.<br>\n<a href=\"http://1.No\">1.No</a> scheduling particularity.<br>\n2.A thread is just another process sharing some information with other processes<br>\n3.Each thread has its own <code>task_struct</code>.<br>\n4.Created through <code>clone()</code> with specific flags indicating sharing.</p>\n<h3 id=\"kernel-threads\">Kernel threads<a title=\"#kernel-threads\" href=\"#kernel-threads\"></a></h3>\n<p>Kernel threads are schedulable entities (like regular processes) and do not have their own address space( <code>mm</code>  in <code>task_struct</code> is NULL).</p>\n<p>Kernel threads are all forked from the <code>kthread </code> kernel thread (PID 2), using <code>clone()</code>. To create a kernel thread, use <code>kthread_create() </code>.</p>\n<p>When created through <code>kthread_create()</code>, the thread is not in a runnable state and need to call <code>wake_up_process()</code> or use <code>kthread run()</code>.</p>\n<p>Thread runs until it calls do <code>exit()</code> or until another part of the kernel calls <code>kthread_stop()</code>.</p>\n<h2 id=\"part.5-process-termination\">Part.5 Process termination<a title=\"#part.5-process-termination\" href=\"#part.5-process-termination\"></a></h2>\n<p>Termination on invoking the <code>exit()</code> system call which can be implicitly inserted by the compiler on <code>return</code> from <code>main</code>. <code>sys_exit()</code> calls <code>do_exit()</code>.</p>\n<h3 id=\"do-exit()-(kernel/exit.c):\"><code>do exit()</code> (kernel/exit.c):<a title=\"#do-exit()-(kernel/exit.c):\" href=\"#do-exit()-(kernel/exit.c):\"></a></h3>\n<ol>\n<li>Call <code>exit_signals()</code> which set the <code>PF EXITING</code> flag in the <code>task_struct</code></li>\n<li>Set the exit code in the <code>exit_code</code> field of the <code>task_struct</code>. (To be retrieved by the parent.)</li>\n<li>Call <code>exit_mm()</code> to release the <code>mm_struct</code> for the task. If it is not shared with any other process, it is destroyed.</li>\n<li>Call <code>exit_sem()</code>:process dequeued from potential semaphores queues.</li>\n<li>Call <code>exit_fs()</code> and <code>exit_files()</code> to update accounting information. Potential data structures that are not used anymore are freed.</li>\n<li>Call <code>exit_notify()</code>. Send signals to parent and reparent potential children. Set the <code>exit_state</code> of the <code>task_struct</code> to <code>EXIT ZOMBIE</code> .</li>\n<li>Call <code>do_taskdead()</code>. Set the <code>state</code> to <code>TASK DEAD</code> ,  call <code>schedule()</code> and never returns.</li>\n</ol>\n<p>At that point, what is left is the <code>task_struct</code>, <code>thread info</code> and kernel stack. To provide information to the parent. Parent notifies the kernel when everything can be freed.</p>\n<h3 id=\"task_struct-cleanup:\"><code>task_struct</code> cleanup:<a title=\"#task_struct-cleanup:\" href=\"#task_struct-cleanup:\"></a></h3>\n<ol>\n<li>\n<p>Separated from the process of exiting because of the need to pass exit information to the parent. Until the parent grab the exit information through <code>wait4()</code>.</p>\n</li>\n<li>\n<p>Cleanup implemented in <code>release_task()</code> called from the <code>wait4()</code> implementation.</p>\n<p>Remove the task from the task list. Release and free remaining resources.</p>\n</li>\n</ol>\n<p>A parent exits before its child. Child must be reparented(To another process in the current thread group or <code>init</code> if that fails).</p>\n<p><code>exit notify()</code> calls <code>forget_original_parent()</code>, that calls <code>find_newreaper()</code>. Returns the <code>task_struct</code> of another task in the thread group if it exists, otherwise the one from init. Then, all the children of the currently dying task are reparented to the reaper.</p>\n","prev":{"title":"Memory Management","link":"2020/20201025-Memory-Management"},"next":{"title":"Linux Basics","link":"2020/20201023-Linux-Basics"},"plink":"https://oreodu.github.io/2020/20201024-Process-Management/","toc":[{"id":"process-management","title":"Process Management","index":"1","children":[{"id":"part.1-process","title":"Part.1 Process","index":"1.1"},{"id":"part.2-the-process-descriptor","title":"Part.2 The process descriptor","index":"1.2"},{"id":"part.3-process-creation","title":"Part.3 Process creation","index":"1.3"},{"id":"part.4-threads","title":"Part.4 Threads","index":"1.4"},{"id":"part.5-process-termination","title":"Part.5 Process termination","index":"1.5"}]}],"reward":true,"copyright":{"author":"Oreo Du","link":"<a href=\"https://oreodu.github.io/2020/20201024-Process-Management/\" title=\"Process Management\">https://oreodu.github.io/2020/20201024-Process-Management/</a>","license":"Attribution-NonCommercial-NoDerivatives 4.0 International (<a href=\"https://creativecommons.org/licenses/by-nc-sa/4.0/\" rel=\"external nofollow noopener\" target=\"_blank\">CC BY-NC-ND 4.0</a>)"}}